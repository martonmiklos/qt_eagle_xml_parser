// This file is generated by kxml_compiler from /home/mm/Projektek/qt/e2b/tools/eagle.xsd.
// All changes you do to this file will be lost.

#include "eagle.h"

#include <QtDebug>
#include <QFile>
#include <QDomDocument>

void Layer::setNumber( int v )
{
  mNumber = v;
}

int Layer::number() const
{
  return mNumber;
}

void Layer::setName( const QString &v )
{
  mName = v;
}

QString Layer::name() const
{
  return mName;
}

void Layer::setColor( int v )
{
  mColor = v;
}

int Layer::color() const
{
  return mColor;
}

void Layer::setFill( int v )
{
  mFill = v;
}

int Layer::fill() const
{
  return mFill;
}

void Layer::setVisible( const VisibleEnum &v )
{
  mVisible = v;
}

Layer::VisibleEnum Layer::visible() const
{
  return mVisible;
}

void Layer::setActive( const ActiveEnum &v )
{
  mActive = v;
}

Layer::ActiveEnum Layer::active() const
{
  return mActive;
}

Layer::VisibleEnum Layer::visibleEnumFromString( const QString & v, bool *ok )
{
  if (ok) *ok = true;

  if ( v == "no" ) {
    return Visible_no;
  } else if ( v == "yes" ) {
    return Visible_yes;
  } else {
    if (ok) *ok = false;
    return Visible_Invalid;
  }

  return Visible_Invalid;
}

QString Layer::visibleEnumToString( const VisibleEnum & v )
{
  switch( v ) {
    case Visible_no: return "no";
    case Visible_yes: return "yes";
    case Visible_Invalid:
    default:
      qCritical() << "Unable to serialize a(n) VisibleEnum enum because it has invalid value" << v;
      return QString();
  }
}

Layer::ActiveEnum Layer::activeEnumFromString( const QString & v, bool *ok )
{
  if (ok) *ok = true;

  if ( v == "no" ) {
    return Active_no;
  } else if ( v == "yes" ) {
    return Active_yes;
  } else {
    if (ok) *ok = false;
    return Active_Invalid;
  }

  return Active_Invalid;
}

QString Layer::activeEnumToString( const ActiveEnum & v )
{
  switch( v ) {
    case Active_no: return "no";
    case Active_yes: return "yes";
    case Active_Invalid:
    default:
      qCritical() << "Unable to serialize a(n) ActiveEnum enum because it has invalid value" << v;
      return QString();
  }
}

Layer Layer::parseElement( const QDomElement &element, bool *ok )
{
  if ( element.tagName() != "layer" ) {
    qCritical() << "Expected 'layer', got '" << element.tagName() << "'.";
    if ( ok ) *ok = false;
    return Layer();
  }

  Layer result = Layer();

  result.setNumber( element.attribute( "number" ).toInt() );
  result.setName( element.attribute( "name" ) );
  result.setColor( element.attribute( "color" ).toInt() );
  result.setFill( element.attribute( "fill" ).toInt() );
  if (element.hasAttribute("visible"))  {
    VisibleEnum visible = visibleEnumFromString( element.attribute( "visible" ), ok  );
    if (ok && *ok == false) {
      qCritical() << "Invalid string: \"" << element.attribute( "visible" ) << "\" in the \"visible\" element";
      return Layer();
    } else {
      result.setVisible( visible );
    }
  } else {
    result.setVisible(visibleEnumFromString("no"));
  }
  if (element.hasAttribute("active"))  {
    ActiveEnum active = activeEnumFromString( element.attribute( "active" ), ok  );
    if (ok && *ok == false) {
      qCritical() << "Invalid string: \"" << element.attribute( "active" ) << "\" in the \"active\" element";
      return Layer();
    } else {
      result.setActive( active );
    }
  } else {
    result.setActive(activeEnumFromString("yes"));
  }

  if ( ok ) *ok = true;
  return result;
}

void Layer::writeElement( QXmlStreamWriter &xml ) const
{
  xml.writeEmptyElement( "layer" );
}


void Layers::addLayer( const Layer &v )
{
  mLayerList.append( v );
}

void Layers::setLayerList( const Layer::List &v )
{
  mLayerList = v;
}

Layer::List Layers::layerList() const
{
  return mLayerList;
}

Layers Layers::parseElement( const QDomElement &element, bool *ok )
{
  if ( element.tagName() != "layers" ) {
    qCritical() << "Expected 'layers', got '" << element.tagName() << "'.";
    if ( ok ) *ok = false;
    return Layers();
  }

  Layers result = Layers();

  QDomNode n;
  for( n = element.firstChild(); !n.isNull(); n = n.nextSibling() ) {
    QDomElement e = n.toElement();
    if ( e.tagName() == "layer" ) {
      bool ok;
      Layer o = Layer::parseElement( e, &ok );
      if ( ok ) result.addLayer( o );
    }
  }


  if ( ok ) *ok = true;
  return result;
}

void Layers::writeElement( QXmlStreamWriter &xml ) const
{
  if ( !layerList().isEmpty() ) {
    xml.writeStartElement( "layers" );
    foreach( Layer e, layerList() ) {
      e.writeElement( xml );
    }
    xml.writeEndElement();
  }
}


void Grid::setDistance( int v )
{
  mDistance = v;
}

int Grid::distance() const
{
  return mDistance;
}

void Grid::setUnitdist( const UnitdistEnum &v )
{
  mUnitdist = v;
}

Grid::UnitdistEnum Grid::unitdist() const
{
  return mUnitdist;
}

void Grid::setUnit( const UnitEnum &v )
{
  mUnit = v;
}

Grid::UnitEnum Grid::unit() const
{
  return mUnit;
}

void Grid::setStyle( const StyleEnum &v )
{
  mStyle = v;
}

Grid::StyleEnum Grid::style() const
{
  return mStyle;
}

void Grid::setMultiple( int v )
{
  mMultiple = v;
}

int Grid::multiple() const
{
  return mMultiple;
}

void Grid::setDisplay( const DisplayEnum &v )
{
  mDisplay = v;
}

Grid::DisplayEnum Grid::display() const
{
  return mDisplay;
}

void Grid::setAltdistance( double v )
{
  mAltdistance = v;
}

double Grid::altdistance() const
{
  return mAltdistance;
}

void Grid::setAltunitdist( const AltunitdistEnum &v )
{
  mAltunitdist = v;
}

Grid::AltunitdistEnum Grid::altunitdist() const
{
  return mAltunitdist;
}

void Grid::setAltunit( const AltunitEnum &v )
{
  mAltunit = v;
}

Grid::AltunitEnum Grid::altunit() const
{
  return mAltunit;
}

Grid::UnitdistEnum Grid::unitdistEnumFromString( const QString & v, bool *ok )
{
  if (ok) *ok = true;

  if ( v == "mic" ) {
    return Unitdist_mic;
  } else if ( v == "mm" ) {
    return Unitdist_mm;
  } else if ( v == "mil" ) {
    return Unitdist_mil;
  } else if ( v == "inch" ) {
    return Unitdist_inch;
  } else {
    if (ok) *ok = false;
    return Unitdist_Invalid;
  }

  return Unitdist_Invalid;
}

QString Grid::unitdistEnumToString( const UnitdistEnum & v )
{
  switch( v ) {
    case Unitdist_mic: return "mic";
    case Unitdist_mm: return "mm";
    case Unitdist_mil: return "mil";
    case Unitdist_inch: return "inch";
    case Unitdist_Invalid:
    default:
      qCritical() << "Unable to serialize a(n) UnitdistEnum enum because it has invalid value" << v;
      return QString();
  }
}

Grid::UnitEnum Grid::unitEnumFromString( const QString & v, bool *ok )
{
  if (ok) *ok = true;

  if ( v == "mic" ) {
    return Unit_mic;
  } else if ( v == "mm" ) {
    return Unit_mm;
  } else if ( v == "mil" ) {
    return Unit_mil;
  } else if ( v == "inch" ) {
    return Unit_inch;
  } else {
    if (ok) *ok = false;
    return Unit_Invalid;
  }

  return Unit_Invalid;
}

QString Grid::unitEnumToString( const UnitEnum & v )
{
  switch( v ) {
    case Unit_mic: return "mic";
    case Unit_mm: return "mm";
    case Unit_mil: return "mil";
    case Unit_inch: return "inch";
    case Unit_Invalid:
    default:
      qCritical() << "Unable to serialize a(n) UnitEnum enum because it has invalid value" << v;
      return QString();
  }
}

Grid::StyleEnum Grid::styleEnumFromString( const QString & v, bool *ok )
{
  if (ok) *ok = true;

  if ( v == "continuous" ) {
    return Style_continuous;
  } else if ( v == "longdash" ) {
    return Style_longdash;
  } else if ( v == "shortdash" ) {
    return Style_shortdash;
  } else if ( v == "dashdot" ) {
    return Style_dashdot;
  } else {
    if (ok) *ok = false;
    return Style_Invalid;
  }

  return Style_Invalid;
}

QString Grid::styleEnumToString( const StyleEnum & v )
{
  switch( v ) {
    case Style_continuous: return "continuous";
    case Style_longdash: return "longdash";
    case Style_shortdash: return "shortdash";
    case Style_dashdot: return "dashdot";
    case Style_Invalid:
    default:
      qCritical() << "Unable to serialize a(n) StyleEnum enum because it has invalid value" << v;
      return QString();
  }
}

Grid::DisplayEnum Grid::displayEnumFromString( const QString & v, bool *ok )
{
  if (ok) *ok = true;

  if ( v == "off" ) {
    return Display_off;
  } else if ( v == "value" ) {
    return Display_value;
  } else if ( v == "name" ) {
    return Display_name;
  } else if ( v == "both" ) {
    return Display_both;
  } else {
    if (ok) *ok = false;
    return Display_Invalid;
  }

  return Display_Invalid;
}

QString Grid::displayEnumToString( const DisplayEnum & v )
{
  switch( v ) {
    case Display_off: return "off";
    case Display_value: return "value";
    case Display_name: return "name";
    case Display_both: return "both";
    case Display_Invalid:
    default:
      qCritical() << "Unable to serialize a(n) DisplayEnum enum because it has invalid value" << v;
      return QString();
  }
}

Grid::AltunitdistEnum Grid::altunitdistEnumFromString( const QString & v, bool *ok )
{
  if (ok) *ok = true;

  if ( v == "mic" ) {
    return Altunitdist_mic;
  } else if ( v == "mm" ) {
    return Altunitdist_mm;
  } else if ( v == "mil" ) {
    return Altunitdist_mil;
  } else if ( v == "inch" ) {
    return Altunitdist_inch;
  } else {
    if (ok) *ok = false;
    return Altunitdist_Invalid;
  }

  return Altunitdist_Invalid;
}

QString Grid::altunitdistEnumToString( const AltunitdistEnum & v )
{
  switch( v ) {
    case Altunitdist_mic: return "mic";
    case Altunitdist_mm: return "mm";
    case Altunitdist_mil: return "mil";
    case Altunitdist_inch: return "inch";
    case Altunitdist_Invalid:
    default:
      qCritical() << "Unable to serialize a(n) AltunitdistEnum enum because it has invalid value" << v;
      return QString();
  }
}

Grid::AltunitEnum Grid::altunitEnumFromString( const QString & v, bool *ok )
{
  if (ok) *ok = true;

  if ( v == "mic" ) {
    return Altunit_mic;
  } else if ( v == "mm" ) {
    return Altunit_mm;
  } else if ( v == "mil" ) {
    return Altunit_mil;
  } else if ( v == "inch" ) {
    return Altunit_inch;
  } else {
    if (ok) *ok = false;
    return Altunit_Invalid;
  }

  return Altunit_Invalid;
}

QString Grid::altunitEnumToString( const AltunitEnum & v )
{
  switch( v ) {
    case Altunit_mic: return "mic";
    case Altunit_mm: return "mm";
    case Altunit_mil: return "mil";
    case Altunit_inch: return "inch";
    case Altunit_Invalid:
    default:
      qCritical() << "Unable to serialize a(n) AltunitEnum enum because it has invalid value" << v;
      return QString();
  }
}

Grid Grid::parseElement( const QDomElement &element, bool *ok )
{
  if ( element.tagName() != "grid" ) {
    qCritical() << "Expected 'grid', got '" << element.tagName() << "'.";
    if ( ok ) *ok = false;
    return Grid();
  }

  Grid result = Grid();

  result.setDistance( element.attribute( "distance" ).toInt() );
  if (element.hasAttribute("unitdist"))  {
    UnitdistEnum unitdist = unitdistEnumFromString( element.attribute( "unitdist" ), ok  );
    if (ok && *ok == false) {
      qCritical() << "Invalid string: \"" << element.attribute( "unitdist" ) << "\" in the \"unitdist\" element";
      return Grid();
    } else {
      result.setUnitdist( unitdist );
    }
  } else {
    result.setUnitdist(unitdistEnumFromString(""));
  }
  if (element.hasAttribute("unit"))  {
    UnitEnum unit = unitEnumFromString( element.attribute( "unit" ), ok  );
    if (ok && *ok == false) {
      qCritical() << "Invalid string: \"" << element.attribute( "unit" ) << "\" in the \"unit\" element";
      return Grid();
    } else {
      result.setUnit( unit );
    }
  } else {
    result.setUnit(unitEnumFromString("mm"));
  }
  if (element.hasAttribute("style"))  {
    StyleEnum style = styleEnumFromString( element.attribute( "style" ), ok  );
    if (ok && *ok == false) {
      qCritical() << "Invalid string: \"" << element.attribute( "style" ) << "\" in the \"style\" element";
      return Grid();
    } else {
      result.setStyle( style );
    }
  } else {
    result.setStyle(styleEnumFromString("continuous"));
  }
  result.setMultiple( element.attribute( "multiple" ).toInt() );
  if (element.hasAttribute("display"))  {
    DisplayEnum display = displayEnumFromString( element.attribute( "display" ), ok  );
    if (ok && *ok == false) {
      qCritical() << "Invalid string: \"" << element.attribute( "display" ) << "\" in the \"display\" element";
      return Grid();
    } else {
      result.setDisplay( display );
    }
  } else {
    result.setDisplay(displayEnumFromString("value"));
  }
  result.setAltdistance( element.attribute( "altdistance" ).toDouble() );
  if (element.hasAttribute("altunitdist"))  {
    AltunitdistEnum altunitdist = altunitdistEnumFromString( element.attribute( "altunitdist" ), ok  );
    if (ok && *ok == false) {
      qCritical() << "Invalid string: \"" << element.attribute( "altunitdist" ) << "\" in the \"altunitdist\" element";
      return Grid();
    } else {
      result.setAltunitdist( altunitdist );
    }
  } else {
    result.setAltunitdist(altunitdistEnumFromString(""));
  }
  if (element.hasAttribute("altunit"))  {
    AltunitEnum altunit = altunitEnumFromString( element.attribute( "altunit" ), ok  );
    if (ok && *ok == false) {
      qCritical() << "Invalid string: \"" << element.attribute( "altunit" ) << "\" in the \"altunit\" element";
      return Grid();
    } else {
      result.setAltunit( altunit );
    }
  } else {
    result.setAltunit(altunitEnumFromString(""));
  }

  if ( ok ) *ok = true;
  return result;
}

void Grid::writeElement( QXmlStreamWriter &xml ) const
{
  xml.writeEmptyElement( "grid" );
}


void Setting::setAlwaysvectorfont( const AlwaysvectorfontEnum &v )
{
  mAlwaysvectorfont = v;
}

Setting::AlwaysvectorfontEnum Setting::alwaysvectorfont() const
{
  return mAlwaysvectorfont;
}

void Setting::setVerticaltext( const VerticaltextEnum &v )
{
  mVerticaltext = v;
}

Setting::VerticaltextEnum Setting::verticaltext() const
{
  return mVerticaltext;
}

void Setting::setKeepoldvectorfont( const KeepoldvectorfontEnum &v )
{
  mKeepoldvectorfont = v;
}

Setting::KeepoldvectorfontEnum Setting::keepoldvectorfont() const
{
  return mKeepoldvectorfont;
}

Setting::AlwaysvectorfontEnum Setting::alwaysvectorfontEnumFromString( const QString & v, bool *ok )
{
  if (ok) *ok = true;

  if ( v == "no" ) {
    return Alwaysvectorfont_no;
  } else if ( v == "yes" ) {
    return Alwaysvectorfont_yes;
  } else {
    if (ok) *ok = false;
    return Alwaysvectorfont_Invalid;
  }

  return Alwaysvectorfont_Invalid;
}

QString Setting::alwaysvectorfontEnumToString( const AlwaysvectorfontEnum & v )
{
  switch( v ) {
    case Alwaysvectorfont_no: return "no";
    case Alwaysvectorfont_yes: return "yes";
    case Alwaysvectorfont_Invalid:
    default:
      qCritical() << "Unable to serialize a(n) AlwaysvectorfontEnum enum because it has invalid value" << v;
      return QString();
  }
}

Setting::VerticaltextEnum Setting::verticaltextEnumFromString( const QString & v, bool *ok )
{
  if (ok) *ok = true;

  if ( v == "up" ) {
    return Verticaltext_up;
  } else if ( v == "down" ) {
    return Verticaltext_down;
  } else {
    if (ok) *ok = false;
    return Verticaltext_Invalid;
  }

  return Verticaltext_Invalid;
}

QString Setting::verticaltextEnumToString( const VerticaltextEnum & v )
{
  switch( v ) {
    case Verticaltext_up: return "up";
    case Verticaltext_down: return "down";
    case Verticaltext_Invalid:
    default:
      qCritical() << "Unable to serialize a(n) VerticaltextEnum enum because it has invalid value" << v;
      return QString();
  }
}

Setting::KeepoldvectorfontEnum Setting::keepoldvectorfontEnumFromString( const QString & v, bool *ok )
{
  if (ok) *ok = true;

  if ( v == "no" ) {
    return Keepoldvectorfont_no;
  } else if ( v == "yes" ) {
    return Keepoldvectorfont_yes;
  } else {
    if (ok) *ok = false;
    return Keepoldvectorfont_Invalid;
  }

  return Keepoldvectorfont_Invalid;
}

QString Setting::keepoldvectorfontEnumToString( const KeepoldvectorfontEnum & v )
{
  switch( v ) {
    case Keepoldvectorfont_no: return "no";
    case Keepoldvectorfont_yes: return "yes";
    case Keepoldvectorfont_Invalid:
    default:
      qCritical() << "Unable to serialize a(n) KeepoldvectorfontEnum enum because it has invalid value" << v;
      return QString();
  }
}

Setting Setting::parseElement( const QDomElement &element, bool *ok )
{
  if ( element.tagName() != "setting" ) {
    qCritical() << "Expected 'setting', got '" << element.tagName() << "'.";
    if ( ok ) *ok = false;
    return Setting();
  }

  Setting result = Setting();

  if (element.hasAttribute("alwaysvectorfont"))  {
    AlwaysvectorfontEnum alwaysvectorfont = alwaysvectorfontEnumFromString( element.attribute( "alwaysvectorfont" ), ok  );
    if (ok && *ok == false) {
      qCritical() << "Invalid string: \"" << element.attribute( "alwaysvectorfont" ) << "\" in the \"alwaysvectorfont\" element";
      return Setting();
    } else {
      result.setAlwaysvectorfont( alwaysvectorfont );
    }
  } else {
    result.setAlwaysvectorfont(alwaysvectorfontEnumFromString(""));
  }
  if (element.hasAttribute("verticaltext"))  {
    VerticaltextEnum verticaltext = verticaltextEnumFromString( element.attribute( "verticaltext" ), ok  );
    if (ok && *ok == false) {
      qCritical() << "Invalid string: \"" << element.attribute( "verticaltext" ) << "\" in the \"verticaltext\" element";
      return Setting();
    } else {
      result.setVerticaltext( verticaltext );
    }
  } else {
    result.setVerticaltext(verticaltextEnumFromString("up"));
  }
  if (element.hasAttribute("keepoldvectorfont"))  {
    KeepoldvectorfontEnum keepoldvectorfont = keepoldvectorfontEnumFromString( element.attribute( "keepoldvectorfont" ), ok  );
    if (ok && *ok == false) {
      qCritical() << "Invalid string: \"" << element.attribute( "keepoldvectorfont" ) << "\" in the \"keepoldvectorfont\" element";
      return Setting();
    } else {
      result.setKeepoldvectorfont( keepoldvectorfont );
    }
  } else {
    result.setKeepoldvectorfont(keepoldvectorfontEnumFromString("no"));
  }

  if ( ok ) *ok = true;
  return result;
}

void Setting::writeElement( QXmlStreamWriter &xml ) const
{
  xml.writeEmptyElement( "setting" );
}


void Settings::addSetting( const Setting &v )
{
  mSettingList.append( v );
}

void Settings::setSettingList( const Setting::List &v )
{
  mSettingList = v;
}

Setting::List Settings::settingList() const
{
  return mSettingList;
}

Settings Settings::parseElement( const QDomElement &element, bool *ok )
{
  if ( element.tagName() != "settings" ) {
    qCritical() << "Expected 'settings', got '" << element.tagName() << "'.";
    if ( ok ) *ok = false;
    return Settings();
  }

  Settings result = Settings();

  QDomNode n;
  for( n = element.firstChild(); !n.isNull(); n = n.nextSibling() ) {
    QDomElement e = n.toElement();
    if ( e.tagName() == "setting" ) {
      bool ok;
      Setting o = Setting::parseElement( e, &ok );
      if ( ok ) result.addSetting( o );
    }
  }


  if ( ok ) *ok = true;
  return result;
}

void Settings::writeElement( QXmlStreamWriter &xml ) const
{
  if ( !settingList().isEmpty() ) {
    xml.writeStartElement( "settings" );
    foreach( Setting e, settingList() ) {
      e.writeElement( xml );
    }
    xml.writeEndElement();
  }
}


void Via::setX( double v )
{
  mX = v;
}

double Via::x() const
{
  return mX;
}

void Via::setY( double v )
{
  mY = v;
}

double Via::y() const
{
  return mY;
}

void Via::setExtent( const QString &v )
{
  mExtent = v;
}

QString Via::extent() const
{
  return mExtent;
}

void Via::setDrill( double v )
{
  mDrill = v;
}

double Via::drill() const
{
  return mDrill;
}

void Via::setDiameter( double v )
{
  mDiameter = v;
}

double Via::diameter() const
{
  return mDiameter;
}

void Via::setShape( const ShapeEnum &v )
{
  mShape = v;
}

Via::ShapeEnum Via::shape() const
{
  return mShape;
}

void Via::setAlwaysstop( const AlwaysstopEnum &v )
{
  mAlwaysstop = v;
}

Via::AlwaysstopEnum Via::alwaysstop() const
{
  return mAlwaysstop;
}

Via::ShapeEnum Via::shapeEnumFromString( const QString & v, bool *ok )
{
  if (ok) *ok = true;

  if ( v == "square" ) {
    return Shape_square;
  } else if ( v == "round" ) {
    return Shape_round;
  } else if ( v == "octagon" ) {
    return Shape_octagon;
  } else if ( v == "long" ) {
    return Shape_long;
  } else if ( v == "offset" ) {
    return Shape_offset;
  } else {
    if (ok) *ok = false;
    return Shape_Invalid;
  }

  return Shape_Invalid;
}

QString Via::shapeEnumToString( const ShapeEnum & v )
{
  switch( v ) {
    case Shape_square: return "square";
    case Shape_round: return "round";
    case Shape_octagon: return "octagon";
    case Shape_long: return "long";
    case Shape_offset: return "offset";
    case Shape_Invalid:
    default:
      qCritical() << "Unable to serialize a(n) ShapeEnum enum because it has invalid value" << v;
      return QString();
  }
}

Via::AlwaysstopEnum Via::alwaysstopEnumFromString( const QString & v, bool *ok )
{
  if (ok) *ok = true;

  if ( v == "no" ) {
    return Alwaysstop_no;
  } else if ( v == "yes" ) {
    return Alwaysstop_yes;
  } else {
    if (ok) *ok = false;
    return Alwaysstop_Invalid;
  }

  return Alwaysstop_Invalid;
}

QString Via::alwaysstopEnumToString( const AlwaysstopEnum & v )
{
  switch( v ) {
    case Alwaysstop_no: return "no";
    case Alwaysstop_yes: return "yes";
    case Alwaysstop_Invalid:
    default:
      qCritical() << "Unable to serialize a(n) AlwaysstopEnum enum because it has invalid value" << v;
      return QString();
  }
}

Via Via::parseElement( const QDomElement &element, bool *ok )
{
  if ( element.tagName() != "via" ) {
    qCritical() << "Expected 'via', got '" << element.tagName() << "'.";
    if ( ok ) *ok = false;
    return Via();
  }

  Via result = Via();

  result.setX( element.attribute( "x" ).toDouble() );
  result.setY( element.attribute( "y" ).toDouble() );
  result.setExtent( element.attribute( "extent" ) );
  result.setDrill( element.attribute( "drill" ).toDouble() );
  result.setDiameter( element.attribute( "diameter" ).toDouble() );
  if (element.hasAttribute("shape"))  {
    ShapeEnum shape = shapeEnumFromString( element.attribute( "shape" ), ok  );
    if (ok && *ok == false) {
      qCritical() << "Invalid string: \"" << element.attribute( "shape" ) << "\" in the \"shape\" element";
      return Via();
    } else {
      result.setShape( shape );
    }
  } else {
    result.setShape(shapeEnumFromString("round"));
  }
  if (element.hasAttribute("alwaysstop"))  {
    AlwaysstopEnum alwaysstop = alwaysstopEnumFromString( element.attribute( "alwaysstop" ), ok  );
    if (ok && *ok == false) {
      qCritical() << "Invalid string: \"" << element.attribute( "alwaysstop" ) << "\" in the \"alwaysstop\" element";
      return Via();
    } else {
      result.setAlwaysstop( alwaysstop );
    }
  } else {
    result.setAlwaysstop(alwaysstopEnumFromString("no"));
  }

  if ( ok ) *ok = true;
  return result;
}

void Via::writeElement( QXmlStreamWriter &xml ) const
{
  xml.writeEmptyElement( "via" );
}


void Contactref::setElement( const QString &v )
{
  mElement = v;
}

QString Contactref::element() const
{
  return mElement;
}

void Contactref::setPad( const QString &v )
{
  mPad = v;
}

QString Contactref::pad() const
{
  return mPad;
}

void Contactref::setRoute( const RouteEnum &v )
{
  mRoute = v;
}

Contactref::RouteEnum Contactref::route() const
{
  return mRoute;
}

void Contactref::setRoutetag( const QString &v )
{
  mRoutetag = v;
}

QString Contactref::routetag() const
{
  return mRoutetag;
}

Contactref::RouteEnum Contactref::routeEnumFromString( const QString & v, bool *ok )
{
  if (ok) *ok = true;

  if ( v == "all" ) {
    return Route_all;
  } else if ( v == "any" ) {
    return Route_any;
  } else {
    if (ok) *ok = false;
    return Route_Invalid;
  }

  return Route_Invalid;
}

QString Contactref::routeEnumToString( const RouteEnum & v )
{
  switch( v ) {
    case Route_all: return "all";
    case Route_any: return "any";
    case Route_Invalid:
    default:
      qCritical() << "Unable to serialize a(n) RouteEnum enum because it has invalid value" << v;
      return QString();
  }
}

Contactref Contactref::parseElement( const QDomElement &element, bool *ok )
{
  if ( element.tagName() != "contactref" ) {
    qCritical() << "Expected 'contactref', got '" << element.tagName() << "'.";
    if ( ok ) *ok = false;
    return Contactref();
  }

  Contactref result = Contactref();

  result.setElement( element.attribute( "element" ) );
  result.setPad( element.attribute( "pad" ) );
  if (element.hasAttribute("route"))  {
    RouteEnum route = routeEnumFromString( element.attribute( "route" ), ok  );
    if (ok && *ok == false) {
      qCritical() << "Invalid string: \"" << element.attribute( "route" ) << "\" in the \"route\" element";
      return Contactref();
    } else {
      result.setRoute( route );
    }
  } else {
    result.setRoute(routeEnumFromString("all"));
  }
  result.setRoutetag( element.attribute( "routetag" ) );

  if ( ok ) *ok = true;
  return result;
}

void Contactref::writeElement( QXmlStreamWriter &xml ) const
{
  xml.writeEmptyElement( "contactref" );
}


void Vertex::setX( double v )
{
  mX = v;
}

double Vertex::x() const
{
  return mX;
}

void Vertex::setY( double v )
{
  mY = v;
}

double Vertex::y() const
{
  return mY;
}

void Vertex::setCurve( double v )
{
  mCurve = v;
}

double Vertex::curve() const
{
  return mCurve;
}

Vertex Vertex::parseElement( const QDomElement &element, bool *ok )
{
  if ( element.tagName() != "vertex" ) {
    qCritical() << "Expected 'vertex', got '" << element.tagName() << "'.";
    if ( ok ) *ok = false;
    return Vertex();
  }

  Vertex result = Vertex();

  result.setX( element.attribute( "x" ).toDouble() );
  result.setY( element.attribute( "y" ).toDouble() );
  result.setCurve( element.attribute( "curve" ).toDouble() );

  if ( ok ) *ok = true;
  return result;
}

void Vertex::writeElement( QXmlStreamWriter &xml ) const
{
  xml.writeEmptyElement( "vertex" );
}


void Polygon::setWidth( double v )
{
  mWidth = v;
}

double Polygon::width() const
{
  return mWidth;
}

void Polygon::setLayer( int v )
{
  mLayer = v;
}

int Polygon::layer() const
{
  return mLayer;
}

void Polygon::setSpacing( double v )
{
  mSpacing = v;
}

double Polygon::spacing() const
{
  return mSpacing;
}

void Polygon::setPour( const PourEnum &v )
{
  mPour = v;
}

Polygon::PourEnum Polygon::pour() const
{
  return mPour;
}

void Polygon::setIsolate( double v )
{
  mIsolate = v;
}

double Polygon::isolate() const
{
  return mIsolate;
}

void Polygon::setOrphans( const OrphansEnum &v )
{
  mOrphans = v;
}

Polygon::OrphansEnum Polygon::orphans() const
{
  return mOrphans;
}

void Polygon::setThermals( const ThermalsEnum &v )
{
  mThermals = v;
}

Polygon::ThermalsEnum Polygon::thermals() const
{
  return mThermals;
}

void Polygon::setRank( int v )
{
  mRank = v;
}

int Polygon::rank() const
{
  return mRank;
}

void Polygon::addVertex( const Vertex &v )
{
  mVertexList.append( v );
}

void Polygon::setVertexList( const Vertex::List &v )
{
  mVertexList = v;
}

Vertex::List Polygon::vertexList() const
{
  return mVertexList;
}

Polygon::PourEnum Polygon::pourEnumFromString( const QString & v, bool *ok )
{
  if (ok) *ok = true;

  if ( v == "solid" ) {
    return Pour_solid;
  } else if ( v == "hatch" ) {
    return Pour_hatch;
  } else if ( v == "cutout" ) {
    return Pour_cutout;
  } else {
    if (ok) *ok = false;
    return Pour_Invalid;
  }

  return Pour_Invalid;
}

QString Polygon::pourEnumToString( const PourEnum & v )
{
  switch( v ) {
    case Pour_solid: return "solid";
    case Pour_hatch: return "hatch";
    case Pour_cutout: return "cutout";
    case Pour_Invalid:
    default:
      qCritical() << "Unable to serialize a(n) PourEnum enum because it has invalid value" << v;
      return QString();
  }
}

Polygon::OrphansEnum Polygon::orphansEnumFromString( const QString & v, bool *ok )
{
  if (ok) *ok = true;

  if ( v == "no" ) {
    return Orphans_no;
  } else if ( v == "yes" ) {
    return Orphans_yes;
  } else {
    if (ok) *ok = false;
    return Orphans_Invalid;
  }

  return Orphans_Invalid;
}

QString Polygon::orphansEnumToString( const OrphansEnum & v )
{
  switch( v ) {
    case Orphans_no: return "no";
    case Orphans_yes: return "yes";
    case Orphans_Invalid:
    default:
      qCritical() << "Unable to serialize a(n) OrphansEnum enum because it has invalid value" << v;
      return QString();
  }
}

Polygon::ThermalsEnum Polygon::thermalsEnumFromString( const QString & v, bool *ok )
{
  if (ok) *ok = true;

  if ( v == "no" ) {
    return Thermals_no;
  } else if ( v == "yes" ) {
    return Thermals_yes;
  } else {
    if (ok) *ok = false;
    return Thermals_Invalid;
  }

  return Thermals_Invalid;
}

QString Polygon::thermalsEnumToString( const ThermalsEnum & v )
{
  switch( v ) {
    case Thermals_no: return "no";
    case Thermals_yes: return "yes";
    case Thermals_Invalid:
    default:
      qCritical() << "Unable to serialize a(n) ThermalsEnum enum because it has invalid value" << v;
      return QString();
  }
}

Polygon Polygon::parseElement( const QDomElement &element, bool *ok )
{
  if ( element.tagName() != "polygon" ) {
    qCritical() << "Expected 'polygon', got '" << element.tagName() << "'.";
    if ( ok ) *ok = false;
    return Polygon();
  }

  Polygon result = Polygon();

  QDomNode n;
  for( n = element.firstChild(); !n.isNull(); n = n.nextSibling() ) {
    QDomElement e = n.toElement();
    if ( e.tagName() == "vertex" ) {
      bool ok;
      Vertex o = Vertex::parseElement( e, &ok );
      if ( ok ) result.addVertex( o );
    }
  }

  result.setWidth( element.attribute( "width" ).toDouble() );
  result.setLayer( element.attribute( "layer" ).toInt() );
  result.setSpacing( element.attribute( "spacing" ).toDouble() );
  if (element.hasAttribute("pour"))  {
    PourEnum pour = pourEnumFromString( element.attribute( "pour" ), ok  );
    if (ok && *ok == false) {
      qCritical() << "Invalid string: \"" << element.attribute( "pour" ) << "\" in the \"pour\" element";
      return Polygon();
    } else {
      result.setPour( pour );
    }
  } else {
    result.setPour(pourEnumFromString("solid"));
  }
  result.setIsolate( element.attribute( "isolate" ).toDouble() );
  if (element.hasAttribute("orphans"))  {
    OrphansEnum orphans = orphansEnumFromString( element.attribute( "orphans" ), ok  );
    if (ok && *ok == false) {
      qCritical() << "Invalid string: \"" << element.attribute( "orphans" ) << "\" in the \"orphans\" element";
      return Polygon();
    } else {
      result.setOrphans( orphans );
    }
  } else {
    result.setOrphans(orphansEnumFromString("no"));
  }
  if (element.hasAttribute("thermals"))  {
    ThermalsEnum thermals = thermalsEnumFromString( element.attribute( "thermals" ), ok  );
    if (ok && *ok == false) {
      qCritical() << "Invalid string: \"" << element.attribute( "thermals" ) << "\" in the \"thermals\" element";
      return Polygon();
    } else {
      result.setThermals( thermals );
    }
  } else {
    result.setThermals(thermalsEnumFromString("yes"));
  }
  result.setRank( element.attribute( "rank" ).toInt() );

  if ( ok ) *ok = true;
  return result;
}

void Polygon::writeElement( QXmlStreamWriter &xml ) const
{
  xml.writeStartElement( "polygon" );
      xml.writeAttribute( "width", QString::number( width() ) );
      xml.writeAttribute( "layer", QString::number( layer() ) );
      xml.writeAttribute( "spacing", QString::number( spacing() ) );
      xml.writeAttribute("pour", pourEnumToString( pour() ));
      xml.writeAttribute( "isolate", QString::number( isolate() ) );
      xml.writeAttribute("orphans", orphansEnumToString( orphans() ));
      xml.writeAttribute("thermals", thermalsEnumToString( thermals() ));
      xml.writeAttribute( "rank", QString::number( rank() ) );
  foreach( Vertex e, vertexList() ) {
    e.writeElement( xml );
  }
  xml.writeEndElement();
}


void Wire::setX1( double v )
{
  mX1 = v;
}

double Wire::x1() const
{
  return mX1;
}

void Wire::setY1( double v )
{
  mY1 = v;
}

double Wire::y1() const
{
  return mY1;
}

void Wire::setX2( double v )
{
  mX2 = v;
}

double Wire::x2() const
{
  return mX2;
}

void Wire::setY2( double v )
{
  mY2 = v;
}

double Wire::y2() const
{
  return mY2;
}

void Wire::setWidth( double v )
{
  mWidth = v;
}

double Wire::width() const
{
  return mWidth;
}

void Wire::setLayer( int v )
{
  mLayer = v;
}

int Wire::layer() const
{
  return mLayer;
}

void Wire::setExtent( const QString &v )
{
  mExtent = v;
}

QString Wire::extent() const
{
  return mExtent;
}

void Wire::setStyle( const StyleEnum &v )
{
  mStyle = v;
}

Wire::StyleEnum Wire::style() const
{
  return mStyle;
}

void Wire::setCurve( double v )
{
  mCurve = v;
}

double Wire::curve() const
{
  return mCurve;
}

void Wire::setCap( const CapEnum &v )
{
  mCap = v;
}

Wire::CapEnum Wire::cap() const
{
  return mCap;
}

Wire::StyleEnum Wire::styleEnumFromString( const QString & v, bool *ok )
{
  if (ok) *ok = true;

  if ( v == "continuous" ) {
    return Style_continuous;
  } else if ( v == "longdash" ) {
    return Style_longdash;
  } else if ( v == "shortdash" ) {
    return Style_shortdash;
  } else if ( v == "dashdot" ) {
    return Style_dashdot;
  } else {
    if (ok) *ok = false;
    return Style_Invalid;
  }

  return Style_Invalid;
}

QString Wire::styleEnumToString( const StyleEnum & v )
{
  switch( v ) {
    case Style_continuous: return "continuous";
    case Style_longdash: return "longdash";
    case Style_shortdash: return "shortdash";
    case Style_dashdot: return "dashdot";
    case Style_Invalid:
    default:
      qCritical() << "Unable to serialize a(n) StyleEnum enum because it has invalid value" << v;
      return QString();
  }
}

Wire::CapEnum Wire::capEnumFromString( const QString & v, bool *ok )
{
  if (ok) *ok = true;

  if ( v == "flat" ) {
    return Cap_flat;
  } else if ( v == "round" ) {
    return Cap_round;
  } else {
    if (ok) *ok = false;
    return Cap_Invalid;
  }

  return Cap_Invalid;
}

QString Wire::capEnumToString( const CapEnum & v )
{
  switch( v ) {
    case Cap_flat: return "flat";
    case Cap_round: return "round";
    case Cap_Invalid:
    default:
      qCritical() << "Unable to serialize a(n) CapEnum enum because it has invalid value" << v;
      return QString();
  }
}

Wire Wire::parseElement( const QDomElement &element, bool *ok )
{
  if ( element.tagName() != "wire" ) {
    qCritical() << "Expected 'wire', got '" << element.tagName() << "'.";
    if ( ok ) *ok = false;
    return Wire();
  }

  Wire result = Wire();

  result.setX1( element.attribute( "x1" ).toDouble() );
  result.setY1( element.attribute( "y1" ).toDouble() );
  result.setX2( element.attribute( "x2" ).toDouble() );
  result.setY2( element.attribute( "y2" ).toDouble() );
  result.setWidth( element.attribute( "width" ).toDouble() );
  result.setLayer( element.attribute( "layer" ).toInt() );
  result.setExtent( element.attribute( "extent" ) );
  if (element.hasAttribute("style"))  {
    StyleEnum style = styleEnumFromString( element.attribute( "style" ), ok  );
    if (ok && *ok == false) {
      qCritical() << "Invalid string: \"" << element.attribute( "style" ) << "\" in the \"style\" element";
      return Wire();
    } else {
      result.setStyle( style );
    }
  } else {
    result.setStyle(styleEnumFromString("continuous"));
  }
  result.setCurve( element.attribute( "curve" ).toDouble() );
  if (element.hasAttribute("cap"))  {
    CapEnum cap = capEnumFromString( element.attribute( "cap" ), ok  );
    if (ok && *ok == false) {
      qCritical() << "Invalid string: \"" << element.attribute( "cap" ) << "\" in the \"cap\" element";
      return Wire();
    } else {
      result.setCap( cap );
    }
  } else {
    result.setCap(capEnumFromString("round"));
  }

  if ( ok ) *ok = true;
  return result;
}

void Wire::writeElement( QXmlStreamWriter &xml ) const
{
  xml.writeEmptyElement( "wire" );
}


void Signal::setName( const QString &v )
{
  mName = v;
}

QString Signal::name() const
{
  return mName;
}

void Signal::setClass( int v )
{
  mClass = v;
}

int Signal::class() const
{
  return mClass;
}

void Signal::setAirwireshidden( const AirwireshiddenEnum &v )
{
  mAirwireshidden = v;
}

Signal::AirwireshiddenEnum Signal::airwireshidden() const
{
  return mAirwireshidden;
}

void Signal::addContactref( const Contactref &v )
{
  mContactrefList.append( v );
}

void Signal::setContactrefList( const Contactref::List &v )
{
  mContactrefList = v;
}

Contactref::List Signal::contactrefList() const
{
  return mContactrefList;
}

void Signal::addPolygon( const Polygon &v )
{
  mPolygonList.append( v );
}

void Signal::setPolygonList( const Polygon::List &v )
{
  mPolygonList = v;
}

Polygon::List Signal::polygonList() const
{
  return mPolygonList;
}

void Signal::addWire( const Wire &v )
{
  mWireList.append( v );
}

void Signal::setWireList( const Wire::List &v )
{
  mWireList = v;
}

Wire::List Signal::wireList() const
{
  return mWireList;
}

void Signal::addVia( const Via &v )
{
  mViaList.append( v );
}

void Signal::setViaList( const Via::List &v )
{
  mViaList = v;
}

Via::List Signal::viaList() const
{
  return mViaList;
}

Signal::AirwireshiddenEnum Signal::airwireshiddenEnumFromString( const QString & v, bool *ok )
{
  if (ok) *ok = true;

  if ( v == "no" ) {
    return Airwireshidden_no;
  } else if ( v == "yes" ) {
    return Airwireshidden_yes;
  } else {
    if (ok) *ok = false;
    return Airwireshidden_Invalid;
  }

  return Airwireshidden_Invalid;
}

QString Signal::airwireshiddenEnumToString( const AirwireshiddenEnum & v )
{
  switch( v ) {
    case Airwireshidden_no: return "no";
    case Airwireshidden_yes: return "yes";
    case Airwireshidden_Invalid:
    default:
      qCritical() << "Unable to serialize a(n) AirwireshiddenEnum enum because it has invalid value" << v;
      return QString();
  }
}

Signal Signal::parseElement( const QDomElement &element, bool *ok )
{
  if ( element.tagName() != "signal" ) {
    qCritical() << "Expected 'signal', got '" << element.tagName() << "'.";
    if ( ok ) *ok = false;
    return Signal();
  }

  Signal result = Signal();

  QDomNode n;
  for( n = element.firstChild(); !n.isNull(); n = n.nextSibling() ) {
    QDomElement e = n.toElement();
    if ( e.tagName() == "contactref" ) {
      bool ok;
      Contactref o = Contactref::parseElement( e, &ok );
      if ( ok ) result.addContactref( o );
    }
    else if ( e.tagName() == "polygon" ) {
      bool ok;
      Polygon o = Polygon::parseElement( e, &ok );
      if ( ok ) result.addPolygon( o );
    }
    else if ( e.tagName() == "wire" ) {
      bool ok;
      Wire o = Wire::parseElement( e, &ok );
      if ( ok ) result.addWire( o );
    }
    else if ( e.tagName() == "via" ) {
      bool ok;
      Via o = Via::parseElement( e, &ok );
      if ( ok ) result.addVia( o );
    }
  }

  result.setName( element.attribute( "name" ) );
  result.setClass( element.attribute( "class" ).toInt() );
  if (element.hasAttribute("airwireshidden"))  {
    AirwireshiddenEnum airwireshidden = airwireshiddenEnumFromString( element.attribute( "airwireshidden" ), ok  );
    if (ok && *ok == false) {
      qCritical() << "Invalid string: \"" << element.attribute( "airwireshidden" ) << "\" in the \"airwireshidden\" element";
      return Signal();
    } else {
      result.setAirwireshidden( airwireshidden );
    }
  } else {
    result.setAirwireshidden(airwireshiddenEnumFromString("no"));
  }

  if ( ok ) *ok = true;
  return result;
}

void Signal::writeElement( QXmlStreamWriter &xml ) const
{
  xml.writeStartElement( "signal" );
      xml.writeAttribute( "name", name() );
      xml.writeAttribute( "class", QString::number( class() ) );
      xml.writeAttribute("airwireshidden", airwireshiddenEnumToString( airwireshidden() ));
  foreach( Contactref e, contactrefList() ) {
    e.writeElement( xml );
  }
  foreach( Polygon e, polygonList() ) {
    e.writeElement( xml );
  }
  foreach( Wire e, wireList() ) {
    e.writeElement( xml );
  }
  foreach( Via e, viaList() ) {
    e.writeElement( xml );
  }
  xml.writeEndElement();
}


void Signals::addSignal( const Signal &v )
{
  mSignalList.append( v );
}

void Signals::setSignalList( const Signal::List &v )
{
  mSignalList = v;
}

Signal::List Signals::signalList() const
{
  return mSignalList;
}

Signals Signals::parseElement( const QDomElement &element, bool *ok )
{
  if ( element.tagName() != "signals" ) {
    qCritical() << "Expected 'signals', got '" << element.tagName() << "'.";
    if ( ok ) *ok = false;
    return Signals();
  }

  Signals result = Signals();

  QDomNode n;
  for( n = element.firstChild(); !n.isNull(); n = n.nextSibling() ) {
    QDomElement e = n.toElement();
    if ( e.tagName() == "signal" ) {
      bool ok;
      Signal o = Signal::parseElement( e, &ok );
      if ( ok ) result.addSignal( o );
    }
  }


  if ( ok ) *ok = true;
  return result;
}

void Signals::writeElement( QXmlStreamWriter &xml ) const
{
  if ( !signalList().isEmpty() ) {
    xml.writeStartElement( "signals" );
    foreach( Signal e, signalList() ) {
      e.writeElement( xml );
    }
    xml.writeEndElement();
  }
}


void Attribute::setName( const QString &v )
{
  mName = v;
}

QString Attribute::name() const
{
  return mName;
}

void Attribute::setValue( const QString &v )
{
  mValue = v;
}

QString Attribute::value() const
{
  return mValue;
}

void Attribute::setX( double v )
{
  mX = v;
}

double Attribute::x() const
{
  return mX;
}

void Attribute::setY( double v )
{
  mY = v;
}

double Attribute::y() const
{
  return mY;
}

void Attribute::setSize( double v )
{
  mSize = v;
}

double Attribute::size() const
{
  return mSize;
}

void Attribute::setLayer( int v )
{
  mLayer = v;
}

int Attribute::layer() const
{
  return mLayer;
}

void Attribute::setFont( const FontEnum &v )
{
  mFont = v;
}

Attribute::FontEnum Attribute::font() const
{
  return mFont;
}

void Attribute::setRatio( int v )
{
  mRatio = v;
}

int Attribute::ratio() const
{
  return mRatio;
}

void Attribute::setRot( const QString &v )
{
  mRot = v;
}

QString Attribute::rot() const
{
  return mRot;
}

void Attribute::setDisplay( const DisplayEnum &v )
{
  mDisplay = v;
}

Attribute::DisplayEnum Attribute::display() const
{
  return mDisplay;
}

void Attribute::setConstant( const ConstantEnum &v )
{
  mConstant = v;
}

Attribute::ConstantEnum Attribute::constant() const
{
  return mConstant;
}

void Attribute::setAlign( const AlignEnum &v )
{
  mAlign = v;
}

Attribute::AlignEnum Attribute::align() const
{
  return mAlign;
}

Attribute::FontEnum Attribute::fontEnumFromString( const QString & v, bool *ok )
{
  if (ok) *ok = true;

  if ( v == "vector" ) {
    return Font_vector;
  } else if ( v == "proportional" ) {
    return Font_proportional;
  } else if ( v == "fixed" ) {
    return Font_fixed;
  } else {
    if (ok) *ok = false;
    return Font_Invalid;
  }

  return Font_Invalid;
}

QString Attribute::fontEnumToString( const FontEnum & v )
{
  switch( v ) {
    case Font_vector: return "vector";
    case Font_proportional: return "proportional";
    case Font_fixed: return "fixed";
    case Font_Invalid:
    default:
      qCritical() << "Unable to serialize a(n) FontEnum enum because it has invalid value" << v;
      return QString();
  }
}

Attribute::DisplayEnum Attribute::displayEnumFromString( const QString & v, bool *ok )
{
  if (ok) *ok = true;

  if ( v == "off" ) {
    return Display_off;
  } else if ( v == "value" ) {
    return Display_value;
  } else if ( v == "name" ) {
    return Display_name;
  } else if ( v == "both" ) {
    return Display_both;
  } else {
    if (ok) *ok = false;
    return Display_Invalid;
  }

  return Display_Invalid;
}

QString Attribute::displayEnumToString( const DisplayEnum & v )
{
  switch( v ) {
    case Display_off: return "off";
    case Display_value: return "value";
    case Display_name: return "name";
    case Display_both: return "both";
    case Display_Invalid:
    default:
      qCritical() << "Unable to serialize a(n) DisplayEnum enum because it has invalid value" << v;
      return QString();
  }
}

Attribute::ConstantEnum Attribute::constantEnumFromString( const QString & v, bool *ok )
{
  if (ok) *ok = true;

  if ( v == "no" ) {
    return Constant_no;
  } else if ( v == "yes" ) {
    return Constant_yes;
  } else {
    if (ok) *ok = false;
    return Constant_Invalid;
  }

  return Constant_Invalid;
}

QString Attribute::constantEnumToString( const ConstantEnum & v )
{
  switch( v ) {
    case Constant_no: return "no";
    case Constant_yes: return "yes";
    case Constant_Invalid:
    default:
      qCritical() << "Unable to serialize a(n) ConstantEnum enum because it has invalid value" << v;
      return QString();
  }
}

Attribute::AlignEnum Attribute::alignEnumFromString( const QString & v, bool *ok )
{
  if (ok) *ok = true;

  if ( v == "bottom-left" ) {
    return Align_bottom_left;
  } else if ( v == "bottom-center" ) {
    return Align_bottom_center;
  } else if ( v == "bottom-right" ) {
    return Align_bottom_right;
  } else if ( v == "center-left" ) {
    return Align_center_left;
  } else if ( v == "center" ) {
    return Align_center;
  } else if ( v == "center-right" ) {
    return Align_center_right;
  } else if ( v == "top-left" ) {
    return Align_top_left;
  } else if ( v == "top-center" ) {
    return Align_top_center;
  } else if ( v == "top-right" ) {
    return Align_top_right;
  } else {
    if (ok) *ok = false;
    return Align_Invalid;
  }

  return Align_Invalid;
}

QString Attribute::alignEnumToString( const AlignEnum & v )
{
  switch( v ) {
    case Align_bottom_left: return "bottom-left";
    case Align_bottom_center: return "bottom-center";
    case Align_bottom_right: return "bottom-right";
    case Align_center_left: return "center-left";
    case Align_center: return "center";
    case Align_center_right: return "center-right";
    case Align_top_left: return "top-left";
    case Align_top_center: return "top-center";
    case Align_top_right: return "top-right";
    case Align_Invalid:
    default:
      qCritical() << "Unable to serialize a(n) AlignEnum enum because it has invalid value" << v;
      return QString();
  }
}

Attribute Attribute::parseElement( const QDomElement &element, bool *ok )
{
  if ( element.tagName() != "attribute" ) {
    qCritical() << "Expected 'attribute', got '" << element.tagName() << "'.";
    if ( ok ) *ok = false;
    return Attribute();
  }

  Attribute result = Attribute();

  result.setName( element.attribute( "name" ) );
  result.setValue( element.attribute( "value" ) );
  result.setX( element.attribute( "x" ).toDouble() );
  result.setY( element.attribute( "y" ).toDouble() );
  result.setSize( element.attribute( "size" ).toDouble() );
  result.setLayer( element.attribute( "layer" ).toInt() );
  if (element.hasAttribute("font"))  {
    FontEnum font = fontEnumFromString( element.attribute( "font" ), ok  );
    if (ok && *ok == false) {
      qCritical() << "Invalid string: \"" << element.attribute( "font" ) << "\" in the \"font\" element";
      return Attribute();
    } else {
      result.setFont( font );
    }
  } else {
    result.setFont(fontEnumFromString("proportional"));
  }
  result.setRatio( element.attribute( "ratio" ).toInt() );
  result.setRot( element.attribute( "rot" ) );
  if (element.hasAttribute("display"))  {
    DisplayEnum display = displayEnumFromString( element.attribute( "display" ), ok  );
    if (ok && *ok == false) {
      qCritical() << "Invalid string: \"" << element.attribute( "display" ) << "\" in the \"display\" element";
      return Attribute();
    } else {
      result.setDisplay( display );
    }
  } else {
    result.setDisplay(displayEnumFromString("value"));
  }
  if (element.hasAttribute("constant"))  {
    ConstantEnum constant = constantEnumFromString( element.attribute( "constant" ), ok  );
    if (ok && *ok == false) {
      qCritical() << "Invalid string: \"" << element.attribute( "constant" ) << "\" in the \"constant\" element";
      return Attribute();
    } else {
      result.setConstant( constant );
    }
  } else {
    result.setConstant(constantEnumFromString("no"));
  }
  if (element.hasAttribute("align"))  {
    AlignEnum align = alignEnumFromString( element.attribute( "align" ), ok  );
    if (ok && *ok == false) {
      qCritical() << "Invalid string: \"" << element.attribute( "align" ) << "\" in the \"align\" element";
      return Attribute();
    } else {
      result.setAlign( align );
    }
  } else {
    result.setAlign(alignEnumFromString("bottom-left"));
  }

  if ( ok ) *ok = true;
  return result;
}

void Attribute::writeElement( QXmlStreamWriter &xml ) const
{
  xml.writeEmptyElement( "attribute" );
}


void Variant::setName( const QString &v )
{
  mName = v;
}

QString Variant::name() const
{
  return mName;
}

void Variant::setPopulate( const PopulateEnum &v )
{
  mPopulate = v;
}

Variant::PopulateEnum Variant::populate() const
{
  return mPopulate;
}

void Variant::setValue( const QString &v )
{
  mValue = v;
}

QString Variant::value() const
{
  return mValue;
}

void Variant::setTechnology( const QString &v )
{
  mTechnology = v;
}

QString Variant::technology() const
{
  return mTechnology;
}

Variant::PopulateEnum Variant::populateEnumFromString( const QString & v, bool *ok )
{
  if (ok) *ok = true;

  if ( v == "no" ) {
    return Populate_no;
  } else if ( v == "yes" ) {
    return Populate_yes;
  } else {
    if (ok) *ok = false;
    return Populate_Invalid;
  }

  return Populate_Invalid;
}

QString Variant::populateEnumToString( const PopulateEnum & v )
{
  switch( v ) {
    case Populate_no: return "no";
    case Populate_yes: return "yes";
    case Populate_Invalid:
    default:
      qCritical() << "Unable to serialize a(n) PopulateEnum enum because it has invalid value" << v;
      return QString();
  }
}

Variant Variant::parseElement( const QDomElement &element, bool *ok )
{
  if ( element.tagName() != "variant" ) {
    qCritical() << "Expected 'variant', got '" << element.tagName() << "'.";
    if ( ok ) *ok = false;
    return Variant();
  }

  Variant result = Variant();

  result.setName( element.attribute( "name" ) );
  if (element.hasAttribute("populate"))  {
    PopulateEnum populate = populateEnumFromString( element.attribute( "populate" ), ok  );
    if (ok && *ok == false) {
      qCritical() << "Invalid string: \"" << element.attribute( "populate" ) << "\" in the \"populate\" element";
      return Variant();
    } else {
      result.setPopulate( populate );
    }
  } else {
    result.setPopulate(populateEnumFromString("yes"));
  }
  result.setValue( element.attribute( "value" ) );
  result.setTechnology( element.attribute( "technology" ) );

  if ( ok ) *ok = true;
  return result;
}

void Variant::writeElement( QXmlStreamWriter &xml ) const
{
  xml.writeEmptyElement( "variant" );
}


void Element::setName( const QString &v )
{
  mName = v;
}

QString Element::name() const
{
  return mName;
}

void Element::setLibrary( const QString &v )
{
  mLibrary = v;
}

QString Element::library() const
{
  return mLibrary;
}

void Element::setLibraryUrn( const QString &v )
{
  mLibraryUrn = v;
}

QString Element::libraryUrn() const
{
  return mLibraryUrn;
}

void Element::setPackage( const QString &v )
{
  mPackage = v;
}

QString Element::package() const
{
  return mPackage;
}

void Element::setPackage3dUrn( const QString &v )
{
  mPackage3dUrn = v;
}

QString Element::package3dUrn() const
{
  return mPackage3dUrn;
}

void Element::setValue( const QString &v )
{
  mValue = v;
}

QString Element::value() const
{
  return mValue;
}

void Element::setX( double v )
{
  mX = v;
}

double Element::x() const
{
  return mX;
}

void Element::setY( double v )
{
  mY = v;
}

double Element::y() const
{
  return mY;
}

void Element::setLocked( const LockedEnum &v )
{
  mLocked = v;
}

Element::LockedEnum Element::locked() const
{
  return mLocked;
}

void Element::setPopulate( const PopulateEnum &v )
{
  mPopulate = v;
}

Element::PopulateEnum Element::populate() const
{
  return mPopulate;
}

void Element::setSmashed( const SmashedEnum &v )
{
  mSmashed = v;
}

Element::SmashedEnum Element::smashed() const
{
  return mSmashed;
}

void Element::setRot( const QString &v )
{
  mRot = v;
}

QString Element::rot() const
{
  return mRot;
}

void Element::addAttribute( const Attribute &v )
{
  mAttributeList.append( v );
}

void Element::setAttributeList( const Attribute::List &v )
{
  mAttributeList = v;
}

Attribute::List Element::attributeList() const
{
  return mAttributeList;
}

void Element::addVariant( const Variant &v )
{
  mVariantList.append( v );
}

void Element::setVariantList( const Variant::List &v )
{
  mVariantList = v;
}

Variant::List Element::variantList() const
{
  return mVariantList;
}

Element::LockedEnum Element::lockedEnumFromString( const QString & v, bool *ok )
{
  if (ok) *ok = true;

  if ( v == "no" ) {
    return Locked_no;
  } else if ( v == "yes" ) {
    return Locked_yes;
  } else {
    if (ok) *ok = false;
    return Locked_Invalid;
  }

  return Locked_Invalid;
}

QString Element::lockedEnumToString( const LockedEnum & v )
{
  switch( v ) {
    case Locked_no: return "no";
    case Locked_yes: return "yes";
    case Locked_Invalid:
    default:
      qCritical() << "Unable to serialize a(n) LockedEnum enum because it has invalid value" << v;
      return QString();
  }
}

Element::PopulateEnum Element::populateEnumFromString( const QString & v, bool *ok )
{
  if (ok) *ok = true;

  if ( v == "no" ) {
    return Populate_no;
  } else if ( v == "yes" ) {
    return Populate_yes;
  } else {
    if (ok) *ok = false;
    return Populate_Invalid;
  }

  return Populate_Invalid;
}

QString Element::populateEnumToString( const PopulateEnum & v )
{
  switch( v ) {
    case Populate_no: return "no";
    case Populate_yes: return "yes";
    case Populate_Invalid:
    default:
      qCritical() << "Unable to serialize a(n) PopulateEnum enum because it has invalid value" << v;
      return QString();
  }
}

Element::SmashedEnum Element::smashedEnumFromString( const QString & v, bool *ok )
{
  if (ok) *ok = true;

  if ( v == "no" ) {
    return Smashed_no;
  } else if ( v == "yes" ) {
    return Smashed_yes;
  } else {
    if (ok) *ok = false;
    return Smashed_Invalid;
  }

  return Smashed_Invalid;
}

QString Element::smashedEnumToString( const SmashedEnum & v )
{
  switch( v ) {
    case Smashed_no: return "no";
    case Smashed_yes: return "yes";
    case Smashed_Invalid:
    default:
      qCritical() << "Unable to serialize a(n) SmashedEnum enum because it has invalid value" << v;
      return QString();
  }
}

Element Element::parseElement( const QDomElement &element, bool *ok )
{
  if ( element.tagName() != "element" ) {
    qCritical() << "Expected 'element', got '" << element.tagName() << "'.";
    if ( ok ) *ok = false;
    return Element();
  }

  Element result = Element();

  QDomNode n;
  for( n = element.firstChild(); !n.isNull(); n = n.nextSibling() ) {
    QDomElement e = n.toElement();
    if ( e.tagName() == "attribute" ) {
      bool ok;
      Attribute o = Attribute::parseElement( e, &ok );
      if ( ok ) result.addAttribute( o );
    }
    else if ( e.tagName() == "variant" ) {
      bool ok;
      Variant o = Variant::parseElement( e, &ok );
      if ( ok ) result.addVariant( o );
    }
  }

  result.setName( element.attribute( "name" ) );
  result.setLibrary( element.attribute( "library" ) );
  result.setLibraryUrn( element.attribute( "library_urn" ) );
  result.setPackage( element.attribute( "package" ) );
  result.setPackage3dUrn( element.attribute( "package3d_urn" ) );
  result.setValue( element.attribute( "value" ) );
  result.setX( element.attribute( "x" ).toDouble() );
  result.setY( element.attribute( "y" ).toDouble() );
  if (element.hasAttribute("locked"))  {
    LockedEnum locked = lockedEnumFromString( element.attribute( "locked" ), ok  );
    if (ok && *ok == false) {
      qCritical() << "Invalid string: \"" << element.attribute( "locked" ) << "\" in the \"locked\" element";
      return Element();
    } else {
      result.setLocked( locked );
    }
  } else {
    result.setLocked(lockedEnumFromString("no"));
  }
  if (element.hasAttribute("populate"))  {
    PopulateEnum populate = populateEnumFromString( element.attribute( "populate" ), ok  );
    if (ok && *ok == false) {
      qCritical() << "Invalid string: \"" << element.attribute( "populate" ) << "\" in the \"populate\" element";
      return Element();
    } else {
      result.setPopulate( populate );
    }
  } else {
    result.setPopulate(populateEnumFromString("yes"));
  }
  if (element.hasAttribute("smashed"))  {
    SmashedEnum smashed = smashedEnumFromString( element.attribute( "smashed" ), ok  );
    if (ok && *ok == false) {
      qCritical() << "Invalid string: \"" << element.attribute( "smashed" ) << "\" in the \"smashed\" element";
      return Element();
    } else {
      result.setSmashed( smashed );
    }
  } else {
    result.setSmashed(smashedEnumFromString("no"));
  }
  result.setRot( element.attribute( "rot" ) );

  if ( ok ) *ok = true;
  return result;
}

void Element::writeElement( QXmlStreamWriter &xml ) const
{
  xml.writeStartElement( "element" );
      xml.writeAttribute( "name", name() );
      xml.writeAttribute( "library", library() );
      xml.writeAttribute( "library_urn", libraryUrn() );
      xml.writeAttribute( "package", package() );
      xml.writeAttribute( "package3d_urn", package3dUrn() );
      xml.writeAttribute( "value", value() );
      xml.writeAttribute( "x", QString::number( x() ) );
      xml.writeAttribute( "y", QString::number( y() ) );
      xml.writeAttribute("locked", lockedEnumToString( locked() ));
      xml.writeAttribute("populate", populateEnumToString( populate() ));
      xml.writeAttribute("smashed", smashedEnumToString( smashed() ));
      xml.writeAttribute( "rot", rot() );
  foreach( Attribute e, attributeList() ) {
    e.writeElement( xml );
  }
  foreach( Variant e, variantList() ) {
    e.writeElement( xml );
  }
  xml.writeEndElement();
}


void Elements::addElement( const Element &v )
{
  mElementList.append( v );
}

void Elements::setElementList( const Element::List &v )
{
  mElementList = v;
}

Element::List Elements::elementList() const
{
  return mElementList;
}

Elements Elements::parseElement( const QDomElement &element, bool *ok )
{
  if ( element.tagName() != "elements" ) {
    qCritical() << "Expected 'elements', got '" << element.tagName() << "'.";
    if ( ok ) *ok = false;
    return Elements();
  }

  Elements result = Elements();

  QDomNode n;
  for( n = element.firstChild(); !n.isNull(); n = n.nextSibling() ) {
    QDomElement e = n.toElement();
    if ( e.tagName() == "element" ) {
      bool ok;
      Element o = Element::parseElement( e, &ok );
      if ( ok ) result.addElement( o );
    }
  }


  if ( ok ) *ok = true;
  return result;
}

void Elements::writeElement( QXmlStreamWriter &xml ) const
{
  if ( !elementList().isEmpty() ) {
    xml.writeStartElement( "elements" );
    foreach( Element e, elementList() ) {
      e.writeElement( xml );
    }
    xml.writeEndElement();
  }
}


void Param::setName( const QString &v )
{
  mName = v;
}

QString Param::name() const
{
  return mName;
}

void Param::setValue( const QString &v )
{
  mValue = v;
}

QString Param::value() const
{
  return mValue;
}

Param Param::parseElement( const QDomElement &element, bool *ok )
{
  if ( element.tagName() != "param" ) {
    qCritical() << "Expected 'param', got '" << element.tagName() << "'.";
    if ( ok ) *ok = false;
    return Param();
  }

  Param result = Param();

  result.setName( element.attribute( "name" ) );
  result.setValue( element.attribute( "value" ) );

  if ( ok ) *ok = true;
  return result;
}

void Param::writeElement( QXmlStreamWriter &xml ) const
{
  xml.writeEmptyElement( "param" );
}


void Pass::setName( const QString &v )
{
  mName = v;
}

QString Pass::name() const
{
  return mName;
}

void Pass::setRefer( const QString &v )
{
  mRefer = v;
}

QString Pass::refer() const
{
  return mRefer;
}

void Pass::setActive( const ActiveEnum &v )
{
  mActive = v;
}

Pass::ActiveEnum Pass::active() const
{
  return mActive;
}

void Pass::addParam( const Param &v )
{
  mParamList.append( v );
}

void Pass::setParamList( const Param::List &v )
{
  mParamList = v;
}

Param::List Pass::paramList() const
{
  return mParamList;
}

Pass::ActiveEnum Pass::activeEnumFromString( const QString & v, bool *ok )
{
  if (ok) *ok = true;

  if ( v == "no" ) {
    return Active_no;
  } else if ( v == "yes" ) {
    return Active_yes;
  } else {
    if (ok) *ok = false;
    return Active_Invalid;
  }

  return Active_Invalid;
}

QString Pass::activeEnumToString( const ActiveEnum & v )
{
  switch( v ) {
    case Active_no: return "no";
    case Active_yes: return "yes";
    case Active_Invalid:
    default:
      qCritical() << "Unable to serialize a(n) ActiveEnum enum because it has invalid value" << v;
      return QString();
  }
}

Pass Pass::parseElement( const QDomElement &element, bool *ok )
{
  if ( element.tagName() != "pass" ) {
    qCritical() << "Expected 'pass', got '" << element.tagName() << "'.";
    if ( ok ) *ok = false;
    return Pass();
  }

  Pass result = Pass();

  QDomNode n;
  for( n = element.firstChild(); !n.isNull(); n = n.nextSibling() ) {
    QDomElement e = n.toElement();
    if ( e.tagName() == "param" ) {
      bool ok;
      Param o = Param::parseElement( e, &ok );
      if ( ok ) result.addParam( o );
    }
  }

  result.setName( element.attribute( "name" ) );
  result.setRefer( element.attribute( "refer" ) );
  if (element.hasAttribute("active"))  {
    ActiveEnum active = activeEnumFromString( element.attribute( "active" ), ok  );
    if (ok && *ok == false) {
      qCritical() << "Invalid string: \"" << element.attribute( "active" ) << "\" in the \"active\" element";
      return Pass();
    } else {
      result.setActive( active );
    }
  } else {
    result.setActive(activeEnumFromString("yes"));
  }

  if ( ok ) *ok = true;
  return result;
}

void Pass::writeElement( QXmlStreamWriter &xml ) const
{
  xml.writeStartElement( "pass" );
      xml.writeAttribute( "name", name() );
      xml.writeAttribute( "refer", refer() );
      xml.writeAttribute("active", activeEnumToString( active() ));
  foreach( Param e, paramList() ) {
    e.writeElement( xml );
  }
  xml.writeEndElement();
}


void Autorouter::addPass( const Pass &v )
{
  mPassList.append( v );
}

void Autorouter::setPassList( const Pass::List &v )
{
  mPassList = v;
}

Pass::List Autorouter::passList() const
{
  return mPassList;
}

Autorouter Autorouter::parseElement( const QDomElement &element, bool *ok )
{
  if ( element.tagName() != "autorouter" ) {
    qCritical() << "Expected 'autorouter', got '" << element.tagName() << "'.";
    if ( ok ) *ok = false;
    return Autorouter();
  }

  Autorouter result = Autorouter();

  QDomNode n;
  for( n = element.firstChild(); !n.isNull(); n = n.nextSibling() ) {
    QDomElement e = n.toElement();
    if ( e.tagName() == "pass" ) {
      bool ok;
      Pass o = Pass::parseElement( e, &ok );
      if ( ok ) result.addPass( o );
    }
  }


  if ( ok ) *ok = true;
  return result;
}

void Autorouter::writeElement( QXmlStreamWriter &xml ) const
{
  if ( !passList().isEmpty() ) {
    xml.writeStartElement( "autorouter" );
    foreach( Pass e, passList() ) {
      e.writeElement( xml );
    }
    xml.writeEndElement();
  }
}


void Description::setLanguage( const QString &v )
{
  mLanguage = v;
}

QString Description::language() const
{
  return mLanguage;
}

void Description::setValue( const QString &v )
{
  mValue = v;
}

QString Description::value() const
{
  return mValue;
}

Description Description::parseElement( const QDomElement &element, bool *ok )
{
  if ( element.tagName() != "description" ) {
    qCritical() << "Expected 'description', got '" << element.tagName() << "'.";
    if ( ok ) *ok = false;
    return Description();
  }

  Description result = Description();

  result.setValue( element.text() );
  result.setLanguage( element.attribute( "language" ) );

  if ( ok ) *ok = true;
  return result;
}

void Description::writeElement( QXmlStreamWriter &xml ) const
{
  if ( !value().isEmpty() ) {
    xml.writeStartElement( "description" );
      xml.writeAttribute( "language", language() );
    xml.writeCharacters( value() );
    xml.writeEndElement();
  }
}


void Designrules::setName( const QString &v )
{
  mName = v;
}

QString Designrules::name() const
{
  return mName;
}

void Designrules::addDescription( const Description &v )
{
  mDescriptionList.append( v );
}

void Designrules::setDescriptionList( const Description::List &v )
{
  mDescriptionList = v;
}

Description::List Designrules::descriptionList() const
{
  return mDescriptionList;
}

void Designrules::addParam( const Param &v )
{
  mParamList.append( v );
}

void Designrules::setParamList( const Param::List &v )
{
  mParamList = v;
}

Param::List Designrules::paramList() const
{
  return mParamList;
}

Designrules Designrules::parseElement( const QDomElement &element, bool *ok )
{
  if ( element.tagName() != "designrules" ) {
    qCritical() << "Expected 'designrules', got '" << element.tagName() << "'.";
    if ( ok ) *ok = false;
    return Designrules();
  }

  Designrules result = Designrules();

  QDomNode n;
  for( n = element.firstChild(); !n.isNull(); n = n.nextSibling() ) {
    QDomElement e = n.toElement();
    if ( e.tagName() == "description" ) {
      bool ok;
      Description o = Description::parseElement( e, &ok );
      if ( ok ) result.addDescription( o );
    }
    else if ( e.tagName() == "param" ) {
      bool ok;
      Param o = Param::parseElement( e, &ok );
      if ( ok ) result.addParam( o );
    }
  }

  result.setName( element.attribute( "name" ) );

  if ( ok ) *ok = true;
  return result;
}

void Designrules::writeElement( QXmlStreamWriter &xml ) const
{
  xml.writeStartElement( "designrules" );
      xml.writeAttribute( "name", name() );
  foreach( Description e, descriptionList() ) {
    e.writeElement( xml );
  }
  foreach( Param e, paramList() ) {
    e.writeElement( xml );
  }
  xml.writeEndElement();
}


void Fusionsync::setHuburn( const QString &v )
{
  mHuburn = v;
}

QString Fusionsync::huburn() const
{
  return mHuburn;
}

void Fusionsync::setProjecturn( const QString &v )
{
  mProjecturn = v;
}

QString Fusionsync::projecturn() const
{
  return mProjecturn;
}

void Fusionsync::setF3durn( const QString &v )
{
  mF3durn = v;
}

QString Fusionsync::f3durn() const
{
  return mF3durn;
}

void Fusionsync::setPcbguid( const QString &v )
{
  mPcbguid = v;
}

QString Fusionsync::pcbguid() const
{
  return mPcbguid;
}

void Fusionsync::setLastsyncedchangeguid( const QString &v )
{
  mLastsyncedchangeguid = v;
}

QString Fusionsync::lastsyncedchangeguid() const
{
  return mLastsyncedchangeguid;
}

void Fusionsync::setLastpulledtime( const QString &v )
{
  mLastpulledtime = v;
}

QString Fusionsync::lastpulledtime() const
{
  return mLastpulledtime;
}

Fusionsync Fusionsync::parseElement( const QDomElement &element, bool *ok )
{
  if ( element.tagName() != "fusionsync" ) {
    qCritical() << "Expected 'fusionsync', got '" << element.tagName() << "'.";
    if ( ok ) *ok = false;
    return Fusionsync();
  }

  Fusionsync result = Fusionsync();

  result.setHuburn( element.attribute( "huburn" ) );
  result.setProjecturn( element.attribute( "projecturn" ) );
  result.setF3durn( element.attribute( "f3durn" ) );
  result.setPcbguid( element.attribute( "pcbguid" ) );
  result.setLastsyncedchangeguid( element.attribute( "lastsyncedchangeguid" ) );
  result.setLastpulledtime( element.attribute( "lastpulledtime" ) );

  if ( ok ) *ok = true;
  return result;
}

void Fusionsync::writeElement( QXmlStreamWriter &xml ) const
{
  xml.writeEmptyElement( "fusionsync" );
}


void Text::setX( double v )
{
  mX = v;
}

double Text::x() const
{
  return mX;
}

void Text::setY( double v )
{
  mY = v;
}

double Text::y() const
{
  return mY;
}

void Text::setSize( double v )
{
  mSize = v;
}

double Text::size() const
{
  return mSize;
}

void Text::setLayer( int v )
{
  mLayer = v;
}

int Text::layer() const
{
  return mLayer;
}

void Text::setFont( const FontEnum &v )
{
  mFont = v;
}

Text::FontEnum Text::font() const
{
  return mFont;
}

void Text::setRatio( int v )
{
  mRatio = v;
}

int Text::ratio() const
{
  return mRatio;
}

void Text::setRot( const QString &v )
{
  mRot = v;
}

QString Text::rot() const
{
  return mRot;
}

void Text::setAlign( const AlignEnum &v )
{
  mAlign = v;
}

Text::AlignEnum Text::align() const
{
  return mAlign;
}

void Text::setDistance( int v )
{
  mDistance = v;
}

int Text::distance() const
{
  return mDistance;
}

void Text::setValue( const QString &v )
{
  mValue = v;
}

QString Text::value() const
{
  return mValue;
}

Text::FontEnum Text::fontEnumFromString( const QString & v, bool *ok )
{
  if (ok) *ok = true;

  if ( v == "vector" ) {
    return Font_vector;
  } else if ( v == "proportional" ) {
    return Font_proportional;
  } else if ( v == "fixed" ) {
    return Font_fixed;
  } else {
    if (ok) *ok = false;
    return Font_Invalid;
  }

  return Font_Invalid;
}

QString Text::fontEnumToString( const FontEnum & v )
{
  switch( v ) {
    case Font_vector: return "vector";
    case Font_proportional: return "proportional";
    case Font_fixed: return "fixed";
    case Font_Invalid:
    default:
      qCritical() << "Unable to serialize a(n) FontEnum enum because it has invalid value" << v;
      return QString();
  }
}

Text::AlignEnum Text::alignEnumFromString( const QString & v, bool *ok )
{
  if (ok) *ok = true;

  if ( v == "bottom-left" ) {
    return Align_bottom_left;
  } else if ( v == "bottom-center" ) {
    return Align_bottom_center;
  } else if ( v == "bottom-right" ) {
    return Align_bottom_right;
  } else if ( v == "center-left" ) {
    return Align_center_left;
  } else if ( v == "center" ) {
    return Align_center;
  } else if ( v == "center-right" ) {
    return Align_center_right;
  } else if ( v == "top-left" ) {
    return Align_top_left;
  } else if ( v == "top-center" ) {
    return Align_top_center;
  } else if ( v == "top-right" ) {
    return Align_top_right;
  } else {
    if (ok) *ok = false;
    return Align_Invalid;
  }

  return Align_Invalid;
}

QString Text::alignEnumToString( const AlignEnum & v )
{
  switch( v ) {
    case Align_bottom_left: return "bottom-left";
    case Align_bottom_center: return "bottom-center";
    case Align_bottom_right: return "bottom-right";
    case Align_center_left: return "center-left";
    case Align_center: return "center";
    case Align_center_right: return "center-right";
    case Align_top_left: return "top-left";
    case Align_top_center: return "top-center";
    case Align_top_right: return "top-right";
    case Align_Invalid:
    default:
      qCritical() << "Unable to serialize a(n) AlignEnum enum because it has invalid value" << v;
      return QString();
  }
}

Text Text::parseElement( const QDomElement &element, bool *ok )
{
  if ( element.tagName() != "text" ) {
    qCritical() << "Expected 'text', got '" << element.tagName() << "'.";
    if ( ok ) *ok = false;
    return Text();
  }

  Text result = Text();

  result.setValue( element.text() );
  result.setX( element.attribute( "x" ).toDouble() );
  result.setY( element.attribute( "y" ).toDouble() );
  result.setSize( element.attribute( "size" ).toDouble() );
  result.setLayer( element.attribute( "layer" ).toInt() );
  if (element.hasAttribute("font"))  {
    FontEnum font = fontEnumFromString( element.attribute( "font" ), ok  );
    if (ok && *ok == false) {
      qCritical() << "Invalid string: \"" << element.attribute( "font" ) << "\" in the \"font\" element";
      return Text();
    } else {
      result.setFont( font );
    }
  } else {
    result.setFont(fontEnumFromString("proportional"));
  }
  result.setRatio( element.attribute( "ratio" ).toInt() );
  result.setRot( element.attribute( "rot" ) );
  if (element.hasAttribute("align"))  {
    AlignEnum align = alignEnumFromString( element.attribute( "align" ), ok  );
    if (ok && *ok == false) {
      qCritical() << "Invalid string: \"" << element.attribute( "align" ) << "\" in the \"align\" element";
      return Text();
    } else {
      result.setAlign( align );
    }
  } else {
    result.setAlign(alignEnumFromString("bottom-left"));
  }
  result.setDistance( element.attribute( "distance" ).toInt() );

  if ( ok ) *ok = true;
  return result;
}

void Text::writeElement( QXmlStreamWriter &xml ) const
{
  if ( !value().isEmpty() ) {
    xml.writeStartElement( "text" );
      xml.writeAttribute( "x", QString::number( x() ) );
      xml.writeAttribute( "y", QString::number( y() ) );
      xml.writeAttribute( "size", QString::number( size() ) );
      xml.writeAttribute( "layer", QString::number( layer() ) );
      xml.writeAttribute("font", fontEnumToString( font() ));
      xml.writeAttribute( "ratio", QString::number( ratio() ) );
      xml.writeAttribute( "rot", rot() );
      xml.writeAttribute("align", alignEnumToString( align() ));
      xml.writeAttribute( "distance", QString::number( distance() ) );
    xml.writeCharacters( value() );
    xml.writeEndElement();
  }
}


void Dimension::setX1( double v )
{
  mX1 = v;
}

double Dimension::x1() const
{
  return mX1;
}

void Dimension::setY1( double v )
{
  mY1 = v;
}

double Dimension::y1() const
{
  return mY1;
}

void Dimension::setX2( double v )
{
  mX2 = v;
}

double Dimension::x2() const
{
  return mX2;
}

void Dimension::setY2( double v )
{
  mY2 = v;
}

double Dimension::y2() const
{
  return mY2;
}

void Dimension::setX3( double v )
{
  mX3 = v;
}

double Dimension::x3() const
{
  return mX3;
}

void Dimension::setY3( double v )
{
  mY3 = v;
}

double Dimension::y3() const
{
  return mY3;
}

void Dimension::setLayer( int v )
{
  mLayer = v;
}

int Dimension::layer() const
{
  return mLayer;
}

void Dimension::setDtype( const DtypeEnum &v )
{
  mDtype = v;
}

Dimension::DtypeEnum Dimension::dtype() const
{
  return mDtype;
}

void Dimension::setWidth( double v )
{
  mWidth = v;
}

double Dimension::width() const
{
  return mWidth;
}

void Dimension::setExtwidth( double v )
{
  mExtwidth = v;
}

double Dimension::extwidth() const
{
  return mExtwidth;
}

void Dimension::setExtlength( double v )
{
  mExtlength = v;
}

double Dimension::extlength() const
{
  return mExtlength;
}

void Dimension::setExtoffset( double v )
{
  mExtoffset = v;
}

double Dimension::extoffset() const
{
  return mExtoffset;
}

void Dimension::setTextsize( double v )
{
  mTextsize = v;
}

double Dimension::textsize() const
{
  return mTextsize;
}

void Dimension::setTextratio( int v )
{
  mTextratio = v;
}

int Dimension::textratio() const
{
  return mTextratio;
}

void Dimension::setUnit( const UnitEnum &v )
{
  mUnit = v;
}

Dimension::UnitEnum Dimension::unit() const
{
  return mUnit;
}

void Dimension::setPrecision( int v )
{
  mPrecision = v;
}

int Dimension::precision() const
{
  return mPrecision;
}

void Dimension::setVisible( const VisibleEnum &v )
{
  mVisible = v;
}

Dimension::VisibleEnum Dimension::visible() const
{
  return mVisible;
}

Dimension::DtypeEnum Dimension::dtypeEnumFromString( const QString & v, bool *ok )
{
  if (ok) *ok = true;

  if ( v == "parallel" ) {
    return Dtype_parallel;
  } else if ( v == "horizontal" ) {
    return Dtype_horizontal;
  } else if ( v == "vertical" ) {
    return Dtype_vertical;
  } else if ( v == "radius" ) {
    return Dtype_radius;
  } else if ( v == "diameter" ) {
    return Dtype_diameter;
  } else if ( v == "leader" ) {
    return Dtype_leader;
  } else {
    if (ok) *ok = false;
    return Dtype_Invalid;
  }

  return Dtype_Invalid;
}

QString Dimension::dtypeEnumToString( const DtypeEnum & v )
{
  switch( v ) {
    case Dtype_parallel: return "parallel";
    case Dtype_horizontal: return "horizontal";
    case Dtype_vertical: return "vertical";
    case Dtype_radius: return "radius";
    case Dtype_diameter: return "diameter";
    case Dtype_leader: return "leader";
    case Dtype_Invalid:
    default:
      qCritical() << "Unable to serialize a(n) DtypeEnum enum because it has invalid value" << v;
      return QString();
  }
}

Dimension::UnitEnum Dimension::unitEnumFromString( const QString & v, bool *ok )
{
  if (ok) *ok = true;

  if ( v == "mic" ) {
    return Unit_mic;
  } else if ( v == "mm" ) {
    return Unit_mm;
  } else if ( v == "mil" ) {
    return Unit_mil;
  } else if ( v == "inch" ) {
    return Unit_inch;
  } else {
    if (ok) *ok = false;
    return Unit_Invalid;
  }

  return Unit_Invalid;
}

QString Dimension::unitEnumToString( const UnitEnum & v )
{
  switch( v ) {
    case Unit_mic: return "mic";
    case Unit_mm: return "mm";
    case Unit_mil: return "mil";
    case Unit_inch: return "inch";
    case Unit_Invalid:
    default:
      qCritical() << "Unable to serialize a(n) UnitEnum enum because it has invalid value" << v;
      return QString();
  }
}

Dimension::VisibleEnum Dimension::visibleEnumFromString( const QString & v, bool *ok )
{
  if (ok) *ok = true;

  if ( v == "no" ) {
    return Visible_no;
  } else if ( v == "yes" ) {
    return Visible_yes;
  } else {
    if (ok) *ok = false;
    return Visible_Invalid;
  }

  return Visible_Invalid;
}

QString Dimension::visibleEnumToString( const VisibleEnum & v )
{
  switch( v ) {
    case Visible_no: return "no";
    case Visible_yes: return "yes";
    case Visible_Invalid:
    default:
      qCritical() << "Unable to serialize a(n) VisibleEnum enum because it has invalid value" << v;
      return QString();
  }
}

Dimension Dimension::parseElement( const QDomElement &element, bool *ok )
{
  if ( element.tagName() != "dimension" ) {
    qCritical() << "Expected 'dimension', got '" << element.tagName() << "'.";
    if ( ok ) *ok = false;
    return Dimension();
  }

  Dimension result = Dimension();

  result.setX1( element.attribute( "x1" ).toDouble() );
  result.setY1( element.attribute( "y1" ).toDouble() );
  result.setX2( element.attribute( "x2" ).toDouble() );
  result.setY2( element.attribute( "y2" ).toDouble() );
  result.setX3( element.attribute( "x3" ).toDouble() );
  result.setY3( element.attribute( "y3" ).toDouble() );
  result.setLayer( element.attribute( "layer" ).toInt() );
  if (element.hasAttribute("dtype"))  {
    DtypeEnum dtype = dtypeEnumFromString( element.attribute( "dtype" ), ok  );
    if (ok && *ok == false) {
      qCritical() << "Invalid string: \"" << element.attribute( "dtype" ) << "\" in the \"dtype\" element";
      return Dimension();
    } else {
      result.setDtype( dtype );
    }
  } else {
    result.setDtype(dtypeEnumFromString("parallel"));
  }
  result.setWidth( element.attribute( "width" ).toDouble() );
  result.setExtwidth( element.attribute( "extwidth" ).toDouble() );
  result.setExtlength( element.attribute( "extlength" ).toDouble() );
  result.setExtoffset( element.attribute( "extoffset" ).toDouble() );
  result.setTextsize( element.attribute( "textsize" ).toDouble() );
  result.setTextratio( element.attribute( "textratio" ).toInt() );
  if (element.hasAttribute("unit"))  {
    UnitEnum unit = unitEnumFromString( element.attribute( "unit" ), ok  );
    if (ok && *ok == false) {
      qCritical() << "Invalid string: \"" << element.attribute( "unit" ) << "\" in the \"unit\" element";
      return Dimension();
    } else {
      result.setUnit( unit );
    }
  } else {
    result.setUnit(unitEnumFromString("mm"));
  }
  result.setPrecision( element.attribute( "precision" ).toInt() );
  if (element.hasAttribute("visible"))  {
    VisibleEnum visible = visibleEnumFromString( element.attribute( "visible" ), ok  );
    if (ok && *ok == false) {
      qCritical() << "Invalid string: \"" << element.attribute( "visible" ) << "\" in the \"visible\" element";
      return Dimension();
    } else {
      result.setVisible( visible );
    }
  } else {
    result.setVisible(visibleEnumFromString("no"));
  }

  if ( ok ) *ok = true;
  return result;
}

void Dimension::writeElement( QXmlStreamWriter &xml ) const
{
  xml.writeEmptyElement( "dimension" );
}


void Circle::setX( double v )
{
  mX = v;
}

double Circle::x() const
{
  return mX;
}

void Circle::setY( double v )
{
  mY = v;
}

double Circle::y() const
{
  return mY;
}

void Circle::setRadius( double v )
{
  mRadius = v;
}

double Circle::radius() const
{
  return mRadius;
}

void Circle::setWidth( double v )
{
  mWidth = v;
}

double Circle::width() const
{
  return mWidth;
}

void Circle::setLayer( int v )
{
  mLayer = v;
}

int Circle::layer() const
{
  return mLayer;
}

Circle Circle::parseElement( const QDomElement &element, bool *ok )
{
  if ( element.tagName() != "circle" ) {
    qCritical() << "Expected 'circle', got '" << element.tagName() << "'.";
    if ( ok ) *ok = false;
    return Circle();
  }

  Circle result = Circle();

  result.setX( element.attribute( "x" ).toDouble() );
  result.setY( element.attribute( "y" ).toDouble() );
  result.setRadius( element.attribute( "radius" ).toDouble() );
  result.setWidth( element.attribute( "width" ).toDouble() );
  result.setLayer( element.attribute( "layer" ).toInt() );

  if ( ok ) *ok = true;
  return result;
}

void Circle::writeElement( QXmlStreamWriter &xml ) const
{
  xml.writeEmptyElement( "circle" );
}


void Rectangle::setX1( double v )
{
  mX1 = v;
}

double Rectangle::x1() const
{
  return mX1;
}

void Rectangle::setY1( double v )
{
  mY1 = v;
}

double Rectangle::y1() const
{
  return mY1;
}

void Rectangle::setX2( double v )
{
  mX2 = v;
}

double Rectangle::x2() const
{
  return mX2;
}

void Rectangle::setY2( double v )
{
  mY2 = v;
}

double Rectangle::y2() const
{
  return mY2;
}

void Rectangle::setLayer( int v )
{
  mLayer = v;
}

int Rectangle::layer() const
{
  return mLayer;
}

void Rectangle::setRot( const QString &v )
{
  mRot = v;
}

QString Rectangle::rot() const
{
  return mRot;
}

Rectangle Rectangle::parseElement( const QDomElement &element, bool *ok )
{
  if ( element.tagName() != "rectangle" ) {
    qCritical() << "Expected 'rectangle', got '" << element.tagName() << "'.";
    if ( ok ) *ok = false;
    return Rectangle();
  }

  Rectangle result = Rectangle();

  result.setX1( element.attribute( "x1" ).toDouble() );
  result.setY1( element.attribute( "y1" ).toDouble() );
  result.setX2( element.attribute( "x2" ).toDouble() );
  result.setY2( element.attribute( "y2" ).toDouble() );
  result.setLayer( element.attribute( "layer" ).toInt() );
  result.setRot( element.attribute( "rot" ) );

  if ( ok ) *ok = true;
  return result;
}

void Rectangle::writeElement( QXmlStreamWriter &xml ) const
{
  xml.writeEmptyElement( "rectangle" );
}


void Frame::setX1( double v )
{
  mX1 = v;
}

double Frame::x1() const
{
  return mX1;
}

void Frame::setY1( double v )
{
  mY1 = v;
}

double Frame::y1() const
{
  return mY1;
}

void Frame::setX2( double v )
{
  mX2 = v;
}

double Frame::x2() const
{
  return mX2;
}

void Frame::setY2( double v )
{
  mY2 = v;
}

double Frame::y2() const
{
  return mY2;
}

void Frame::setColumns( int v )
{
  mColumns = v;
}

int Frame::columns() const
{
  return mColumns;
}

void Frame::setRows( int v )
{
  mRows = v;
}

int Frame::rows() const
{
  return mRows;
}

void Frame::setLayer( int v )
{
  mLayer = v;
}

int Frame::layer() const
{
  return mLayer;
}

void Frame::setBorder-left( const Border-leftEnum &v )
{
  mBorder-left = v;
}

Frame::Border-leftEnum Frame::border-left() const
{
  return mBorder-left;
}

void Frame::setBorder-top( const Border-topEnum &v )
{
  mBorder-top = v;
}

Frame::Border-topEnum Frame::border-top() const
{
  return mBorder-top;
}

void Frame::setBorder-right( const Border-rightEnum &v )
{
  mBorder-right = v;
}

Frame::Border-rightEnum Frame::border-right() const
{
  return mBorder-right;
}

void Frame::setBorder-bottom( const Border-bottomEnum &v )
{
  mBorder-bottom = v;
}

Frame::Border-bottomEnum Frame::border-bottom() const
{
  return mBorder-bottom;
}

Frame::Border-leftEnum Frame::border-leftEnumFromString( const QString & v, bool *ok )
{
  if (ok) *ok = true;

  if ( v == "no" ) {
    return Border-left_no;
  } else if ( v == "yes" ) {
    return Border-left_yes;
  } else {
    if (ok) *ok = false;
    return Border-left_Invalid;
  }

  return Border-left_Invalid;
}

QString Frame::border-leftEnumToString( const Border-leftEnum & v )
{
  switch( v ) {
    case Border-left_no: return "no";
    case Border-left_yes: return "yes";
    case Border-left_Invalid:
    default:
      qCritical() << "Unable to serialize a(n) Border-leftEnum enum because it has invalid value" << v;
      return QString();
  }
}

Frame::Border-topEnum Frame::border-topEnumFromString( const QString & v, bool *ok )
{
  if (ok) *ok = true;

  if ( v == "no" ) {
    return Border-top_no;
  } else if ( v == "yes" ) {
    return Border-top_yes;
  } else {
    if (ok) *ok = false;
    return Border-top_Invalid;
  }

  return Border-top_Invalid;
}

QString Frame::border-topEnumToString( const Border-topEnum & v )
{
  switch( v ) {
    case Border-top_no: return "no";
    case Border-top_yes: return "yes";
    case Border-top_Invalid:
    default:
      qCritical() << "Unable to serialize a(n) Border-topEnum enum because it has invalid value" << v;
      return QString();
  }
}

Frame::Border-rightEnum Frame::border-rightEnumFromString( const QString & v, bool *ok )
{
  if (ok) *ok = true;

  if ( v == "no" ) {
    return Border-right_no;
  } else if ( v == "yes" ) {
    return Border-right_yes;
  } else {
    if (ok) *ok = false;
    return Border-right_Invalid;
  }

  return Border-right_Invalid;
}

QString Frame::border-rightEnumToString( const Border-rightEnum & v )
{
  switch( v ) {
    case Border-right_no: return "no";
    case Border-right_yes: return "yes";
    case Border-right_Invalid:
    default:
      qCritical() << "Unable to serialize a(n) Border-rightEnum enum because it has invalid value" << v;
      return QString();
  }
}

Frame::Border-bottomEnum Frame::border-bottomEnumFromString( const QString & v, bool *ok )
{
  if (ok) *ok = true;

  if ( v == "no" ) {
    return Border-bottom_no;
  } else if ( v == "yes" ) {
    return Border-bottom_yes;
  } else {
    if (ok) *ok = false;
    return Border-bottom_Invalid;
  }

  return Border-bottom_Invalid;
}

QString Frame::border-bottomEnumToString( const Border-bottomEnum & v )
{
  switch( v ) {
    case Border-bottom_no: return "no";
    case Border-bottom_yes: return "yes";
    case Border-bottom_Invalid:
    default:
      qCritical() << "Unable to serialize a(n) Border-bottomEnum enum because it has invalid value" << v;
      return QString();
  }
}

Frame Frame::parseElement( const QDomElement &element, bool *ok )
{
  if ( element.tagName() != "frame" ) {
    qCritical() << "Expected 'frame', got '" << element.tagName() << "'.";
    if ( ok ) *ok = false;
    return Frame();
  }

  Frame result = Frame();

  result.setX1( element.attribute( "x1" ).toDouble() );
  result.setY1( element.attribute( "y1" ).toDouble() );
  result.setX2( element.attribute( "x2" ).toDouble() );
  result.setY2( element.attribute( "y2" ).toDouble() );
  result.setColumns( element.attribute( "columns" ).toInt() );
  result.setRows( element.attribute( "rows" ).toInt() );
  result.setLayer( element.attribute( "layer" ).toInt() );
  if (element.hasAttribute("border-left"))  {
    Border-leftEnum border_left = border-leftEnumFromString( element.attribute( "border_left" ), ok  );
    if (ok && *ok == false) {
      qCritical() << "Invalid string: \"" << element.attribute( "border-left" ) << "\" in the \"border-left\" element";
      return Frame();
    } else {
      result.setBorder-left( border_left );
    }
  } else {
    result.setBorder-left(border-leftEnumFromString("yes"));
  }
  if (element.hasAttribute("border-top"))  {
    Border-topEnum border_top = border-topEnumFromString( element.attribute( "border_top" ), ok  );
    if (ok && *ok == false) {
      qCritical() << "Invalid string: \"" << element.attribute( "border-top" ) << "\" in the \"border-top\" element";
      return Frame();
    } else {
      result.setBorder-top( border_top );
    }
  } else {
    result.setBorder-top(border-topEnumFromString("yes"));
  }
  if (element.hasAttribute("border-right"))  {
    Border-rightEnum border_right = border-rightEnumFromString( element.attribute( "border_right" ), ok  );
    if (ok && *ok == false) {
      qCritical() << "Invalid string: \"" << element.attribute( "border-right" ) << "\" in the \"border-right\" element";
      return Frame();
    } else {
      result.setBorder-right( border_right );
    }
  } else {
    result.setBorder-right(border-rightEnumFromString("yes"));
  }
  if (element.hasAttribute("border-bottom"))  {
    Border-bottomEnum border_bottom = border-bottomEnumFromString( element.attribute( "border_bottom" ), ok  );
    if (ok && *ok == false) {
      qCritical() << "Invalid string: \"" << element.attribute( "border-bottom" ) << "\" in the \"border-bottom\" element";
      return Frame();
    } else {
      result.setBorder-bottom( border_bottom );
    }
  } else {
    result.setBorder-bottom(border-bottomEnumFromString("yes"));
  }

  if ( ok ) *ok = true;
  return result;
}

void Frame::writeElement( QXmlStreamWriter &xml ) const
{
  xml.writeEmptyElement( "frame" );
}


void Hole::setX( double v )
{
  mX = v;
}

double Hole::x() const
{
  return mX;
}

void Hole::setY( double v )
{
  mY = v;
}

double Hole::y() const
{
  return mY;
}

void Hole::setDrill( double v )
{
  mDrill = v;
}

double Hole::drill() const
{
  return mDrill;
}

Hole Hole::parseElement( const QDomElement &element, bool *ok )
{
  if ( element.tagName() != "hole" ) {
    qCritical() << "Expected 'hole', got '" << element.tagName() << "'.";
    if ( ok ) *ok = false;
    return Hole();
  }

  Hole result = Hole();

  result.setX( element.attribute( "x" ).toDouble() );
  result.setY( element.attribute( "y" ).toDouble() );
  result.setDrill( element.attribute( "drill" ).toDouble() );

  if ( ok ) *ok = true;
  return result;
}

void Hole::writeElement( QXmlStreamWriter &xml ) const
{
  xml.writeEmptyElement( "hole" );
}


void Plain::addPolygon( const Polygon &v )
{
  mPolygonList.append( v );
}

void Plain::setPolygonList( const Polygon::List &v )
{
  mPolygonList = v;
}

Polygon::List Plain::polygonList() const
{
  return mPolygonList;
}

void Plain::addWire( const Wire &v )
{
  mWireList.append( v );
}

void Plain::setWireList( const Wire::List &v )
{
  mWireList = v;
}

Wire::List Plain::wireList() const
{
  return mWireList;
}

void Plain::addText( const Text &v )
{
  mTextList.append( v );
}

void Plain::setTextList( const Text::List &v )
{
  mTextList = v;
}

Text::List Plain::textList() const
{
  return mTextList;
}

void Plain::addDimension( const Dimension &v )
{
  mDimensionList.append( v );
}

void Plain::setDimensionList( const Dimension::List &v )
{
  mDimensionList = v;
}

Dimension::List Plain::dimensionList() const
{
  return mDimensionList;
}

void Plain::addCircle( const Circle &v )
{
  mCircleList.append( v );
}

void Plain::setCircleList( const Circle::List &v )
{
  mCircleList = v;
}

Circle::List Plain::circleList() const
{
  return mCircleList;
}

void Plain::addRectangle( const Rectangle &v )
{
  mRectangleList.append( v );
}

void Plain::setRectangleList( const Rectangle::List &v )
{
  mRectangleList = v;
}

Rectangle::List Plain::rectangleList() const
{
  return mRectangleList;
}

void Plain::addFrame( const Frame &v )
{
  mFrameList.append( v );
}

void Plain::setFrameList( const Frame::List &v )
{
  mFrameList = v;
}

Frame::List Plain::frameList() const
{
  return mFrameList;
}

void Plain::addHole( const Hole &v )
{
  mHoleList.append( v );
}

void Plain::setHoleList( const Hole::List &v )
{
  mHoleList = v;
}

Hole::List Plain::holeList() const
{
  return mHoleList;
}

Plain Plain::parseElement( const QDomElement &element, bool *ok )
{
  if ( element.tagName() != "plain" ) {
    qCritical() << "Expected 'plain', got '" << element.tagName() << "'.";
    if ( ok ) *ok = false;
    return Plain();
  }

  Plain result = Plain();

  QDomNode n;
  for( n = element.firstChild(); !n.isNull(); n = n.nextSibling() ) {
    QDomElement e = n.toElement();
    if ( e.tagName() == "polygon" ) {
      bool ok;
      Polygon o = Polygon::parseElement( e, &ok );
      if ( ok ) result.addPolygon( o );
    }
    else if ( e.tagName() == "wire" ) {
      bool ok;
      Wire o = Wire::parseElement( e, &ok );
      if ( ok ) result.addWire( o );
    }
    else if ( e.tagName() == "text" ) {
      bool ok;
      Text o = Text::parseElement( e, &ok );
      if ( ok ) result.addText( o );
    }
    else if ( e.tagName() == "dimension" ) {
      bool ok;
      Dimension o = Dimension::parseElement( e, &ok );
      if ( ok ) result.addDimension( o );
    }
    else if ( e.tagName() == "circle" ) {
      bool ok;
      Circle o = Circle::parseElement( e, &ok );
      if ( ok ) result.addCircle( o );
    }
    else if ( e.tagName() == "rectangle" ) {
      bool ok;
      Rectangle o = Rectangle::parseElement( e, &ok );
      if ( ok ) result.addRectangle( o );
    }
    else if ( e.tagName() == "frame" ) {
      bool ok;
      Frame o = Frame::parseElement( e, &ok );
      if ( ok ) result.addFrame( o );
    }
    else if ( e.tagName() == "hole" ) {
      bool ok;
      Hole o = Hole::parseElement( e, &ok );
      if ( ok ) result.addHole( o );
    }
  }


  if ( ok ) *ok = true;
  return result;
}

void Plain::writeElement( QXmlStreamWriter &xml ) const
{
  if ( !polygonList().isEmpty() || !wireList().isEmpty() || !textList().isEmpty() || !dimensionList().isEmpty() || !circleList().isEmpty() || !rectangleList().isEmpty() || !frameList().isEmpty() || !holeList().isEmpty() ) {
    xml.writeStartElement( "plain" );
    foreach( Polygon e, polygonList() ) {
      e.writeElement( xml );
    }
    foreach( Wire e, wireList() ) {
      e.writeElement( xml );
    }
    foreach( Text e, textList() ) {
      e.writeElement( xml );
    }
    foreach( Dimension e, dimensionList() ) {
      e.writeElement( xml );
    }
    foreach( Circle e, circleList() ) {
      e.writeElement( xml );
    }
    foreach( Rectangle e, rectangleList() ) {
      e.writeElement( xml );
    }
    foreach( Frame e, frameList() ) {
      e.writeElement( xml );
    }
    foreach( Hole e, holeList() ) {
      e.writeElement( xml );
    }
    xml.writeEndElement();
  }
}


void Pad::setName( const QString &v )
{
  mName = v;
}

QString Pad::name() const
{
  return mName;
}

void Pad::setX( double v )
{
  mX = v;
}

double Pad::x() const
{
  return mX;
}

void Pad::setY( double v )
{
  mY = v;
}

double Pad::y() const
{
  return mY;
}

void Pad::setDrill( double v )
{
  mDrill = v;
}

double Pad::drill() const
{
  return mDrill;
}

void Pad::setDiameter( double v )
{
  mDiameter = v;
}

double Pad::diameter() const
{
  return mDiameter;
}

void Pad::setShape( const ShapeEnum &v )
{
  mShape = v;
}

Pad::ShapeEnum Pad::shape() const
{
  return mShape;
}

void Pad::setRot( const QString &v )
{
  mRot = v;
}

QString Pad::rot() const
{
  return mRot;
}

void Pad::setStop( const StopEnum &v )
{
  mStop = v;
}

Pad::StopEnum Pad::stop() const
{
  return mStop;
}

void Pad::setThermals( const ThermalsEnum &v )
{
  mThermals = v;
}

Pad::ThermalsEnum Pad::thermals() const
{
  return mThermals;
}

void Pad::setFirst( const FirstEnum &v )
{
  mFirst = v;
}

Pad::FirstEnum Pad::first() const
{
  return mFirst;
}

Pad::ShapeEnum Pad::shapeEnumFromString( const QString & v, bool *ok )
{
  if (ok) *ok = true;

  if ( v == "square" ) {
    return Shape_square;
  } else if ( v == "round" ) {
    return Shape_round;
  } else if ( v == "octagon" ) {
    return Shape_octagon;
  } else if ( v == "long" ) {
    return Shape_long;
  } else if ( v == "offset" ) {
    return Shape_offset;
  } else {
    if (ok) *ok = false;
    return Shape_Invalid;
  }

  return Shape_Invalid;
}

QString Pad::shapeEnumToString( const ShapeEnum & v )
{
  switch( v ) {
    case Shape_square: return "square";
    case Shape_round: return "round";
    case Shape_octagon: return "octagon";
    case Shape_long: return "long";
    case Shape_offset: return "offset";
    case Shape_Invalid:
    default:
      qCritical() << "Unable to serialize a(n) ShapeEnum enum because it has invalid value" << v;
      return QString();
  }
}

Pad::StopEnum Pad::stopEnumFromString( const QString & v, bool *ok )
{
  if (ok) *ok = true;

  if ( v == "no" ) {
    return Stop_no;
  } else if ( v == "yes" ) {
    return Stop_yes;
  } else {
    if (ok) *ok = false;
    return Stop_Invalid;
  }

  return Stop_Invalid;
}

QString Pad::stopEnumToString( const StopEnum & v )
{
  switch( v ) {
    case Stop_no: return "no";
    case Stop_yes: return "yes";
    case Stop_Invalid:
    default:
      qCritical() << "Unable to serialize a(n) StopEnum enum because it has invalid value" << v;
      return QString();
  }
}

Pad::ThermalsEnum Pad::thermalsEnumFromString( const QString & v, bool *ok )
{
  if (ok) *ok = true;

  if ( v == "no" ) {
    return Thermals_no;
  } else if ( v == "yes" ) {
    return Thermals_yes;
  } else {
    if (ok) *ok = false;
    return Thermals_Invalid;
  }

  return Thermals_Invalid;
}

QString Pad::thermalsEnumToString( const ThermalsEnum & v )
{
  switch( v ) {
    case Thermals_no: return "no";
    case Thermals_yes: return "yes";
    case Thermals_Invalid:
    default:
      qCritical() << "Unable to serialize a(n) ThermalsEnum enum because it has invalid value" << v;
      return QString();
  }
}

Pad::FirstEnum Pad::firstEnumFromString( const QString & v, bool *ok )
{
  if (ok) *ok = true;

  if ( v == "no" ) {
    return First_no;
  } else if ( v == "yes" ) {
    return First_yes;
  } else {
    if (ok) *ok = false;
    return First_Invalid;
  }

  return First_Invalid;
}

QString Pad::firstEnumToString( const FirstEnum & v )
{
  switch( v ) {
    case First_no: return "no";
    case First_yes: return "yes";
    case First_Invalid:
    default:
      qCritical() << "Unable to serialize a(n) FirstEnum enum because it has invalid value" << v;
      return QString();
  }
}

Pad Pad::parseElement( const QDomElement &element, bool *ok )
{
  if ( element.tagName() != "pad" ) {
    qCritical() << "Expected 'pad', got '" << element.tagName() << "'.";
    if ( ok ) *ok = false;
    return Pad();
  }

  Pad result = Pad();

  result.setName( element.attribute( "name" ) );
  result.setX( element.attribute( "x" ).toDouble() );
  result.setY( element.attribute( "y" ).toDouble() );
  result.setDrill( element.attribute( "drill" ).toDouble() );
  result.setDiameter( element.attribute( "diameter" ).toDouble() );
  if (element.hasAttribute("shape"))  {
    ShapeEnum shape = shapeEnumFromString( element.attribute( "shape" ), ok  );
    if (ok && *ok == false) {
      qCritical() << "Invalid string: \"" << element.attribute( "shape" ) << "\" in the \"shape\" element";
      return Pad();
    } else {
      result.setShape( shape );
    }
  } else {
    result.setShape(shapeEnumFromString("round"));
  }
  result.setRot( element.attribute( "rot" ) );
  if (element.hasAttribute("stop"))  {
    StopEnum stop = stopEnumFromString( element.attribute( "stop" ), ok  );
    if (ok && *ok == false) {
      qCritical() << "Invalid string: \"" << element.attribute( "stop" ) << "\" in the \"stop\" element";
      return Pad();
    } else {
      result.setStop( stop );
    }
  } else {
    result.setStop(stopEnumFromString("yes"));
  }
  if (element.hasAttribute("thermals"))  {
    ThermalsEnum thermals = thermalsEnumFromString( element.attribute( "thermals" ), ok  );
    if (ok && *ok == false) {
      qCritical() << "Invalid string: \"" << element.attribute( "thermals" ) << "\" in the \"thermals\" element";
      return Pad();
    } else {
      result.setThermals( thermals );
    }
  } else {
    result.setThermals(thermalsEnumFromString("yes"));
  }
  if (element.hasAttribute("first"))  {
    FirstEnum first = firstEnumFromString( element.attribute( "first" ), ok  );
    if (ok && *ok == false) {
      qCritical() << "Invalid string: \"" << element.attribute( "first" ) << "\" in the \"first\" element";
      return Pad();
    } else {
      result.setFirst( first );
    }
  } else {
    result.setFirst(firstEnumFromString("no"));
  }

  if ( ok ) *ok = true;
  return result;
}

void Pad::writeElement( QXmlStreamWriter &xml ) const
{
  xml.writeEmptyElement( "pad" );
}


void Smd::setName( const QString &v )
{
  mName = v;
}

QString Smd::name() const
{
  return mName;
}

void Smd::setX( double v )
{
  mX = v;
}

double Smd::x() const
{
  return mX;
}

void Smd::setY( double v )
{
  mY = v;
}

double Smd::y() const
{
  return mY;
}

void Smd::setDx( double v )
{
  mDx = v;
}

double Smd::dx() const
{
  return mDx;
}

void Smd::setDy( double v )
{
  mDy = v;
}

double Smd::dy() const
{
  return mDy;
}

void Smd::setLayer( int v )
{
  mLayer = v;
}

int Smd::layer() const
{
  return mLayer;
}

void Smd::setRoundness( int v )
{
  mRoundness = v;
}

int Smd::roundness() const
{
  return mRoundness;
}

void Smd::setRot( const QString &v )
{
  mRot = v;
}

QString Smd::rot() const
{
  return mRot;
}

void Smd::setStop( const StopEnum &v )
{
  mStop = v;
}

Smd::StopEnum Smd::stop() const
{
  return mStop;
}

void Smd::setThermals( const ThermalsEnum &v )
{
  mThermals = v;
}

Smd::ThermalsEnum Smd::thermals() const
{
  return mThermals;
}

void Smd::setCream( const CreamEnum &v )
{
  mCream = v;
}

Smd::CreamEnum Smd::cream() const
{
  return mCream;
}

Smd::StopEnum Smd::stopEnumFromString( const QString & v, bool *ok )
{
  if (ok) *ok = true;

  if ( v == "no" ) {
    return Stop_no;
  } else if ( v == "yes" ) {
    return Stop_yes;
  } else {
    if (ok) *ok = false;
    return Stop_Invalid;
  }

  return Stop_Invalid;
}

QString Smd::stopEnumToString( const StopEnum & v )
{
  switch( v ) {
    case Stop_no: return "no";
    case Stop_yes: return "yes";
    case Stop_Invalid:
    default:
      qCritical() << "Unable to serialize a(n) StopEnum enum because it has invalid value" << v;
      return QString();
  }
}

Smd::ThermalsEnum Smd::thermalsEnumFromString( const QString & v, bool *ok )
{
  if (ok) *ok = true;

  if ( v == "no" ) {
    return Thermals_no;
  } else if ( v == "yes" ) {
    return Thermals_yes;
  } else {
    if (ok) *ok = false;
    return Thermals_Invalid;
  }

  return Thermals_Invalid;
}

QString Smd::thermalsEnumToString( const ThermalsEnum & v )
{
  switch( v ) {
    case Thermals_no: return "no";
    case Thermals_yes: return "yes";
    case Thermals_Invalid:
    default:
      qCritical() << "Unable to serialize a(n) ThermalsEnum enum because it has invalid value" << v;
      return QString();
  }
}

Smd::CreamEnum Smd::creamEnumFromString( const QString & v, bool *ok )
{
  if (ok) *ok = true;

  if ( v == "no" ) {
    return Cream_no;
  } else if ( v == "yes" ) {
    return Cream_yes;
  } else {
    if (ok) *ok = false;
    return Cream_Invalid;
  }

  return Cream_Invalid;
}

QString Smd::creamEnumToString( const CreamEnum & v )
{
  switch( v ) {
    case Cream_no: return "no";
    case Cream_yes: return "yes";
    case Cream_Invalid:
    default:
      qCritical() << "Unable to serialize a(n) CreamEnum enum because it has invalid value" << v;
      return QString();
  }
}

Smd Smd::parseElement( const QDomElement &element, bool *ok )
{
  if ( element.tagName() != "smd" ) {
    qCritical() << "Expected 'smd', got '" << element.tagName() << "'.";
    if ( ok ) *ok = false;
    return Smd();
  }

  Smd result = Smd();

  result.setName( element.attribute( "name" ) );
  result.setX( element.attribute( "x" ).toDouble() );
  result.setY( element.attribute( "y" ).toDouble() );
  result.setDx( element.attribute( "dx" ).toDouble() );
  result.setDy( element.attribute( "dy" ).toDouble() );
  result.setLayer( element.attribute( "layer" ).toInt() );
  result.setRoundness( element.attribute( "roundness" ).toInt() );
  result.setRot( element.attribute( "rot" ) );
  if (element.hasAttribute("stop"))  {
    StopEnum stop = stopEnumFromString( element.attribute( "stop" ), ok  );
    if (ok && *ok == false) {
      qCritical() << "Invalid string: \"" << element.attribute( "stop" ) << "\" in the \"stop\" element";
      return Smd();
    } else {
      result.setStop( stop );
    }
  } else {
    result.setStop(stopEnumFromString("yes"));
  }
  if (element.hasAttribute("thermals"))  {
    ThermalsEnum thermals = thermalsEnumFromString( element.attribute( "thermals" ), ok  );
    if (ok && *ok == false) {
      qCritical() << "Invalid string: \"" << element.attribute( "thermals" ) << "\" in the \"thermals\" element";
      return Smd();
    } else {
      result.setThermals( thermals );
    }
  } else {
    result.setThermals(thermalsEnumFromString("yes"));
  }
  if (element.hasAttribute("cream"))  {
    CreamEnum cream = creamEnumFromString( element.attribute( "cream" ), ok  );
    if (ok && *ok == false) {
      qCritical() << "Invalid string: \"" << element.attribute( "cream" ) << "\" in the \"cream\" element";
      return Smd();
    } else {
      result.setCream( cream );
    }
  } else {
    result.setCream(creamEnumFromString("yes"));
  }

  if ( ok ) *ok = true;
  return result;
}

void Smd::writeElement( QXmlStreamWriter &xml ) const
{
  xml.writeEmptyElement( "smd" );
}


void Package::setName( const QString &v )
{
  mName = v;
}

QString Package::name() const
{
  return mName;
}

void Package::setUrn( const QString &v )
{
  mUrn = v;
}

QString Package::urn() const
{
  return mUrn;
}

void Package::setLocallyModified( const LocallyModifiedEnum &v )
{
  mLocallyModified = v;
}

Package::LocallyModifiedEnum Package::locallyModified() const
{
  return mLocallyModified;
}

void Package::setLibraryVersion( int v )
{
  mLibraryVersion = v;
}

int Package::libraryVersion() const
{
  return mLibraryVersion;
}

void Package::setLibraryLocallyModified( const LibraryLocallyModifiedEnum &v )
{
  mLibraryLocallyModified = v;
}

Package::LibraryLocallyModifiedEnum Package::libraryLocallyModified() const
{
  return mLibraryLocallyModified;
}

void Package::addPolygon( const Polygon &v )
{
  mPolygonList.append( v );
}

void Package::setPolygonList( const Polygon::List &v )
{
  mPolygonList = v;
}

Polygon::List Package::polygonList() const
{
  return mPolygonList;
}

void Package::addWire( const Wire &v )
{
  mWireList.append( v );
}

void Package::setWireList( const Wire::List &v )
{
  mWireList = v;
}

Wire::List Package::wireList() const
{
  return mWireList;
}

void Package::addText( const Text &v )
{
  mTextList.append( v );
}

void Package::setTextList( const Text::List &v )
{
  mTextList = v;
}

Text::List Package::textList() const
{
  return mTextList;
}

void Package::addDimension( const Dimension &v )
{
  mDimensionList.append( v );
}

void Package::setDimensionList( const Dimension::List &v )
{
  mDimensionList = v;
}

Dimension::List Package::dimensionList() const
{
  return mDimensionList;
}

void Package::addCircle( const Circle &v )
{
  mCircleList.append( v );
}

void Package::setCircleList( const Circle::List &v )
{
  mCircleList = v;
}

Circle::List Package::circleList() const
{
  return mCircleList;
}

void Package::addRectangle( const Rectangle &v )
{
  mRectangleList.append( v );
}

void Package::setRectangleList( const Rectangle::List &v )
{
  mRectangleList = v;
}

Rectangle::List Package::rectangleList() const
{
  return mRectangleList;
}

void Package::addFrame( const Frame &v )
{
  mFrameList.append( v );
}

void Package::setFrameList( const Frame::List &v )
{
  mFrameList = v;
}

Frame::List Package::frameList() const
{
  return mFrameList;
}

void Package::addHole( const Hole &v )
{
  mHoleList.append( v );
}

void Package::setHoleList( const Hole::List &v )
{
  mHoleList = v;
}

Hole::List Package::holeList() const
{
  return mHoleList;
}

void Package::addPad( const Pad &v )
{
  mPadList.append( v );
}

void Package::setPadList( const Pad::List &v )
{
  mPadList = v;
}

Pad::List Package::padList() const
{
  return mPadList;
}

void Package::addSmd( const Smd &v )
{
  mSmdList.append( v );
}

void Package::setSmdList( const Smd::List &v )
{
  mSmdList = v;
}

Smd::List Package::smdList() const
{
  return mSmdList;
}

void Package::setDescription( const Description &v )
{
  mDescription = v;
}

Description Package::description() const
{
  return mDescription;
}

Package::LocallyModifiedEnum Package::locallyModifiedEnumFromString( const QString & v, bool *ok )
{
  if (ok) *ok = true;

  if ( v == "no" ) {
    return LocallyModified_no;
  } else if ( v == "yes" ) {
    return LocallyModified_yes;
  } else {
    if (ok) *ok = false;
    return LocallyModified_Invalid;
  }

  return LocallyModified_Invalid;
}

QString Package::locallyModifiedEnumToString( const LocallyModifiedEnum & v )
{
  switch( v ) {
    case LocallyModified_no: return "no";
    case LocallyModified_yes: return "yes";
    case LocallyModified_Invalid:
    default:
      qCritical() << "Unable to serialize a(n) LocallyModifiedEnum enum because it has invalid value" << v;
      return QString();
  }
}

Package::LibraryLocallyModifiedEnum Package::libraryLocallyModifiedEnumFromString( const QString & v, bool *ok )
{
  if (ok) *ok = true;

  if ( v == "no" ) {
    return LibraryLocallyModified_no;
  } else if ( v == "yes" ) {
    return LibraryLocallyModified_yes;
  } else {
    if (ok) *ok = false;
    return LibraryLocallyModified_Invalid;
  }

  return LibraryLocallyModified_Invalid;
}

QString Package::libraryLocallyModifiedEnumToString( const LibraryLocallyModifiedEnum & v )
{
  switch( v ) {
    case LibraryLocallyModified_no: return "no";
    case LibraryLocallyModified_yes: return "yes";
    case LibraryLocallyModified_Invalid:
    default:
      qCritical() << "Unable to serialize a(n) LibraryLocallyModifiedEnum enum because it has invalid value" << v;
      return QString();
  }
}

Package Package::parseElement( const QDomElement &element, bool *ok )
{
  if ( element.tagName() != "package" ) {
    qCritical() << "Expected 'package', got '" << element.tagName() << "'.";
    if ( ok ) *ok = false;
    return Package();
  }

  Package result = Package();

  QDomNode n;
  for( n = element.firstChild(); !n.isNull(); n = n.nextSibling() ) {
    QDomElement e = n.toElement();
    if ( e.tagName() == "polygon" ) {
      bool ok;
      Polygon o = Polygon::parseElement( e, &ok );
      if ( ok ) result.addPolygon( o );
    }
    else if ( e.tagName() == "wire" ) {
      bool ok;
      Wire o = Wire::parseElement( e, &ok );
      if ( ok ) result.addWire( o );
    }
    else if ( e.tagName() == "text" ) {
      bool ok;
      Text o = Text::parseElement( e, &ok );
      if ( ok ) result.addText( o );
    }
    else if ( e.tagName() == "dimension" ) {
      bool ok;
      Dimension o = Dimension::parseElement( e, &ok );
      if ( ok ) result.addDimension( o );
    }
    else if ( e.tagName() == "circle" ) {
      bool ok;
      Circle o = Circle::parseElement( e, &ok );
      if ( ok ) result.addCircle( o );
    }
    else if ( e.tagName() == "rectangle" ) {
      bool ok;
      Rectangle o = Rectangle::parseElement( e, &ok );
      if ( ok ) result.addRectangle( o );
    }
    else if ( e.tagName() == "frame" ) {
      bool ok;
      Frame o = Frame::parseElement( e, &ok );
      if ( ok ) result.addFrame( o );
    }
    else if ( e.tagName() == "hole" ) {
      bool ok;
      Hole o = Hole::parseElement( e, &ok );
      if ( ok ) result.addHole( o );
    }
    else if ( e.tagName() == "pad" ) {
      bool ok;
      Pad o = Pad::parseElement( e, &ok );
      if ( ok ) result.addPad( o );
    }
    else if ( e.tagName() == "smd" ) {
      bool ok;
      Smd o = Smd::parseElement( e, &ok );
      if ( ok ) result.addSmd( o );
    }
    else if ( e.tagName() == "description" ) {
      bool ok;
      Description o = Description::parseElement( e, &ok );
      if ( ok ) result.setDescription( o );
    }
  }

  result.setName( element.attribute( "name" ) );
  result.setUrn( element.attribute( "urn" ) );
  if (element.hasAttribute("locally_modified"))  {
    LocallyModifiedEnum locally_modified = locallyModifiedEnumFromString( element.attribute( "locally_modified" ), ok  );
    if (ok && *ok == false) {
      qCritical() << "Invalid string: \"" << element.attribute( "locally_modified" ) << "\" in the \"locally_modified\" element";
      return Package();
    } else {
      result.setLocallyModified( locally_modified );
    }
  } else {
    result.setLocallyModified(locallyModifiedEnumFromString("no"));
  }
  result.setLibraryVersion( element.attribute( "library_version" ).toInt() );
  if (element.hasAttribute("library_locally_modified"))  {
    LibraryLocallyModifiedEnum library_locally_modified = libraryLocallyModifiedEnumFromString( element.attribute( "library_locally_modified" ), ok  );
    if (ok && *ok == false) {
      qCritical() << "Invalid string: \"" << element.attribute( "library_locally_modified" ) << "\" in the \"library_locally_modified\" element";
      return Package();
    } else {
      result.setLibraryLocallyModified( library_locally_modified );
    }
  } else {
    result.setLibraryLocallyModified(libraryLocallyModifiedEnumFromString("no"));
  }

  if ( ok ) *ok = true;
  return result;
}

void Package::writeElement( QXmlStreamWriter &xml ) const
{
  xml.writeStartElement( "package" );
      xml.writeAttribute( "name", name() );
      xml.writeAttribute( "urn", urn() );
      xml.writeAttribute("locally_modified", locally_modifiedEnumToString( locally_modified() ));
      xml.writeAttribute( "library_version", QString::number( libraryVersion() ) );
      xml.writeAttribute("library_locally_modified", library_locally_modifiedEnumToString( library_locally_modified() ));
  foreach( Polygon e, polygonList() ) {
    e.writeElement( xml );
  }
  foreach( Wire e, wireList() ) {
    e.writeElement( xml );
  }
  foreach( Text e, textList() ) {
    e.writeElement( xml );
  }
  foreach( Dimension e, dimensionList() ) {
    e.writeElement( xml );
  }
  foreach( Circle e, circleList() ) {
    e.writeElement( xml );
  }
  foreach( Rectangle e, rectangleList() ) {
    e.writeElement( xml );
  }
  foreach( Frame e, frameList() ) {
    e.writeElement( xml );
  }
  foreach( Hole e, holeList() ) {
    e.writeElement( xml );
  }
  foreach( Pad e, padList() ) {
    e.writeElement( xml );
  }
  foreach( Smd e, smdList() ) {
    e.writeElement( xml );
  }
  description().writeElement( xml );
  xml.writeEndElement();
}


void Packages::addPackage( const Package &v )
{
  mPackageList.append( v );
}

void Packages::setPackageList( const Package::List &v )
{
  mPackageList = v;
}

Package::List Packages::packageList() const
{
  return mPackageList;
}

Packages Packages::parseElement( const QDomElement &element, bool *ok )
{
  if ( element.tagName() != "packages" ) {
    qCritical() << "Expected 'packages', got '" << element.tagName() << "'.";
    if ( ok ) *ok = false;
    return Packages();
  }

  Packages result = Packages();

  QDomNode n;
  for( n = element.firstChild(); !n.isNull(); n = n.nextSibling() ) {
    QDomElement e = n.toElement();
    if ( e.tagName() == "package" ) {
      bool ok;
      Package o = Package::parseElement( e, &ok );
      if ( ok ) result.addPackage( o );
    }
  }


  if ( ok ) *ok = true;
  return result;
}

void Packages::writeElement( QXmlStreamWriter &xml ) const
{
  if ( !packageList().isEmpty() ) {
    xml.writeStartElement( "packages" );
    foreach( Package e, packageList() ) {
      e.writeElement( xml );
    }
    xml.writeEndElement();
  }
}


void Pin::setName( const QString &v )
{
  mName = v;
}

QString Pin::name() const
{
  return mName;
}

void Pin::setX( double v )
{
  mX = v;
}

double Pin::x() const
{
  return mX;
}

void Pin::setY( double v )
{
  mY = v;
}

double Pin::y() const
{
  return mY;
}

void Pin::setVisible( const VisibleEnum &v )
{
  mVisible = v;
}

Pin::VisibleEnum Pin::visible() const
{
  return mVisible;
}

void Pin::setLength( const LengthEnum &v )
{
  mLength = v;
}

Pin::LengthEnum Pin::length() const
{
  return mLength;
}

void Pin::setDirection( const DirectionEnum &v )
{
  mDirection = v;
}

Pin::DirectionEnum Pin::direction() const
{
  return mDirection;
}

void Pin::setFunction( const FunctionEnum &v )
{
  mFunction = v;
}

Pin::FunctionEnum Pin::function() const
{
  return mFunction;
}

void Pin::setSwaplevel( int v )
{
  mSwaplevel = v;
}

int Pin::swaplevel() const
{
  return mSwaplevel;
}

void Pin::setRot( const QString &v )
{
  mRot = v;
}

QString Pin::rot() const
{
  return mRot;
}

Pin::VisibleEnum Pin::visibleEnumFromString( const QString & v, bool *ok )
{
  if (ok) *ok = true;

  if ( v == "no" ) {
    return Visible_no;
  } else if ( v == "yes" ) {
    return Visible_yes;
  } else {
    if (ok) *ok = false;
    return Visible_Invalid;
  }

  return Visible_Invalid;
}

QString Pin::visibleEnumToString( const VisibleEnum & v )
{
  switch( v ) {
    case Visible_no: return "no";
    case Visible_yes: return "yes";
    case Visible_Invalid:
    default:
      qCritical() << "Unable to serialize a(n) VisibleEnum enum because it has invalid value" << v;
      return QString();
  }
}

Pin::LengthEnum Pin::lengthEnumFromString( const QString & v, bool *ok )
{
  if (ok) *ok = true;

  if ( v == "point" ) {
    return Length_point;
  } else if ( v == "short" ) {
    return Length_short;
  } else if ( v == "middle" ) {
    return Length_middle;
  } else if ( v == "long" ) {
    return Length_long;
  } else {
    if (ok) *ok = false;
    return Length_Invalid;
  }

  return Length_Invalid;
}

QString Pin::lengthEnumToString( const LengthEnum & v )
{
  switch( v ) {
    case Length_point: return "point";
    case Length_short: return "short";
    case Length_middle: return "middle";
    case Length_long: return "long";
    case Length_Invalid:
    default:
      qCritical() << "Unable to serialize a(n) LengthEnum enum because it has invalid value" << v;
      return QString();
  }
}

Pin::DirectionEnum Pin::directionEnumFromString( const QString & v, bool *ok )
{
  if (ok) *ok = true;

  if ( v == "nc" ) {
    return Direction_nc;
  } else if ( v == "in" ) {
    return Direction_in;
  } else if ( v == "out" ) {
    return Direction_out;
  } else if ( v == "io" ) {
    return Direction_io;
  } else if ( v == "oc" ) {
    return Direction_oc;
  } else if ( v == "pwr" ) {
    return Direction_pwr;
  } else if ( v == "pas" ) {
    return Direction_pas;
  } else if ( v == "hiz" ) {
    return Direction_hiz;
  } else if ( v == "sup" ) {
    return Direction_sup;
  } else {
    if (ok) *ok = false;
    return Direction_Invalid;
  }

  return Direction_Invalid;
}

QString Pin::directionEnumToString( const DirectionEnum & v )
{
  switch( v ) {
    case Direction_nc: return "nc";
    case Direction_in: return "in";
    case Direction_out: return "out";
    case Direction_io: return "io";
    case Direction_oc: return "oc";
    case Direction_pwr: return "pwr";
    case Direction_pas: return "pas";
    case Direction_hiz: return "hiz";
    case Direction_sup: return "sup";
    case Direction_Invalid:
    default:
      qCritical() << "Unable to serialize a(n) DirectionEnum enum because it has invalid value" << v;
      return QString();
  }
}

Pin::FunctionEnum Pin::functionEnumFromString( const QString & v, bool *ok )
{
  if (ok) *ok = true;

  if ( v == "none" ) {
    return Function_none;
  } else if ( v == "dot" ) {
    return Function_dot;
  } else if ( v == "clk" ) {
    return Function_clk;
  } else if ( v == "dotclk" ) {
    return Function_dotclk;
  } else {
    if (ok) *ok = false;
    return Function_Invalid;
  }

  return Function_Invalid;
}

QString Pin::functionEnumToString( const FunctionEnum & v )
{
  switch( v ) {
    case Function_none: return "none";
    case Function_dot: return "dot";
    case Function_clk: return "clk";
    case Function_dotclk: return "dotclk";
    case Function_Invalid:
    default:
      qCritical() << "Unable to serialize a(n) FunctionEnum enum because it has invalid value" << v;
      return QString();
  }
}

Pin Pin::parseElement( const QDomElement &element, bool *ok )
{
  if ( element.tagName() != "pin" ) {
    qCritical() << "Expected 'pin', got '" << element.tagName() << "'.";
    if ( ok ) *ok = false;
    return Pin();
  }

  Pin result = Pin();

  result.setName( element.attribute( "name" ) );
  result.setX( element.attribute( "x" ).toDouble() );
  result.setY( element.attribute( "y" ).toDouble() );
  if (element.hasAttribute("visible"))  {
    VisibleEnum visible = visibleEnumFromString( element.attribute( "visible" ), ok  );
    if (ok && *ok == false) {
      qCritical() << "Invalid string: \"" << element.attribute( "visible" ) << "\" in the \"visible\" element";
      return Pin();
    } else {
      result.setVisible( visible );
    }
  } else {
    result.setVisible(visibleEnumFromString("no"));
  }
  if (element.hasAttribute("length"))  {
    LengthEnum length = lengthEnumFromString( element.attribute( "length" ), ok  );
    if (ok && *ok == false) {
      qCritical() << "Invalid string: \"" << element.attribute( "length" ) << "\" in the \"length\" element";
      return Pin();
    } else {
      result.setLength( length );
    }
  } else {
    result.setLength(lengthEnumFromString("long"));
  }
  if (element.hasAttribute("direction"))  {
    DirectionEnum direction = directionEnumFromString( element.attribute( "direction" ), ok  );
    if (ok && *ok == false) {
      qCritical() << "Invalid string: \"" << element.attribute( "direction" ) << "\" in the \"direction\" element";
      return Pin();
    } else {
      result.setDirection( direction );
    }
  } else {
    result.setDirection(directionEnumFromString("io"));
  }
  if (element.hasAttribute("function"))  {
    FunctionEnum function = functionEnumFromString( element.attribute( "function" ), ok  );
    if (ok && *ok == false) {
      qCritical() << "Invalid string: \"" << element.attribute( "function" ) << "\" in the \"function\" element";
      return Pin();
    } else {
      result.setFunction( function );
    }
  } else {
    result.setFunction(functionEnumFromString("none"));
  }
  result.setSwaplevel( element.attribute( "swaplevel" ).toInt() );
  result.setRot( element.attribute( "rot" ) );

  if ( ok ) *ok = true;
  return result;
}

void Pin::writeElement( QXmlStreamWriter &xml ) const
{
  xml.writeEmptyElement( "pin" );
}


void Symbol::setName( const QString &v )
{
  mName = v;
}

QString Symbol::name() const
{
  return mName;
}

void Symbol::setUrn( const QString &v )
{
  mUrn = v;
}

QString Symbol::urn() const
{
  return mUrn;
}

void Symbol::setLocallyModified( const LocallyModifiedEnum &v )
{
  mLocallyModified = v;
}

Symbol::LocallyModifiedEnum Symbol::locallyModified() const
{
  return mLocallyModified;
}

void Symbol::setLibraryVersion( int v )
{
  mLibraryVersion = v;
}

int Symbol::libraryVersion() const
{
  return mLibraryVersion;
}

void Symbol::setLibraryLocallyModified( const LibraryLocallyModifiedEnum &v )
{
  mLibraryLocallyModified = v;
}

Symbol::LibraryLocallyModifiedEnum Symbol::libraryLocallyModified() const
{
  return mLibraryLocallyModified;
}

void Symbol::addPolygon( const Polygon &v )
{
  mPolygonList.append( v );
}

void Symbol::setPolygonList( const Polygon::List &v )
{
  mPolygonList = v;
}

Polygon::List Symbol::polygonList() const
{
  return mPolygonList;
}

void Symbol::addWire( const Wire &v )
{
  mWireList.append( v );
}

void Symbol::setWireList( const Wire::List &v )
{
  mWireList = v;
}

Wire::List Symbol::wireList() const
{
  return mWireList;
}

void Symbol::addText( const Text &v )
{
  mTextList.append( v );
}

void Symbol::setTextList( const Text::List &v )
{
  mTextList = v;
}

Text::List Symbol::textList() const
{
  return mTextList;
}

void Symbol::addDimension( const Dimension &v )
{
  mDimensionList.append( v );
}

void Symbol::setDimensionList( const Dimension::List &v )
{
  mDimensionList = v;
}

Dimension::List Symbol::dimensionList() const
{
  return mDimensionList;
}

void Symbol::addPin( const Pin &v )
{
  mPinList.append( v );
}

void Symbol::setPinList( const Pin::List &v )
{
  mPinList = v;
}

Pin::List Symbol::pinList() const
{
  return mPinList;
}

void Symbol::addCircle( const Circle &v )
{
  mCircleList.append( v );
}

void Symbol::setCircleList( const Circle::List &v )
{
  mCircleList = v;
}

Circle::List Symbol::circleList() const
{
  return mCircleList;
}

void Symbol::addRectangle( const Rectangle &v )
{
  mRectangleList.append( v );
}

void Symbol::setRectangleList( const Rectangle::List &v )
{
  mRectangleList = v;
}

Rectangle::List Symbol::rectangleList() const
{
  return mRectangleList;
}

void Symbol::addFrame( const Frame &v )
{
  mFrameList.append( v );
}

void Symbol::setFrameList( const Frame::List &v )
{
  mFrameList = v;
}

Frame::List Symbol::frameList() const
{
  return mFrameList;
}

void Symbol::setDescription( const Description &v )
{
  mDescription = v;
}

Description Symbol::description() const
{
  return mDescription;
}

Symbol::LocallyModifiedEnum Symbol::locallyModifiedEnumFromString( const QString & v, bool *ok )
{
  if (ok) *ok = true;

  if ( v == "no" ) {
    return LocallyModified_no;
  } else if ( v == "yes" ) {
    return LocallyModified_yes;
  } else {
    if (ok) *ok = false;
    return LocallyModified_Invalid;
  }

  return LocallyModified_Invalid;
}

QString Symbol::locallyModifiedEnumToString( const LocallyModifiedEnum & v )
{
  switch( v ) {
    case LocallyModified_no: return "no";
    case LocallyModified_yes: return "yes";
    case LocallyModified_Invalid:
    default:
      qCritical() << "Unable to serialize a(n) LocallyModifiedEnum enum because it has invalid value" << v;
      return QString();
  }
}

Symbol::LibraryLocallyModifiedEnum Symbol::libraryLocallyModifiedEnumFromString( const QString & v, bool *ok )
{
  if (ok) *ok = true;

  if ( v == "no" ) {
    return LibraryLocallyModified_no;
  } else if ( v == "yes" ) {
    return LibraryLocallyModified_yes;
  } else {
    if (ok) *ok = false;
    return LibraryLocallyModified_Invalid;
  }

  return LibraryLocallyModified_Invalid;
}

QString Symbol::libraryLocallyModifiedEnumToString( const LibraryLocallyModifiedEnum & v )
{
  switch( v ) {
    case LibraryLocallyModified_no: return "no";
    case LibraryLocallyModified_yes: return "yes";
    case LibraryLocallyModified_Invalid:
    default:
      qCritical() << "Unable to serialize a(n) LibraryLocallyModifiedEnum enum because it has invalid value" << v;
      return QString();
  }
}

Symbol Symbol::parseElement( const QDomElement &element, bool *ok )
{
  if ( element.tagName() != "symbol" ) {
    qCritical() << "Expected 'symbol', got '" << element.tagName() << "'.";
    if ( ok ) *ok = false;
    return Symbol();
  }

  Symbol result = Symbol();

  QDomNode n;
  for( n = element.firstChild(); !n.isNull(); n = n.nextSibling() ) {
    QDomElement e = n.toElement();
    if ( e.tagName() == "polygon" ) {
      bool ok;
      Polygon o = Polygon::parseElement( e, &ok );
      if ( ok ) result.addPolygon( o );
    }
    else if ( e.tagName() == "wire" ) {
      bool ok;
      Wire o = Wire::parseElement( e, &ok );
      if ( ok ) result.addWire( o );
    }
    else if ( e.tagName() == "text" ) {
      bool ok;
      Text o = Text::parseElement( e, &ok );
      if ( ok ) result.addText( o );
    }
    else if ( e.tagName() == "dimension" ) {
      bool ok;
      Dimension o = Dimension::parseElement( e, &ok );
      if ( ok ) result.addDimension( o );
    }
    else if ( e.tagName() == "pin" ) {
      bool ok;
      Pin o = Pin::parseElement( e, &ok );
      if ( ok ) result.addPin( o );
    }
    else if ( e.tagName() == "circle" ) {
      bool ok;
      Circle o = Circle::parseElement( e, &ok );
      if ( ok ) result.addCircle( o );
    }
    else if ( e.tagName() == "rectangle" ) {
      bool ok;
      Rectangle o = Rectangle::parseElement( e, &ok );
      if ( ok ) result.addRectangle( o );
    }
    else if ( e.tagName() == "frame" ) {
      bool ok;
      Frame o = Frame::parseElement( e, &ok );
      if ( ok ) result.addFrame( o );
    }
    else if ( e.tagName() == "description" ) {
      bool ok;
      Description o = Description::parseElement( e, &ok );
      if ( ok ) result.setDescription( o );
    }
  }

  result.setName( element.attribute( "name" ) );
  result.setUrn( element.attribute( "urn" ) );
  if (element.hasAttribute("locally_modified"))  {
    LocallyModifiedEnum locally_modified = locallyModifiedEnumFromString( element.attribute( "locally_modified" ), ok  );
    if (ok && *ok == false) {
      qCritical() << "Invalid string: \"" << element.attribute( "locally_modified" ) << "\" in the \"locally_modified\" element";
      return Symbol();
    } else {
      result.setLocallyModified( locally_modified );
    }
  } else {
    result.setLocallyModified(locallyModifiedEnumFromString("no"));
  }
  result.setLibraryVersion( element.attribute( "library_version" ).toInt() );
  if (element.hasAttribute("library_locally_modified"))  {
    LibraryLocallyModifiedEnum library_locally_modified = libraryLocallyModifiedEnumFromString( element.attribute( "library_locally_modified" ), ok  );
    if (ok && *ok == false) {
      qCritical() << "Invalid string: \"" << element.attribute( "library_locally_modified" ) << "\" in the \"library_locally_modified\" element";
      return Symbol();
    } else {
      result.setLibraryLocallyModified( library_locally_modified );
    }
  } else {
    result.setLibraryLocallyModified(libraryLocallyModifiedEnumFromString("no"));
  }

  if ( ok ) *ok = true;
  return result;
}

void Symbol::writeElement( QXmlStreamWriter &xml ) const
{
  xml.writeStartElement( "symbol" );
      xml.writeAttribute( "name", name() );
      xml.writeAttribute( "urn", urn() );
      xml.writeAttribute("locally_modified", locally_modifiedEnumToString( locally_modified() ));
      xml.writeAttribute( "library_version", QString::number( libraryVersion() ) );
      xml.writeAttribute("library_locally_modified", library_locally_modifiedEnumToString( library_locally_modified() ));
  foreach( Polygon e, polygonList() ) {
    e.writeElement( xml );
  }
  foreach( Wire e, wireList() ) {
    e.writeElement( xml );
  }
  foreach( Text e, textList() ) {
    e.writeElement( xml );
  }
  foreach( Dimension e, dimensionList() ) {
    e.writeElement( xml );
  }
  foreach( Pin e, pinList() ) {
    e.writeElement( xml );
  }
  foreach( Circle e, circleList() ) {
    e.writeElement( xml );
  }
  foreach( Rectangle e, rectangleList() ) {
    e.writeElement( xml );
  }
  foreach( Frame e, frameList() ) {
    e.writeElement( xml );
  }
  description().writeElement( xml );
  xml.writeEndElement();
}


void Symbols::addSymbol( const Symbol &v )
{
  mSymbolList.append( v );
}

void Symbols::setSymbolList( const Symbol::List &v )
{
  mSymbolList = v;
}

Symbol::List Symbols::symbolList() const
{
  return mSymbolList;
}

Symbols Symbols::parseElement( const QDomElement &element, bool *ok )
{
  if ( element.tagName() != "symbols" ) {
    qCritical() << "Expected 'symbols', got '" << element.tagName() << "'.";
    if ( ok ) *ok = false;
    return Symbols();
  }

  Symbols result = Symbols();

  QDomNode n;
  for( n = element.firstChild(); !n.isNull(); n = n.nextSibling() ) {
    QDomElement e = n.toElement();
    if ( e.tagName() == "symbol" ) {
      bool ok;
      Symbol o = Symbol::parseElement( e, &ok );
      if ( ok ) result.addSymbol( o );
    }
  }


  if ( ok ) *ok = true;
  return result;
}

void Symbols::writeElement( QXmlStreamWriter &xml ) const
{
  if ( !symbolList().isEmpty() ) {
    xml.writeStartElement( "symbols" );
    foreach( Symbol e, symbolList() ) {
      e.writeElement( xml );
    }
    xml.writeEndElement();
  }
}


void Gate::setName( const QString &v )
{
  mName = v;
}

QString Gate::name() const
{
  return mName;
}

void Gate::setSymbol( const QString &v )
{
  mSymbol = v;
}

QString Gate::symbol() const
{
  return mSymbol;
}

void Gate::setX( double v )
{
  mX = v;
}

double Gate::x() const
{
  return mX;
}

void Gate::setY( double v )
{
  mY = v;
}

double Gate::y() const
{
  return mY;
}

void Gate::setAddlevel( const AddlevelEnum &v )
{
  mAddlevel = v;
}

Gate::AddlevelEnum Gate::addlevel() const
{
  return mAddlevel;
}

void Gate::setSwaplevel( int v )
{
  mSwaplevel = v;
}

int Gate::swaplevel() const
{
  return mSwaplevel;
}

Gate::AddlevelEnum Gate::addlevelEnumFromString( const QString & v, bool *ok )
{
  if (ok) *ok = true;

  if ( v == "must" ) {
    return Addlevel_must;
  } else if ( v == "can" ) {
    return Addlevel_can;
  } else if ( v == "next" ) {
    return Addlevel_next;
  } else if ( v == "request" ) {
    return Addlevel_request;
  } else if ( v == "always" ) {
    return Addlevel_always;
  } else {
    if (ok) *ok = false;
    return Addlevel_Invalid;
  }

  return Addlevel_Invalid;
}

QString Gate::addlevelEnumToString( const AddlevelEnum & v )
{
  switch( v ) {
    case Addlevel_must: return "must";
    case Addlevel_can: return "can";
    case Addlevel_next: return "next";
    case Addlevel_request: return "request";
    case Addlevel_always: return "always";
    case Addlevel_Invalid:
    default:
      qCritical() << "Unable to serialize a(n) AddlevelEnum enum because it has invalid value" << v;
      return QString();
  }
}

Gate Gate::parseElement( const QDomElement &element, bool *ok )
{
  if ( element.tagName() != "gate" ) {
    qCritical() << "Expected 'gate', got '" << element.tagName() << "'.";
    if ( ok ) *ok = false;
    return Gate();
  }

  Gate result = Gate();

  result.setName( element.attribute( "name" ) );
  result.setSymbol( element.attribute( "symbol" ) );
  result.setX( element.attribute( "x" ).toDouble() );
  result.setY( element.attribute( "y" ).toDouble() );
  if (element.hasAttribute("addlevel"))  {
    AddlevelEnum addlevel = addlevelEnumFromString( element.attribute( "addlevel" ), ok  );
    if (ok && *ok == false) {
      qCritical() << "Invalid string: \"" << element.attribute( "addlevel" ) << "\" in the \"addlevel\" element";
      return Gate();
    } else {
      result.setAddlevel( addlevel );
    }
  } else {
    result.setAddlevel(addlevelEnumFromString("next"));
  }
  result.setSwaplevel( element.attribute( "swaplevel" ).toInt() );

  if ( ok ) *ok = true;
  return result;
}

void Gate::writeElement( QXmlStreamWriter &xml ) const
{
  xml.writeEmptyElement( "gate" );
}


void Gates::addGate( const Gate &v )
{
  mGateList.append( v );
}

void Gates::setGateList( const Gate::List &v )
{
  mGateList = v;
}

Gate::List Gates::gateList() const
{
  return mGateList;
}

Gates Gates::parseElement( const QDomElement &element, bool *ok )
{
  if ( element.tagName() != "gates" ) {
    qCritical() << "Expected 'gates', got '" << element.tagName() << "'.";
    if ( ok ) *ok = false;
    return Gates();
  }

  Gates result = Gates();

  QDomNode n;
  for( n = element.firstChild(); !n.isNull(); n = n.nextSibling() ) {
    QDomElement e = n.toElement();
    if ( e.tagName() == "gate" ) {
      bool ok;
      Gate o = Gate::parseElement( e, &ok );
      if ( ok ) result.addGate( o );
    }
  }


  if ( ok ) *ok = true;
  return result;
}

void Gates::writeElement( QXmlStreamWriter &xml ) const
{
  if ( !gateList().isEmpty() ) {
    xml.writeStartElement( "gates" );
    foreach( Gate e, gateList() ) {
      e.writeElement( xml );
    }
    xml.writeEndElement();
  }
}


void Connect::setGate( const QString &v )
{
  mGate = v;
}

QString Connect::gate() const
{
  return mGate;
}

void Connect::setPin( const QString &v )
{
  mPin = v;
}

QString Connect::pin() const
{
  return mPin;
}

void Connect::setPad( const QString &v )
{
  mPad = v;
}

QString Connect::pad() const
{
  return mPad;
}

void Connect::setRoute( const RouteEnum &v )
{
  mRoute = v;
}

Connect::RouteEnum Connect::route() const
{
  return mRoute;
}

Connect::RouteEnum Connect::routeEnumFromString( const QString & v, bool *ok )
{
  if (ok) *ok = true;

  if ( v == "all" ) {
    return Route_all;
  } else if ( v == "any" ) {
    return Route_any;
  } else {
    if (ok) *ok = false;
    return Route_Invalid;
  }

  return Route_Invalid;
}

QString Connect::routeEnumToString( const RouteEnum & v )
{
  switch( v ) {
    case Route_all: return "all";
    case Route_any: return "any";
    case Route_Invalid:
    default:
      qCritical() << "Unable to serialize a(n) RouteEnum enum because it has invalid value" << v;
      return QString();
  }
}

Connect Connect::parseElement( const QDomElement &element, bool *ok )
{
  if ( element.tagName() != "connect" ) {
    qCritical() << "Expected 'connect', got '" << element.tagName() << "'.";
    if ( ok ) *ok = false;
    return Connect();
  }

  Connect result = Connect();

  result.setGate( element.attribute( "gate" ) );
  result.setPin( element.attribute( "pin" ) );
  result.setPad( element.attribute( "pad" ) );
  if (element.hasAttribute("route"))  {
    RouteEnum route = routeEnumFromString( element.attribute( "route" ), ok  );
    if (ok && *ok == false) {
      qCritical() << "Invalid string: \"" << element.attribute( "route" ) << "\" in the \"route\" element";
      return Connect();
    } else {
      result.setRoute( route );
    }
  } else {
    result.setRoute(routeEnumFromString("all"));
  }

  if ( ok ) *ok = true;
  return result;
}

void Connect::writeElement( QXmlStreamWriter &xml ) const
{
  xml.writeEmptyElement( "connect" );
}


void Connects::addConnect( const Connect &v )
{
  mConnectList.append( v );
}

void Connects::setConnectList( const Connect::List &v )
{
  mConnectList = v;
}

Connect::List Connects::connectList() const
{
  return mConnectList;
}

Connects Connects::parseElement( const QDomElement &element, bool *ok )
{
  if ( element.tagName() != "connects" ) {
    qCritical() << "Expected 'connects', got '" << element.tagName() << "'.";
    if ( ok ) *ok = false;
    return Connects();
  }

  Connects result = Connects();

  QDomNode n;
  for( n = element.firstChild(); !n.isNull(); n = n.nextSibling() ) {
    QDomElement e = n.toElement();
    if ( e.tagName() == "connect" ) {
      bool ok;
      Connect o = Connect::parseElement( e, &ok );
      if ( ok ) result.addConnect( o );
    }
  }


  if ( ok ) *ok = true;
  return result;
}

void Connects::writeElement( QXmlStreamWriter &xml ) const
{
  if ( !connectList().isEmpty() ) {
    xml.writeStartElement( "connects" );
    foreach( Connect e, connectList() ) {
      e.writeElement( xml );
    }
    xml.writeEndElement();
  }
}


void Package3dinstance::setPackage3dUrn( const QString &v )
{
  mPackage3dUrn = v;
}

QString Package3dinstance::package3dUrn() const
{
  return mPackage3dUrn;
}

Package3dinstance Package3dinstance::parseElement( const QDomElement &element, bool *ok )
{
  if ( element.tagName() != "package3dinstance" ) {
    qCritical() << "Expected 'package3dinstance', got '" << element.tagName() << "'.";
    if ( ok ) *ok = false;
    return Package3dinstance();
  }

  Package3dinstance result = Package3dinstance();

  result.setPackage3dUrn( element.attribute( "package3d_urn" ) );

  if ( ok ) *ok = true;
  return result;
}

void Package3dinstance::writeElement( QXmlStreamWriter &xml ) const
{
  xml.writeEmptyElement( "package3dinstance" );
}


void Package3dinstances::addPackage3dinstance( const Package3dinstance &v )
{
  mPackage3dinstanceList.append( v );
}

void Package3dinstances::setPackage3dinstanceList( const Package3dinstance::List &v )
{
  mPackage3dinstanceList = v;
}

Package3dinstance::List Package3dinstances::package3dinstanceList() const
{
  return mPackage3dinstanceList;
}

Package3dinstances Package3dinstances::parseElement( const QDomElement &element, bool *ok )
{
  if ( element.tagName() != "package3dinstances" ) {
    qCritical() << "Expected 'package3dinstances', got '" << element.tagName() << "'.";
    if ( ok ) *ok = false;
    return Package3dinstances();
  }

  Package3dinstances result = Package3dinstances();

  QDomNode n;
  for( n = element.firstChild(); !n.isNull(); n = n.nextSibling() ) {
    QDomElement e = n.toElement();
    if ( e.tagName() == "package3dinstance" ) {
      bool ok;
      Package3dinstance o = Package3dinstance::parseElement( e, &ok );
      if ( ok ) result.addPackage3dinstance( o );
    }
  }


  if ( ok ) *ok = true;
  return result;
}

void Package3dinstances::writeElement( QXmlStreamWriter &xml ) const
{
  if ( !package3dinstanceList().isEmpty() ) {
    xml.writeStartElement( "package3dinstances" );
    foreach( Package3dinstance e, package3dinstanceList() ) {
      e.writeElement( xml );
    }
    xml.writeEndElement();
  }
}


void Technology::setName( const QString &v )
{
  mName = v;
}

QString Technology::name() const
{
  return mName;
}

void Technology::addAttribute( const Attribute &v )
{
  mAttributeList.append( v );
}

void Technology::setAttributeList( const Attribute::List &v )
{
  mAttributeList = v;
}

Attribute::List Technology::attributeList() const
{
  return mAttributeList;
}

Technology Technology::parseElement( const QDomElement &element, bool *ok )
{
  if ( element.tagName() != "technology" ) {
    qCritical() << "Expected 'technology', got '" << element.tagName() << "'.";
    if ( ok ) *ok = false;
    return Technology();
  }

  Technology result = Technology();

  QDomNode n;
  for( n = element.firstChild(); !n.isNull(); n = n.nextSibling() ) {
    QDomElement e = n.toElement();
    if ( e.tagName() == "attribute" ) {
      bool ok;
      Attribute o = Attribute::parseElement( e, &ok );
      if ( ok ) result.addAttribute( o );
    }
  }

  result.setName( element.attribute( "name" ) );

  if ( ok ) *ok = true;
  return result;
}

void Technology::writeElement( QXmlStreamWriter &xml ) const
{
  xml.writeStartElement( "technology" );
      xml.writeAttribute( "name", name() );
  foreach( Attribute e, attributeList() ) {
    e.writeElement( xml );
  }
  xml.writeEndElement();
}


void Technologies::addTechnology( const Technology &v )
{
  mTechnologyList.append( v );
}

void Technologies::setTechnologyList( const Technology::List &v )
{
  mTechnologyList = v;
}

Technology::List Technologies::technologyList() const
{
  return mTechnologyList;
}

Technologies Technologies::parseElement( const QDomElement &element, bool *ok )
{
  if ( element.tagName() != "technologies" ) {
    qCritical() << "Expected 'technologies', got '" << element.tagName() << "'.";
    if ( ok ) *ok = false;
    return Technologies();
  }

  Technologies result = Technologies();

  QDomNode n;
  for( n = element.firstChild(); !n.isNull(); n = n.nextSibling() ) {
    QDomElement e = n.toElement();
    if ( e.tagName() == "technology" ) {
      bool ok;
      Technology o = Technology::parseElement( e, &ok );
      if ( ok ) result.addTechnology( o );
    }
  }


  if ( ok ) *ok = true;
  return result;
}

void Technologies::writeElement( QXmlStreamWriter &xml ) const
{
  if ( !technologyList().isEmpty() ) {
    xml.writeStartElement( "technologies" );
    foreach( Technology e, technologyList() ) {
      e.writeElement( xml );
    }
    xml.writeEndElement();
  }
}


void Device::setName( const QString &v )
{
  mName = v;
}

QString Device::name() const
{
  return mName;
}

void Device::setPackage( const QString &v )
{
  mPackage = v;
}

QString Device::package() const
{
  return mPackage;
}

void Device::setConnects( const Connects &v )
{
  mConnects = v;
}

Connects Device::connects() const
{
  return mConnects;
}

void Device::setPackage3dinstances( const Package3dinstances &v )
{
  mPackage3dinstances = v;
}

Package3dinstances Device::package3dinstances() const
{
  return mPackage3dinstances;
}

void Device::setTechnologies( const Technologies &v )
{
  mTechnologies = v;
}

Technologies Device::technologies() const
{
  return mTechnologies;
}

Device Device::parseElement( const QDomElement &element, bool *ok )
{
  if ( element.tagName() != "device" ) {
    qCritical() << "Expected 'device', got '" << element.tagName() << "'.";
    if ( ok ) *ok = false;
    return Device();
  }

  Device result = Device();

  QDomNode n;
  for( n = element.firstChild(); !n.isNull(); n = n.nextSibling() ) {
    QDomElement e = n.toElement();
    if ( e.tagName() == "connects" ) {
      bool ok;
      Connects o = Connects::parseElement( e, &ok );
      if ( ok ) result.setConnects( o );
    }
    else if ( e.tagName() == "package3dinstances" ) {
      bool ok;
      Package3dinstances o = Package3dinstances::parseElement( e, &ok );
      if ( ok ) result.setPackage3dinstances( o );
    }
    else if ( e.tagName() == "technologies" ) {
      bool ok;
      Technologies o = Technologies::parseElement( e, &ok );
      if ( ok ) result.setTechnologies( o );
    }
  }

  result.setName( element.attribute( "name" ) );
  result.setPackage( element.attribute( "package" ) );

  if ( ok ) *ok = true;
  return result;
}

void Device::writeElement( QXmlStreamWriter &xml ) const
{
  xml.writeStartElement( "device" );
      xml.writeAttribute( "name", name() );
      xml.writeAttribute( "package", package() );
  connects().writeElement( xml );
  package3dinstances().writeElement( xml );
  technologies().writeElement( xml );
  xml.writeEndElement();
}


void Devices::addDevice( const Device &v )
{
  mDeviceList.append( v );
}

void Devices::setDeviceList( const Device::List &v )
{
  mDeviceList = v;
}

Device::List Devices::deviceList() const
{
  return mDeviceList;
}

Devices Devices::parseElement( const QDomElement &element, bool *ok )
{
  if ( element.tagName() != "devices" ) {
    qCritical() << "Expected 'devices', got '" << element.tagName() << "'.";
    if ( ok ) *ok = false;
    return Devices();
  }

  Devices result = Devices();

  QDomNode n;
  for( n = element.firstChild(); !n.isNull(); n = n.nextSibling() ) {
    QDomElement e = n.toElement();
    if ( e.tagName() == "device" ) {
      bool ok;
      Device o = Device::parseElement( e, &ok );
      if ( ok ) result.addDevice( o );
    }
  }


  if ( ok ) *ok = true;
  return result;
}

void Devices::writeElement( QXmlStreamWriter &xml ) const
{
  if ( !deviceList().isEmpty() ) {
    xml.writeStartElement( "devices" );
    foreach( Device e, deviceList() ) {
      e.writeElement( xml );
    }
    xml.writeEndElement();
  }
}


void Pinmap::setGate( const QString &v )
{
  mGate = v;
}

QString Pinmap::gate() const
{
  return mGate;
}

void Pinmap::setPin( const QString &v )
{
  mPin = v;
}

QString Pinmap::pin() const
{
  return mPin;
}

void Pinmap::setPinorder( const QString &v )
{
  mPinorder = v;
}

QString Pinmap::pinorder() const
{
  return mPinorder;
}

Pinmap Pinmap::parseElement( const QDomElement &element, bool *ok )
{
  if ( element.tagName() != "pinmap" ) {
    qCritical() << "Expected 'pinmap', got '" << element.tagName() << "'.";
    if ( ok ) *ok = false;
    return Pinmap();
  }

  Pinmap result = Pinmap();

  result.setGate( element.attribute( "gate" ) );
  result.setPin( element.attribute( "pin" ) );
  result.setPinorder( element.attribute( "pinorder" ) );

  if ( ok ) *ok = true;
  return result;
}

void Pinmap::writeElement( QXmlStreamWriter &xml ) const
{
  xml.writeEmptyElement( "pinmap" );
}


void Pinmapping::setIsusermap( const IsusermapEnum &v )
{
  mIsusermap = v;
}

Pinmapping::IsusermapEnum Pinmapping::isusermap() const
{
  return mIsusermap;
}

void Pinmapping::setIddevicewide( const IddevicewideEnum &v )
{
  mIddevicewide = v;
}

Pinmapping::IddevicewideEnum Pinmapping::iddevicewide() const
{
  return mIddevicewide;
}

void Pinmapping::setSpiceprefix( const QString &v )
{
  mSpiceprefix = v;
}

QString Pinmapping::spiceprefix() const
{
  return mSpiceprefix;
}

void Pinmapping::addPinmap( const Pinmap &v )
{
  mPinmapList.append( v );
}

void Pinmapping::setPinmapList( const Pinmap::List &v )
{
  mPinmapList = v;
}

Pinmap::List Pinmapping::pinmapList() const
{
  return mPinmapList;
}

Pinmapping::IsusermapEnum Pinmapping::isusermapEnumFromString( const QString & v, bool *ok )
{
  if (ok) *ok = true;

  if ( v == "no" ) {
    return Isusermap_no;
  } else if ( v == "yes" ) {
    return Isusermap_yes;
  } else {
    if (ok) *ok = false;
    return Isusermap_Invalid;
  }

  return Isusermap_Invalid;
}

QString Pinmapping::isusermapEnumToString( const IsusermapEnum & v )
{
  switch( v ) {
    case Isusermap_no: return "no";
    case Isusermap_yes: return "yes";
    case Isusermap_Invalid:
    default:
      qCritical() << "Unable to serialize a(n) IsusermapEnum enum because it has invalid value" << v;
      return QString();
  }
}

Pinmapping::IddevicewideEnum Pinmapping::iddevicewideEnumFromString( const QString & v, bool *ok )
{
  if (ok) *ok = true;

  if ( v == "no" ) {
    return Iddevicewide_no;
  } else if ( v == "yes" ) {
    return Iddevicewide_yes;
  } else {
    if (ok) *ok = false;
    return Iddevicewide_Invalid;
  }

  return Iddevicewide_Invalid;
}

QString Pinmapping::iddevicewideEnumToString( const IddevicewideEnum & v )
{
  switch( v ) {
    case Iddevicewide_no: return "no";
    case Iddevicewide_yes: return "yes";
    case Iddevicewide_Invalid:
    default:
      qCritical() << "Unable to serialize a(n) IddevicewideEnum enum because it has invalid value" << v;
      return QString();
  }
}

Pinmapping Pinmapping::parseElement( const QDomElement &element, bool *ok )
{
  if ( element.tagName() != "pinmapping" ) {
    qCritical() << "Expected 'pinmapping', got '" << element.tagName() << "'.";
    if ( ok ) *ok = false;
    return Pinmapping();
  }

  Pinmapping result = Pinmapping();

  QDomNode n;
  for( n = element.firstChild(); !n.isNull(); n = n.nextSibling() ) {
    QDomElement e = n.toElement();
    if ( e.tagName() == "pinmap" ) {
      bool ok;
      Pinmap o = Pinmap::parseElement( e, &ok );
      if ( ok ) result.addPinmap( o );
    }
  }

  if (element.hasAttribute("isusermap"))  {
    IsusermapEnum isusermap = isusermapEnumFromString( element.attribute( "isusermap" ), ok  );
    if (ok && *ok == false) {
      qCritical() << "Invalid string: \"" << element.attribute( "isusermap" ) << "\" in the \"isusermap\" element";
      return Pinmapping();
    } else {
      result.setIsusermap( isusermap );
    }
  } else {
    result.setIsusermap(isusermapEnumFromString("yes"));
  }
  if (element.hasAttribute("iddevicewide"))  {
    IddevicewideEnum iddevicewide = iddevicewideEnumFromString( element.attribute( "iddevicewide" ), ok  );
    if (ok && *ok == false) {
      qCritical() << "Invalid string: \"" << element.attribute( "iddevicewide" ) << "\" in the \"iddevicewide\" element";
      return Pinmapping();
    } else {
      result.setIddevicewide( iddevicewide );
    }
  } else {
    result.setIddevicewide(iddevicewideEnumFromString("yes"));
  }
  result.setSpiceprefix( element.attribute( "spiceprefix" ) );

  if ( ok ) *ok = true;
  return result;
}

void Pinmapping::writeElement( QXmlStreamWriter &xml ) const
{
  xml.writeStartElement( "pinmapping" );
      xml.writeAttribute("isusermap", isusermapEnumToString( isusermap() ));
      xml.writeAttribute("iddevicewide", iddevicewideEnumToString( iddevicewide() ));
      xml.writeAttribute( "spiceprefix", spiceprefix() );
  foreach( Pinmap e, pinmapList() ) {
    e.writeElement( xml );
  }
  xml.writeEndElement();
}


void Model::setName( const QString &v )
{
  mName = v;
}

QString Model::name() const
{
  return mName;
}

void Model::setValue( const QString &v )
{
  mValue = v;
}

QString Model::value() const
{
  return mValue;
}

Model Model::parseElement( const QDomElement &element, bool *ok )
{
  if ( element.tagName() != "model" ) {
    qCritical() << "Expected 'model', got '" << element.tagName() << "'.";
    if ( ok ) *ok = false;
    return Model();
  }

  Model result = Model();

  result.setValue( element.text() );
  result.setName( element.attribute( "name" ) );

  if ( ok ) *ok = true;
  return result;
}

void Model::writeElement( QXmlStreamWriter &xml ) const
{
  if ( !value().isEmpty() ) {
    xml.writeStartElement( "model" );
      xml.writeAttribute( "name", name() );
    xml.writeCharacters( value() );
    xml.writeEndElement();
  }
}


void Spice::setPinmapping( const Pinmapping &v )
{
  mPinmapping = v;
}

Pinmapping Spice::pinmapping() const
{
  return mPinmapping;
}

void Spice::setModel( const Model &v )
{
  mModel = v;
}

Model Spice::model() const
{
  return mModel;
}

Spice Spice::parseElement( const QDomElement &element, bool *ok )
{
  if ( element.tagName() != "spice" ) {
    qCritical() << "Expected 'spice', got '" << element.tagName() << "'.";
    if ( ok ) *ok = false;
    return Spice();
  }

  Spice result = Spice();

  QDomNode n;
  for( n = element.firstChild(); !n.isNull(); n = n.nextSibling() ) {
    QDomElement e = n.toElement();
    if ( e.tagName() == "pinmapping" ) {
      bool ok;
      Pinmapping o = Pinmapping::parseElement( e, &ok );
      if ( ok ) result.setPinmapping( o );
    }
    else if ( e.tagName() == "model" ) {
      bool ok;
      Model o = Model::parseElement( e, &ok );
      if ( ok ) result.setModel( o );
    }
  }


  if ( ok ) *ok = true;
  return result;
}

void Spice::writeElement( QXmlStreamWriter &xml ) const
{
  xml.writeStartElement( "spice" );
  pinmapping().writeElement( xml );
  model().writeElement( xml );
  xml.writeEndElement();
}


void Deviceset::setName( const QString &v )
{
  mName = v;
}

QString Deviceset::name() const
{
  return mName;
}

void Deviceset::setUrn( const QString &v )
{
  mUrn = v;
}

QString Deviceset::urn() const
{
  return mUrn;
}

void Deviceset::setLocallyModified( const LocallyModifiedEnum &v )
{
  mLocallyModified = v;
}

Deviceset::LocallyModifiedEnum Deviceset::locallyModified() const
{
  return mLocallyModified;
}

void Deviceset::setPrefix( const QString &v )
{
  mPrefix = v;
}

QString Deviceset::prefix() const
{
  return mPrefix;
}

void Deviceset::setUservalue( const UservalueEnum &v )
{
  mUservalue = v;
}

Deviceset::UservalueEnum Deviceset::uservalue() const
{
  return mUservalue;
}

void Deviceset::setLibraryVersion( int v )
{
  mLibraryVersion = v;
}

int Deviceset::libraryVersion() const
{
  return mLibraryVersion;
}

void Deviceset::setLibraryLocallyModified( const LibraryLocallyModifiedEnum &v )
{
  mLibraryLocallyModified = v;
}

Deviceset::LibraryLocallyModifiedEnum Deviceset::libraryLocallyModified() const
{
  return mLibraryLocallyModified;
}

void Deviceset::setDescription( const Description &v )
{
  mDescription = v;
}

Description Deviceset::description() const
{
  return mDescription;
}

void Deviceset::setGates( const Gates &v )
{
  mGates = v;
}

Gates Deviceset::gates() const
{
  return mGates;
}

void Deviceset::setDevices( const Devices &v )
{
  mDevices = v;
}

Devices Deviceset::devices() const
{
  return mDevices;
}

void Deviceset::setSpice( const Spice &v )
{
  mSpice = v;
}

Spice Deviceset::spice() const
{
  return mSpice;
}

Deviceset::LocallyModifiedEnum Deviceset::locallyModifiedEnumFromString( const QString & v, bool *ok )
{
  if (ok) *ok = true;

  if ( v == "no" ) {
    return LocallyModified_no;
  } else if ( v == "yes" ) {
    return LocallyModified_yes;
  } else {
    if (ok) *ok = false;
    return LocallyModified_Invalid;
  }

  return LocallyModified_Invalid;
}

QString Deviceset::locallyModifiedEnumToString( const LocallyModifiedEnum & v )
{
  switch( v ) {
    case LocallyModified_no: return "no";
    case LocallyModified_yes: return "yes";
    case LocallyModified_Invalid:
    default:
      qCritical() << "Unable to serialize a(n) LocallyModifiedEnum enum because it has invalid value" << v;
      return QString();
  }
}

Deviceset::UservalueEnum Deviceset::uservalueEnumFromString( const QString & v, bool *ok )
{
  if (ok) *ok = true;

  if ( v == "no" ) {
    return Uservalue_no;
  } else if ( v == "yes" ) {
    return Uservalue_yes;
  } else {
    if (ok) *ok = false;
    return Uservalue_Invalid;
  }

  return Uservalue_Invalid;
}

QString Deviceset::uservalueEnumToString( const UservalueEnum & v )
{
  switch( v ) {
    case Uservalue_no: return "no";
    case Uservalue_yes: return "yes";
    case Uservalue_Invalid:
    default:
      qCritical() << "Unable to serialize a(n) UservalueEnum enum because it has invalid value" << v;
      return QString();
  }
}

Deviceset::LibraryLocallyModifiedEnum Deviceset::libraryLocallyModifiedEnumFromString( const QString & v, bool *ok )
{
  if (ok) *ok = true;

  if ( v == "no" ) {
    return LibraryLocallyModified_no;
  } else if ( v == "yes" ) {
    return LibraryLocallyModified_yes;
  } else {
    if (ok) *ok = false;
    return LibraryLocallyModified_Invalid;
  }

  return LibraryLocallyModified_Invalid;
}

QString Deviceset::libraryLocallyModifiedEnumToString( const LibraryLocallyModifiedEnum & v )
{
  switch( v ) {
    case LibraryLocallyModified_no: return "no";
    case LibraryLocallyModified_yes: return "yes";
    case LibraryLocallyModified_Invalid:
    default:
      qCritical() << "Unable to serialize a(n) LibraryLocallyModifiedEnum enum because it has invalid value" << v;
      return QString();
  }
}

Deviceset Deviceset::parseElement( const QDomElement &element, bool *ok )
{
  if ( element.tagName() != "deviceset" ) {
    qCritical() << "Expected 'deviceset', got '" << element.tagName() << "'.";
    if ( ok ) *ok = false;
    return Deviceset();
  }

  Deviceset result = Deviceset();

  QDomNode n;
  for( n = element.firstChild(); !n.isNull(); n = n.nextSibling() ) {
    QDomElement e = n.toElement();
    if ( e.tagName() == "description" ) {
      bool ok;
      Description o = Description::parseElement( e, &ok );
      if ( ok ) result.setDescription( o );
    }
    else if ( e.tagName() == "gates" ) {
      bool ok;
      Gates o = Gates::parseElement( e, &ok );
      if ( ok ) result.setGates( o );
    }
    else if ( e.tagName() == "devices" ) {
      bool ok;
      Devices o = Devices::parseElement( e, &ok );
      if ( ok ) result.setDevices( o );
    }
    else if ( e.tagName() == "spice" ) {
      bool ok;
      Spice o = Spice::parseElement( e, &ok );
      if ( ok ) result.setSpice( o );
    }
  }

  result.setName( element.attribute( "name" ) );
  result.setUrn( element.attribute( "urn" ) );
  if (element.hasAttribute("locally_modified"))  {
    LocallyModifiedEnum locally_modified = locallyModifiedEnumFromString( element.attribute( "locally_modified" ), ok  );
    if (ok && *ok == false) {
      qCritical() << "Invalid string: \"" << element.attribute( "locally_modified" ) << "\" in the \"locally_modified\" element";
      return Deviceset();
    } else {
      result.setLocallyModified( locally_modified );
    }
  } else {
    result.setLocallyModified(locallyModifiedEnumFromString("no"));
  }
  result.setPrefix( element.attribute( "prefix" ) );
  if (element.hasAttribute("uservalue"))  {
    UservalueEnum uservalue = uservalueEnumFromString( element.attribute( "uservalue" ), ok  );
    if (ok && *ok == false) {
      qCritical() << "Invalid string: \"" << element.attribute( "uservalue" ) << "\" in the \"uservalue\" element";
      return Deviceset();
    } else {
      result.setUservalue( uservalue );
    }
  } else {
    result.setUservalue(uservalueEnumFromString("no"));
  }
  result.setLibraryVersion( element.attribute( "library_version" ).toInt() );
  if (element.hasAttribute("library_locally_modified"))  {
    LibraryLocallyModifiedEnum library_locally_modified = libraryLocallyModifiedEnumFromString( element.attribute( "library_locally_modified" ), ok  );
    if (ok && *ok == false) {
      qCritical() << "Invalid string: \"" << element.attribute( "library_locally_modified" ) << "\" in the \"library_locally_modified\" element";
      return Deviceset();
    } else {
      result.setLibraryLocallyModified( library_locally_modified );
    }
  } else {
    result.setLibraryLocallyModified(libraryLocallyModifiedEnumFromString("no"));
  }

  if ( ok ) *ok = true;
  return result;
}

void Deviceset::writeElement( QXmlStreamWriter &xml ) const
{
  xml.writeStartElement( "deviceset" );
      xml.writeAttribute( "name", name() );
      xml.writeAttribute( "urn", urn() );
      xml.writeAttribute("locally_modified", locally_modifiedEnumToString( locally_modified() ));
      xml.writeAttribute( "prefix", prefix() );
      xml.writeAttribute("uservalue", uservalueEnumToString( uservalue() ));
      xml.writeAttribute( "library_version", QString::number( libraryVersion() ) );
      xml.writeAttribute("library_locally_modified", library_locally_modifiedEnumToString( library_locally_modified() ));
  description().writeElement( xml );
  gates().writeElement( xml );
  devices().writeElement( xml );
  spice().writeElement( xml );
  xml.writeEndElement();
}


void Devicesets::addDeviceset( const Deviceset &v )
{
  mDevicesetList.append( v );
}

void Devicesets::setDevicesetList( const Deviceset::List &v )
{
  mDevicesetList = v;
}

Deviceset::List Devicesets::devicesetList() const
{
  return mDevicesetList;
}

Devicesets Devicesets::parseElement( const QDomElement &element, bool *ok )
{
  if ( element.tagName() != "devicesets" ) {
    qCritical() << "Expected 'devicesets', got '" << element.tagName() << "'.";
    if ( ok ) *ok = false;
    return Devicesets();
  }

  Devicesets result = Devicesets();

  QDomNode n;
  for( n = element.firstChild(); !n.isNull(); n = n.nextSibling() ) {
    QDomElement e = n.toElement();
    if ( e.tagName() == "deviceset" ) {
      bool ok;
      Deviceset o = Deviceset::parseElement( e, &ok );
      if ( ok ) result.addDeviceset( o );
    }
  }


  if ( ok ) *ok = true;
  return result;
}

void Devicesets::writeElement( QXmlStreamWriter &xml ) const
{
  if ( !devicesetList().isEmpty() ) {
    xml.writeStartElement( "devicesets" );
    foreach( Deviceset e, devicesetList() ) {
      e.writeElement( xml );
    }
    xml.writeEndElement();
  }
}


void Library::setName( const QString &v )
{
  mName = v;
}

QString Library::name() const
{
  return mName;
}

void Library::setUrn( const QString &v )
{
  mUrn = v;
}

QString Library::urn() const
{
  return mUrn;
}

void Library::setDescription( const Description &v )
{
  mDescription = v;
}

Description Library::description() const
{
  return mDescription;
}

void Library::setPackages( const Packages &v )
{
  mPackages = v;
}

Packages Library::packages() const
{
  return mPackages;
}

void Library::setSymbols( const Symbols &v )
{
  mSymbols = v;
}

Symbols Library::symbols() const
{
  return mSymbols;
}

void Library::setDevicesets( const Devicesets &v )
{
  mDevicesets = v;
}

Devicesets Library::devicesets() const
{
  return mDevicesets;
}

Library Library::parseElement( const QDomElement &element, bool *ok )
{
  if ( element.tagName() != "library" ) {
    qCritical() << "Expected 'library', got '" << element.tagName() << "'.";
    if ( ok ) *ok = false;
    return Library();
  }

  Library result = Library();

  QDomNode n;
  for( n = element.firstChild(); !n.isNull(); n = n.nextSibling() ) {
    QDomElement e = n.toElement();
    if ( e.tagName() == "description" ) {
      bool ok;
      Description o = Description::parseElement( e, &ok );
      if ( ok ) result.setDescription( o );
    }
    else if ( e.tagName() == "packages" ) {
      bool ok;
      Packages o = Packages::parseElement( e, &ok );
      if ( ok ) result.setPackages( o );
    }
    else if ( e.tagName() == "symbols" ) {
      bool ok;
      Symbols o = Symbols::parseElement( e, &ok );
      if ( ok ) result.setSymbols( o );
    }
    else if ( e.tagName() == "devicesets" ) {
      bool ok;
      Devicesets o = Devicesets::parseElement( e, &ok );
      if ( ok ) result.setDevicesets( o );
    }
  }

  result.setName( element.attribute( "name" ) );
  result.setUrn( element.attribute( "urn" ) );

  if ( ok ) *ok = true;
  return result;
}

void Library::writeElement( QXmlStreamWriter &xml ) const
{
  xml.writeStartElement( "library" );
      xml.writeAttribute( "name", name() );
      xml.writeAttribute( "urn", urn() );
  description().writeElement( xml );
  packages().writeElement( xml );
  symbols().writeElement( xml );
  devicesets().writeElement( xml );
  xml.writeEndElement();
}


void Libraries::addLibrary( const Library &v )
{
  mLibraryList.append( v );
}

void Libraries::setLibraryList( const Library::List &v )
{
  mLibraryList = v;
}

Library::List Libraries::libraryList() const
{
  return mLibraryList;
}

Libraries Libraries::parseElement( const QDomElement &element, bool *ok )
{
  if ( element.tagName() != "libraries" ) {
    qCritical() << "Expected 'libraries', got '" << element.tagName() << "'.";
    if ( ok ) *ok = false;
    return Libraries();
  }

  Libraries result = Libraries();

  QDomNode n;
  for( n = element.firstChild(); !n.isNull(); n = n.nextSibling() ) {
    QDomElement e = n.toElement();
    if ( e.tagName() == "library" ) {
      bool ok;
      Library o = Library::parseElement( e, &ok );
      if ( ok ) result.addLibrary( o );
    }
  }


  if ( ok ) *ok = true;
  return result;
}

void Libraries::writeElement( QXmlStreamWriter &xml ) const
{
  if ( !libraryList().isEmpty() ) {
    xml.writeStartElement( "libraries" );
    foreach( Library e, libraryList() ) {
      e.writeElement( xml );
    }
    xml.writeEndElement();
  }
}


void Attributes::addAttribute( const Attribute &v )
{
  mAttributeList.append( v );
}

void Attributes::setAttributeList( const Attribute::List &v )
{
  mAttributeList = v;
}

Attribute::List Attributes::attributeList() const
{
  return mAttributeList;
}

Attributes Attributes::parseElement( const QDomElement &element, bool *ok )
{
  if ( element.tagName() != "attributes" ) {
    qCritical() << "Expected 'attributes', got '" << element.tagName() << "'.";
    if ( ok ) *ok = false;
    return Attributes();
  }

  Attributes result = Attributes();

  QDomNode n;
  for( n = element.firstChild(); !n.isNull(); n = n.nextSibling() ) {
    QDomElement e = n.toElement();
    if ( e.tagName() == "attribute" ) {
      bool ok;
      Attribute o = Attribute::parseElement( e, &ok );
      if ( ok ) result.addAttribute( o );
    }
  }


  if ( ok ) *ok = true;
  return result;
}

void Attributes::writeElement( QXmlStreamWriter &xml ) const
{
  if ( !attributeList().isEmpty() ) {
    xml.writeStartElement( "attributes" );
    foreach( Attribute e, attributeList() ) {
      e.writeElement( xml );
    }
    xml.writeEndElement();
  }
}


void Variantdef::setName( const QString &v )
{
  mName = v;
}

QString Variantdef::name() const
{
  return mName;
}

void Variantdef::setCurrent( const CurrentEnum &v )
{
  mCurrent = v;
}

Variantdef::CurrentEnum Variantdef::current() const
{
  return mCurrent;
}

Variantdef::CurrentEnum Variantdef::currentEnumFromString( const QString & v, bool *ok )
{
  if (ok) *ok = true;

  if ( v == "no" ) {
    return Current_no;
  } else if ( v == "yes" ) {
    return Current_yes;
  } else {
    if (ok) *ok = false;
    return Current_Invalid;
  }

  return Current_Invalid;
}

QString Variantdef::currentEnumToString( const CurrentEnum & v )
{
  switch( v ) {
    case Current_no: return "no";
    case Current_yes: return "yes";
    case Current_Invalid:
    default:
      qCritical() << "Unable to serialize a(n) CurrentEnum enum because it has invalid value" << v;
      return QString();
  }
}

Variantdef Variantdef::parseElement( const QDomElement &element, bool *ok )
{
  if ( element.tagName() != "variantdef" ) {
    qCritical() << "Expected 'variantdef', got '" << element.tagName() << "'.";
    if ( ok ) *ok = false;
    return Variantdef();
  }

  Variantdef result = Variantdef();

  result.setName( element.attribute( "name" ) );
  if (element.hasAttribute("current"))  {
    CurrentEnum current = currentEnumFromString( element.attribute( "current" ), ok  );
    if (ok && *ok == false) {
      qCritical() << "Invalid string: \"" << element.attribute( "current" ) << "\" in the \"current\" element";
      return Variantdef();
    } else {
      result.setCurrent( current );
    }
  } else {
    result.setCurrent(currentEnumFromString("no"));
  }

  if ( ok ) *ok = true;
  return result;
}

void Variantdef::writeElement( QXmlStreamWriter &xml ) const
{
  xml.writeEmptyElement( "variantdef" );
}


void Variantdefs::addVariantdef( const Variantdef &v )
{
  mVariantdefList.append( v );
}

void Variantdefs::setVariantdefList( const Variantdef::List &v )
{
  mVariantdefList = v;
}

Variantdef::List Variantdefs::variantdefList() const
{
  return mVariantdefList;
}

Variantdefs Variantdefs::parseElement( const QDomElement &element, bool *ok )
{
  if ( element.tagName() != "variantdefs" ) {
    qCritical() << "Expected 'variantdefs', got '" << element.tagName() << "'.";
    if ( ok ) *ok = false;
    return Variantdefs();
  }

  Variantdefs result = Variantdefs();

  QDomNode n;
  for( n = element.firstChild(); !n.isNull(); n = n.nextSibling() ) {
    QDomElement e = n.toElement();
    if ( e.tagName() == "variantdef" ) {
      bool ok;
      Variantdef o = Variantdef::parseElement( e, &ok );
      if ( ok ) result.addVariantdef( o );
    }
  }


  if ( ok ) *ok = true;
  return result;
}

void Variantdefs::writeElement( QXmlStreamWriter &xml ) const
{
  if ( !variantdefList().isEmpty() ) {
    xml.writeStartElement( "variantdefs" );
    foreach( Variantdef e, variantdefList() ) {
      e.writeElement( xml );
    }
    xml.writeEndElement();
  }
}


void Clearance::setClass( int v )
{
  mClass = v;
}

int Clearance::class() const
{
  return mClass;
}

void Clearance::setValue( const QString &v )
{
  mValue = v;
}

QString Clearance::value() const
{
  return mValue;
}

Clearance Clearance::parseElement( const QDomElement &element, bool *ok )
{
  if ( element.tagName() != "clearance" ) {
    qCritical() << "Expected 'clearance', got '" << element.tagName() << "'.";
    if ( ok ) *ok = false;
    return Clearance();
  }

  Clearance result = Clearance();

  result.setClass( element.attribute( "class" ).toInt() );
  result.setValue( element.attribute( "value" ) );

  if ( ok ) *ok = true;
  return result;
}

void Clearance::writeElement( QXmlStreamWriter &xml ) const
{
  xml.writeEmptyElement( "clearance" );
}


void Class::setNumber( int v )
{
  mNumber = v;
}

int Class::number() const
{
  return mNumber;
}

void Class::setName( const QString &v )
{
  mName = v;
}

QString Class::name() const
{
  return mName;
}

void Class::setWidth( double v )
{
  mWidth = v;
}

double Class::width() const
{
  return mWidth;
}

void Class::setDrill( double v )
{
  mDrill = v;
}

double Class::drill() const
{
  return mDrill;
}

void Class::addClearance( const Clearance &v )
{
  mClearanceList.append( v );
}

void Class::setClearanceList( const Clearance::List &v )
{
  mClearanceList = v;
}

Clearance::List Class::clearanceList() const
{
  return mClearanceList;
}

Class Class::parseElement( const QDomElement &element, bool *ok )
{
  if ( element.tagName() != "class" ) {
    qCritical() << "Expected 'class', got '" << element.tagName() << "'.";
    if ( ok ) *ok = false;
    return Class();
  }

  Class result = Class();

  QDomNode n;
  for( n = element.firstChild(); !n.isNull(); n = n.nextSibling() ) {
    QDomElement e = n.toElement();
    if ( e.tagName() == "clearance" ) {
      bool ok;
      Clearance o = Clearance::parseElement( e, &ok );
      if ( ok ) result.addClearance( o );
    }
  }

  result.setNumber( element.attribute( "number" ).toInt() );
  result.setName( element.attribute( "name" ) );
  result.setWidth( element.attribute( "width" ).toDouble() );
  result.setDrill( element.attribute( "drill" ).toDouble() );

  if ( ok ) *ok = true;
  return result;
}

void Class::writeElement( QXmlStreamWriter &xml ) const
{
  xml.writeStartElement( "class" );
      xml.writeAttribute( "number", QString::number( number() ) );
      xml.writeAttribute( "name", name() );
      xml.writeAttribute( "width", QString::number( width() ) );
      xml.writeAttribute( "drill", QString::number( drill() ) );
  foreach( Clearance e, clearanceList() ) {
    e.writeElement( xml );
  }
  xml.writeEndElement();
}


void Classes::addClass( const Class &v )
{
  mClassList.append( v );
}

void Classes::setClassList( const Class::List &v )
{
  mClassList = v;
}

Class::List Classes::classList() const
{
  return mClassList;
}

Classes Classes::parseElement( const QDomElement &element, bool *ok )
{
  if ( element.tagName() != "classes" ) {
    qCritical() << "Expected 'classes', got '" << element.tagName() << "'.";
    if ( ok ) *ok = false;
    return Classes();
  }

  Classes result = Classes();

  QDomNode n;
  for( n = element.firstChild(); !n.isNull(); n = n.nextSibling() ) {
    QDomElement e = n.toElement();
    if ( e.tagName() == "class" ) {
      bool ok;
      Class o = Class::parseElement( e, &ok );
      if ( ok ) result.addClass( o );
    }
  }


  if ( ok ) *ok = true;
  return result;
}

void Classes::writeElement( QXmlStreamWriter &xml ) const
{
  if ( !classList().isEmpty() ) {
    xml.writeStartElement( "classes" );
    foreach( Class e, classList() ) {
      e.writeElement( xml );
    }
    xml.writeEndElement();
  }
}


void Approved::setHash( const QString &v )
{
  mHash = v;
}

QString Approved::hash() const
{
  return mHash;
}

Approved Approved::parseElement( const QDomElement &element, bool *ok )
{
  if ( element.tagName() != "approved" ) {
    qCritical() << "Expected 'approved', got '" << element.tagName() << "'.";
    if ( ok ) *ok = false;
    return Approved();
  }

  Approved result = Approved();

  result.setHash( element.attribute( "hash" ) );

  if ( ok ) *ok = true;
  return result;
}

void Approved::writeElement( QXmlStreamWriter &xml ) const
{
  xml.writeEmptyElement( "approved" );
}


void Errors::addApproved( const Approved &v )
{
  mApprovedList.append( v );
}

void Errors::setApprovedList( const Approved::List &v )
{
  mApprovedList = v;
}

Approved::List Errors::approvedList() const
{
  return mApprovedList;
}

Errors Errors::parseElement( const QDomElement &element, bool *ok )
{
  if ( element.tagName() != "errors" ) {
    qCritical() << "Expected 'errors', got '" << element.tagName() << "'.";
    if ( ok ) *ok = false;
    return Errors();
  }

  Errors result = Errors();

  QDomNode n;
  for( n = element.firstChild(); !n.isNull(); n = n.nextSibling() ) {
    QDomElement e = n.toElement();
    if ( e.tagName() == "approved" ) {
      bool ok;
      Approved o = Approved::parseElement( e, &ok );
      if ( ok ) result.addApproved( o );
    }
  }


  if ( ok ) *ok = true;
  return result;
}

void Errors::writeElement( QXmlStreamWriter &xml ) const
{
  if ( !approvedList().isEmpty() ) {
    xml.writeStartElement( "errors" );
    foreach( Approved e, approvedList() ) {
      e.writeElement( xml );
    }
    xml.writeEndElement();
  }
}


void Board::setLimitedwidth( double v )
{
  mLimitedwidth = v;
}

double Board::limitedwidth() const
{
  return mLimitedwidth;
}

void Board::setDescription( const Description &v )
{
  mDescription = v;
}

Description Board::description() const
{
  return mDescription;
}

void Board::setFusionsync( const Fusionsync &v )
{
  mFusionsync = v;
}

Fusionsync Board::fusionsync() const
{
  return mFusionsync;
}

void Board::setPlain( const Plain &v )
{
  mPlain = v;
}

Plain Board::plain() const
{
  return mPlain;
}

void Board::setLibraries( const Libraries &v )
{
  mLibraries = v;
}

Libraries Board::libraries() const
{
  return mLibraries;
}

void Board::setAttributes( const Attributes &v )
{
  mAttributes = v;
}

Attributes Board::attributes() const
{
  return mAttributes;
}

void Board::setVariantdefs( const Variantdefs &v )
{
  mVariantdefs = v;
}

Variantdefs Board::variantdefs() const
{
  return mVariantdefs;
}

void Board::setClasses( const Classes &v )
{
  mClasses = v;
}

Classes Board::classes() const
{
  return mClasses;
}

void Board::setDesignrules( const Designrules &v )
{
  mDesignrules = v;
}

Designrules Board::designrules() const
{
  return mDesignrules;
}

void Board::setAutorouter( const Autorouter &v )
{
  mAutorouter = v;
}

Autorouter Board::autorouter() const
{
  return mAutorouter;
}

void Board::setElements( const Elements &v )
{
  mElements = v;
}

Elements Board::elements() const
{
  return mElements;
}

void Board::setSignals( const Signals &v )
{
  mSignals = v;
}

Signals Board::signals() const
{
  return mSignals;
}

void Board::setErrors( const Errors &v )
{
  mErrors = v;
}

Errors Board::errors() const
{
  return mErrors;
}

Board Board::parseElement( const QDomElement &element, bool *ok )
{
  if ( element.tagName() != "board" ) {
    qCritical() << "Expected 'board', got '" << element.tagName() << "'.";
    if ( ok ) *ok = false;
    return Board();
  }

  Board result = Board();

  QDomNode n;
  for( n = element.firstChild(); !n.isNull(); n = n.nextSibling() ) {
    QDomElement e = n.toElement();
    if ( e.tagName() == "description" ) {
      bool ok;
      Description o = Description::parseElement( e, &ok );
      if ( ok ) result.setDescription( o );
    }
    else if ( e.tagName() == "fusionsync" ) {
      bool ok;
      Fusionsync o = Fusionsync::parseElement( e, &ok );
      if ( ok ) result.setFusionsync( o );
    }
    else if ( e.tagName() == "plain" ) {
      bool ok;
      Plain o = Plain::parseElement( e, &ok );
      if ( ok ) result.setPlain( o );
    }
    else if ( e.tagName() == "libraries" ) {
      bool ok;
      Libraries o = Libraries::parseElement( e, &ok );
      if ( ok ) result.setLibraries( o );
    }
    else if ( e.tagName() == "attributes" ) {
      bool ok;
      Attributes o = Attributes::parseElement( e, &ok );
      if ( ok ) result.setAttributes( o );
    }
    else if ( e.tagName() == "variantdefs" ) {
      bool ok;
      Variantdefs o = Variantdefs::parseElement( e, &ok );
      if ( ok ) result.setVariantdefs( o );
    }
    else if ( e.tagName() == "classes" ) {
      bool ok;
      Classes o = Classes::parseElement( e, &ok );
      if ( ok ) result.setClasses( o );
    }
    else if ( e.tagName() == "designrules" ) {
      bool ok;
      Designrules o = Designrules::parseElement( e, &ok );
      if ( ok ) result.setDesignrules( o );
    }
    else if ( e.tagName() == "autorouter" ) {
      bool ok;
      Autorouter o = Autorouter::parseElement( e, &ok );
      if ( ok ) result.setAutorouter( o );
    }
    else if ( e.tagName() == "elements" ) {
      bool ok;
      Elements o = Elements::parseElement( e, &ok );
      if ( ok ) result.setElements( o );
    }
    else if ( e.tagName() == "signals" ) {
      bool ok;
      Signals o = Signals::parseElement( e, &ok );
      if ( ok ) result.setSignals( o );
    }
    else if ( e.tagName() == "errors" ) {
      bool ok;
      Errors o = Errors::parseElement( e, &ok );
      if ( ok ) result.setErrors( o );
    }
  }

  result.setLimitedwidth( element.attribute( "limitedwidth" ).toDouble() );

  if ( ok ) *ok = true;
  return result;
}

void Board::writeElement( QXmlStreamWriter &xml ) const
{
  xml.writeStartElement( "board" );
      xml.writeAttribute( "limitedwidth", QString::number( limitedwidth() ) );
  description().writeElement( xml );
  fusionsync().writeElement( xml );
  plain().writeElement( xml );
  libraries().writeElement( xml );
  attributes().writeElement( xml );
  variantdefs().writeElement( xml );
  classes().writeElement( xml );
  designrules().writeElement( xml );
  autorouter().writeElement( xml );
  elements().writeElement( xml );
  signals().writeElement( xml );
  errors().writeElement( xml );
  xml.writeEndElement();
}


void Pinref::setPart( const QString &v )
{
  mPart = v;
}

QString Pinref::part() const
{
  return mPart;
}

void Pinref::setGate( const QString &v )
{
  mGate = v;
}

QString Pinref::gate() const
{
  return mGate;
}

void Pinref::setPin( const QString &v )
{
  mPin = v;
}

QString Pinref::pin() const
{
  return mPin;
}

Pinref Pinref::parseElement( const QDomElement &element, bool *ok )
{
  if ( element.tagName() != "pinref" ) {
    qCritical() << "Expected 'pinref', got '" << element.tagName() << "'.";
    if ( ok ) *ok = false;
    return Pinref();
  }

  Pinref result = Pinref();

  result.setPart( element.attribute( "part" ) );
  result.setGate( element.attribute( "gate" ) );
  result.setPin( element.attribute( "pin" ) );

  if ( ok ) *ok = true;
  return result;
}

void Pinref::writeElement( QXmlStreamWriter &xml ) const
{
  xml.writeEmptyElement( "pinref" );
}


void Portref::setModuleinst( const QString &v )
{
  mModuleinst = v;
}

QString Portref::moduleinst() const
{
  return mModuleinst;
}

void Portref::setPort( const QString &v )
{
  mPort = v;
}

QString Portref::port() const
{
  return mPort;
}

Portref Portref::parseElement( const QDomElement &element, bool *ok )
{
  if ( element.tagName() != "portref" ) {
    qCritical() << "Expected 'portref', got '" << element.tagName() << "'.";
    if ( ok ) *ok = false;
    return Portref();
  }

  Portref result = Portref();

  result.setModuleinst( element.attribute( "moduleinst" ) );
  result.setPort( element.attribute( "port" ) );

  if ( ok ) *ok = true;
  return result;
}

void Portref::writeElement( QXmlStreamWriter &xml ) const
{
  xml.writeEmptyElement( "portref" );
}


void Junction::setX( double v )
{
  mX = v;
}

double Junction::x() const
{
  return mX;
}

void Junction::setY( double v )
{
  mY = v;
}

double Junction::y() const
{
  return mY;
}

Junction Junction::parseElement( const QDomElement &element, bool *ok )
{
  if ( element.tagName() != "junction" ) {
    qCritical() << "Expected 'junction', got '" << element.tagName() << "'.";
    if ( ok ) *ok = false;
    return Junction();
  }

  Junction result = Junction();

  result.setX( element.attribute( "x" ).toDouble() );
  result.setY( element.attribute( "y" ).toDouble() );

  if ( ok ) *ok = true;
  return result;
}

void Junction::writeElement( QXmlStreamWriter &xml ) const
{
  xml.writeEmptyElement( "junction" );
}


void Label::setX( double v )
{
  mX = v;
}

double Label::x() const
{
  return mX;
}

void Label::setY( double v )
{
  mY = v;
}

double Label::y() const
{
  return mY;
}

void Label::setSize( double v )
{
  mSize = v;
}

double Label::size() const
{
  return mSize;
}

void Label::setLayer( int v )
{
  mLayer = v;
}

int Label::layer() const
{
  return mLayer;
}

void Label::setFont( const FontEnum &v )
{
  mFont = v;
}

Label::FontEnum Label::font() const
{
  return mFont;
}

void Label::setRatio( int v )
{
  mRatio = v;
}

int Label::ratio() const
{
  return mRatio;
}

void Label::setRot( const QString &v )
{
  mRot = v;
}

QString Label::rot() const
{
  return mRot;
}

void Label::setXref( const XrefEnum &v )
{
  mXref = v;
}

Label::XrefEnum Label::xref() const
{
  return mXref;
}

void Label::setAlign( const AlignEnum &v )
{
  mAlign = v;
}

Label::AlignEnum Label::align() const
{
  return mAlign;
}

Label::FontEnum Label::fontEnumFromString( const QString & v, bool *ok )
{
  if (ok) *ok = true;

  if ( v == "vector" ) {
    return Font_vector;
  } else if ( v == "proportional" ) {
    return Font_proportional;
  } else if ( v == "fixed" ) {
    return Font_fixed;
  } else {
    if (ok) *ok = false;
    return Font_Invalid;
  }

  return Font_Invalid;
}

QString Label::fontEnumToString( const FontEnum & v )
{
  switch( v ) {
    case Font_vector: return "vector";
    case Font_proportional: return "proportional";
    case Font_fixed: return "fixed";
    case Font_Invalid:
    default:
      qCritical() << "Unable to serialize a(n) FontEnum enum because it has invalid value" << v;
      return QString();
  }
}

Label::XrefEnum Label::xrefEnumFromString( const QString & v, bool *ok )
{
  if (ok) *ok = true;

  if ( v == "no" ) {
    return Xref_no;
  } else if ( v == "yes" ) {
    return Xref_yes;
  } else {
    if (ok) *ok = false;
    return Xref_Invalid;
  }

  return Xref_Invalid;
}

QString Label::xrefEnumToString( const XrefEnum & v )
{
  switch( v ) {
    case Xref_no: return "no";
    case Xref_yes: return "yes";
    case Xref_Invalid:
    default:
      qCritical() << "Unable to serialize a(n) XrefEnum enum because it has invalid value" << v;
      return QString();
  }
}

Label::AlignEnum Label::alignEnumFromString( const QString & v, bool *ok )
{
  if (ok) *ok = true;

  if ( v == "bottom-left" ) {
    return Align_bottom_left;
  } else if ( v == "bottom-center" ) {
    return Align_bottom_center;
  } else if ( v == "bottom-right" ) {
    return Align_bottom_right;
  } else if ( v == "center-left" ) {
    return Align_center_left;
  } else if ( v == "center" ) {
    return Align_center;
  } else if ( v == "center-right" ) {
    return Align_center_right;
  } else if ( v == "top-left" ) {
    return Align_top_left;
  } else if ( v == "top-center" ) {
    return Align_top_center;
  } else if ( v == "top-right" ) {
    return Align_top_right;
  } else {
    if (ok) *ok = false;
    return Align_Invalid;
  }

  return Align_Invalid;
}

QString Label::alignEnumToString( const AlignEnum & v )
{
  switch( v ) {
    case Align_bottom_left: return "bottom-left";
    case Align_bottom_center: return "bottom-center";
    case Align_bottom_right: return "bottom-right";
    case Align_center_left: return "center-left";
    case Align_center: return "center";
    case Align_center_right: return "center-right";
    case Align_top_left: return "top-left";
    case Align_top_center: return "top-center";
    case Align_top_right: return "top-right";
    case Align_Invalid:
    default:
      qCritical() << "Unable to serialize a(n) AlignEnum enum because it has invalid value" << v;
      return QString();
  }
}

Label Label::parseElement( const QDomElement &element, bool *ok )
{
  if ( element.tagName() != "label" ) {
    qCritical() << "Expected 'label', got '" << element.tagName() << "'.";
    if ( ok ) *ok = false;
    return Label();
  }

  Label result = Label();

  result.setX( element.attribute( "x" ).toDouble() );
  result.setY( element.attribute( "y" ).toDouble() );
  result.setSize( element.attribute( "size" ).toDouble() );
  result.setLayer( element.attribute( "layer" ).toInt() );
  if (element.hasAttribute("font"))  {
    FontEnum font = fontEnumFromString( element.attribute( "font" ), ok  );
    if (ok && *ok == false) {
      qCritical() << "Invalid string: \"" << element.attribute( "font" ) << "\" in the \"font\" element";
      return Label();
    } else {
      result.setFont( font );
    }
  } else {
    result.setFont(fontEnumFromString("proportional"));
  }
  result.setRatio( element.attribute( "ratio" ).toInt() );
  result.setRot( element.attribute( "rot" ) );
  if (element.hasAttribute("xref"))  {
    XrefEnum xref = xrefEnumFromString( element.attribute( "xref" ), ok  );
    if (ok && *ok == false) {
      qCritical() << "Invalid string: \"" << element.attribute( "xref" ) << "\" in the \"xref\" element";
      return Label();
    } else {
      result.setXref( xref );
    }
  } else {
    result.setXref(xrefEnumFromString("no"));
  }
  if (element.hasAttribute("align"))  {
    AlignEnum align = alignEnumFromString( element.attribute( "align" ), ok  );
    if (ok && *ok == false) {
      qCritical() << "Invalid string: \"" << element.attribute( "align" ) << "\" in the \"align\" element";
      return Label();
    } else {
      result.setAlign( align );
    }
  } else {
    result.setAlign(alignEnumFromString("bottom-left"));
  }

  if ( ok ) *ok = true;
  return result;
}

void Label::writeElement( QXmlStreamWriter &xml ) const
{
  xml.writeEmptyElement( "label" );
}


void Probe::setX( double v )
{
  mX = v;
}

double Probe::x() const
{
  return mX;
}

void Probe::setY( double v )
{
  mY = v;
}

double Probe::y() const
{
  return mY;
}

void Probe::setSize( double v )
{
  mSize = v;
}

double Probe::size() const
{
  return mSize;
}

void Probe::setLayer( int v )
{
  mLayer = v;
}

int Probe::layer() const
{
  return mLayer;
}

void Probe::setFont( const FontEnum &v )
{
  mFont = v;
}

Probe::FontEnum Probe::font() const
{
  return mFont;
}

void Probe::setRatio( int v )
{
  mRatio = v;
}

int Probe::ratio() const
{
  return mRatio;
}

void Probe::setRot( const QString &v )
{
  mRot = v;
}

QString Probe::rot() const
{
  return mRot;
}

void Probe::setXref( const XrefEnum &v )
{
  mXref = v;
}

Probe::XrefEnum Probe::xref() const
{
  return mXref;
}

Probe::FontEnum Probe::fontEnumFromString( const QString & v, bool *ok )
{
  if (ok) *ok = true;

  if ( v == "vector" ) {
    return Font_vector;
  } else if ( v == "proportional" ) {
    return Font_proportional;
  } else if ( v == "fixed" ) {
    return Font_fixed;
  } else {
    if (ok) *ok = false;
    return Font_Invalid;
  }

  return Font_Invalid;
}

QString Probe::fontEnumToString( const FontEnum & v )
{
  switch( v ) {
    case Font_vector: return "vector";
    case Font_proportional: return "proportional";
    case Font_fixed: return "fixed";
    case Font_Invalid:
    default:
      qCritical() << "Unable to serialize a(n) FontEnum enum because it has invalid value" << v;
      return QString();
  }
}

Probe::XrefEnum Probe::xrefEnumFromString( const QString & v, bool *ok )
{
  if (ok) *ok = true;

  if ( v == "no" ) {
    return Xref_no;
  } else if ( v == "yes" ) {
    return Xref_yes;
  } else {
    if (ok) *ok = false;
    return Xref_Invalid;
  }

  return Xref_Invalid;
}

QString Probe::xrefEnumToString( const XrefEnum & v )
{
  switch( v ) {
    case Xref_no: return "no";
    case Xref_yes: return "yes";
    case Xref_Invalid:
    default:
      qCritical() << "Unable to serialize a(n) XrefEnum enum because it has invalid value" << v;
      return QString();
  }
}

Probe Probe::parseElement( const QDomElement &element, bool *ok )
{
  if ( element.tagName() != "probe" ) {
    qCritical() << "Expected 'probe', got '" << element.tagName() << "'.";
    if ( ok ) *ok = false;
    return Probe();
  }

  Probe result = Probe();

  result.setX( element.attribute( "x" ).toDouble() );
  result.setY( element.attribute( "y" ).toDouble() );
  result.setSize( element.attribute( "size" ).toDouble() );
  result.setLayer( element.attribute( "layer" ).toInt() );
  if (element.hasAttribute("font"))  {
    FontEnum font = fontEnumFromString( element.attribute( "font" ), ok  );
    if (ok && *ok == false) {
      qCritical() << "Invalid string: \"" << element.attribute( "font" ) << "\" in the \"font\" element";
      return Probe();
    } else {
      result.setFont( font );
    }
  } else {
    result.setFont(fontEnumFromString("proportional"));
  }
  result.setRatio( element.attribute( "ratio" ).toInt() );
  result.setRot( element.attribute( "rot" ) );
  if (element.hasAttribute("xref"))  {
    XrefEnum xref = xrefEnumFromString( element.attribute( "xref" ), ok  );
    if (ok && *ok == false) {
      qCritical() << "Invalid string: \"" << element.attribute( "xref" ) << "\" in the \"xref\" element";
      return Probe();
    } else {
      result.setXref( xref );
    }
  } else {
    result.setXref(xrefEnumFromString("no"));
  }

  if ( ok ) *ok = true;
  return result;
}

void Probe::writeElement( QXmlStreamWriter &xml ) const
{
  xml.writeEmptyElement( "probe" );
}


void Segment::addPinref( const Pinref &v )
{
  mPinrefList.append( v );
}

void Segment::setPinrefList( const Pinref::List &v )
{
  mPinrefList = v;
}

Pinref::List Segment::pinrefList() const
{
  return mPinrefList;
}

void Segment::addPortref( const Portref &v )
{
  mPortrefList.append( v );
}

void Segment::setPortrefList( const Portref::List &v )
{
  mPortrefList = v;
}

Portref::List Segment::portrefList() const
{
  return mPortrefList;
}

void Segment::addWire( const Wire &v )
{
  mWireList.append( v );
}

void Segment::setWireList( const Wire::List &v )
{
  mWireList = v;
}

Wire::List Segment::wireList() const
{
  return mWireList;
}

void Segment::addJunction( const Junction &v )
{
  mJunctionList.append( v );
}

void Segment::setJunctionList( const Junction::List &v )
{
  mJunctionList = v;
}

Junction::List Segment::junctionList() const
{
  return mJunctionList;
}

void Segment::addLabel( const Label &v )
{
  mLabelList.append( v );
}

void Segment::setLabelList( const Label::List &v )
{
  mLabelList = v;
}

Label::List Segment::labelList() const
{
  return mLabelList;
}

void Segment::addProbe( const Probe &v )
{
  mProbeList.append( v );
}

void Segment::setProbeList( const Probe::List &v )
{
  mProbeList = v;
}

Probe::List Segment::probeList() const
{
  return mProbeList;
}

Segment Segment::parseElement( const QDomElement &element, bool *ok )
{
  if ( element.tagName() != "segment" ) {
    qCritical() << "Expected 'segment', got '" << element.tagName() << "'.";
    if ( ok ) *ok = false;
    return Segment();
  }

  Segment result = Segment();

  QDomNode n;
  for( n = element.firstChild(); !n.isNull(); n = n.nextSibling() ) {
    QDomElement e = n.toElement();
    if ( e.tagName() == "pinref" ) {
      bool ok;
      Pinref o = Pinref::parseElement( e, &ok );
      if ( ok ) result.addPinref( o );
    }
    else if ( e.tagName() == "portref" ) {
      bool ok;
      Portref o = Portref::parseElement( e, &ok );
      if ( ok ) result.addPortref( o );
    }
    else if ( e.tagName() == "wire" ) {
      bool ok;
      Wire o = Wire::parseElement( e, &ok );
      if ( ok ) result.addWire( o );
    }
    else if ( e.tagName() == "junction" ) {
      bool ok;
      Junction o = Junction::parseElement( e, &ok );
      if ( ok ) result.addJunction( o );
    }
    else if ( e.tagName() == "label" ) {
      bool ok;
      Label o = Label::parseElement( e, &ok );
      if ( ok ) result.addLabel( o );
    }
    else if ( e.tagName() == "probe" ) {
      bool ok;
      Probe o = Probe::parseElement( e, &ok );
      if ( ok ) result.addProbe( o );
    }
  }


  if ( ok ) *ok = true;
  return result;
}

void Segment::writeElement( QXmlStreamWriter &xml ) const
{
  if ( !pinrefList().isEmpty() || !portrefList().isEmpty() || !wireList().isEmpty() || !junctionList().isEmpty() || !labelList().isEmpty() || !probeList().isEmpty() ) {
    xml.writeStartElement( "segment" );
    foreach( Pinref e, pinrefList() ) {
      e.writeElement( xml );
    }
    foreach( Portref e, portrefList() ) {
      e.writeElement( xml );
    }
    foreach( Wire e, wireList() ) {
      e.writeElement( xml );
    }
    foreach( Junction e, junctionList() ) {
      e.writeElement( xml );
    }
    foreach( Label e, labelList() ) {
      e.writeElement( xml );
    }
    foreach( Probe e, probeList() ) {
      e.writeElement( xml );
    }
    xml.writeEndElement();
  }
}


void Net::setName( const QString &v )
{
  mName = v;
}

QString Net::name() const
{
  return mName;
}

void Net::setClass( int v )
{
  mClass = v;
}

int Net::class() const
{
  return mClass;
}

void Net::addSegment( const Segment &v )
{
  mSegmentList.append( v );
}

void Net::setSegmentList( const Segment::List &v )
{
  mSegmentList = v;
}

Segment::List Net::segmentList() const
{
  return mSegmentList;
}

Net Net::parseElement( const QDomElement &element, bool *ok )
{
  if ( element.tagName() != "net" ) {
    qCritical() << "Expected 'net', got '" << element.tagName() << "'.";
    if ( ok ) *ok = false;
    return Net();
  }

  Net result = Net();

  QDomNode n;
  for( n = element.firstChild(); !n.isNull(); n = n.nextSibling() ) {
    QDomElement e = n.toElement();
    if ( e.tagName() == "segment" ) {
      bool ok;
      Segment o = Segment::parseElement( e, &ok );
      if ( ok ) result.addSegment( o );
    }
  }

  result.setName( element.attribute( "name" ) );
  result.setClass( element.attribute( "class" ).toInt() );

  if ( ok ) *ok = true;
  return result;
}

void Net::writeElement( QXmlStreamWriter &xml ) const
{
  xml.writeStartElement( "net" );
      xml.writeAttribute( "name", name() );
      xml.writeAttribute( "class", QString::number( class() ) );
  foreach( Segment e, segmentList() ) {
    e.writeElement( xml );
  }
  xml.writeEndElement();
}


void Nets::addNet( const Net &v )
{
  mNetList.append( v );
}

void Nets::setNetList( const Net::List &v )
{
  mNetList = v;
}

Net::List Nets::netList() const
{
  return mNetList;
}

Nets Nets::parseElement( const QDomElement &element, bool *ok )
{
  if ( element.tagName() != "nets" ) {
    qCritical() << "Expected 'nets', got '" << element.tagName() << "'.";
    if ( ok ) *ok = false;
    return Nets();
  }

  Nets result = Nets();

  QDomNode n;
  for( n = element.firstChild(); !n.isNull(); n = n.nextSibling() ) {
    QDomElement e = n.toElement();
    if ( e.tagName() == "net" ) {
      bool ok;
      Net o = Net::parseElement( e, &ok );
      if ( ok ) result.addNet( o );
    }
  }


  if ( ok ) *ok = true;
  return result;
}

void Nets::writeElement( QXmlStreamWriter &xml ) const
{
  if ( !netList().isEmpty() ) {
    xml.writeStartElement( "nets" );
    foreach( Net e, netList() ) {
      e.writeElement( xml );
    }
    xml.writeEndElement();
  }
}


void Bus::setName( const QString &v )
{
  mName = v;
}

QString Bus::name() const
{
  return mName;
}

void Bus::addSegment( const Segment &v )
{
  mSegmentList.append( v );
}

void Bus::setSegmentList( const Segment::List &v )
{
  mSegmentList = v;
}

Segment::List Bus::segmentList() const
{
  return mSegmentList;
}

Bus Bus::parseElement( const QDomElement &element, bool *ok )
{
  if ( element.tagName() != "bus" ) {
    qCritical() << "Expected 'bus', got '" << element.tagName() << "'.";
    if ( ok ) *ok = false;
    return Bus();
  }

  Bus result = Bus();

  QDomNode n;
  for( n = element.firstChild(); !n.isNull(); n = n.nextSibling() ) {
    QDomElement e = n.toElement();
    if ( e.tagName() == "segment" ) {
      bool ok;
      Segment o = Segment::parseElement( e, &ok );
      if ( ok ) result.addSegment( o );
    }
  }

  result.setName( element.attribute( "name" ) );

  if ( ok ) *ok = true;
  return result;
}

void Bus::writeElement( QXmlStreamWriter &xml ) const
{
  xml.writeStartElement( "bus" );
      xml.writeAttribute( "name", name() );
  foreach( Segment e, segmentList() ) {
    e.writeElement( xml );
  }
  xml.writeEndElement();
}


void Busses::addBus( const Bus &v )
{
  mBusList.append( v );
}

void Busses::setBusList( const Bus::List &v )
{
  mBusList = v;
}

Bus::List Busses::busList() const
{
  return mBusList;
}

Busses Busses::parseElement( const QDomElement &element, bool *ok )
{
  if ( element.tagName() != "busses" ) {
    qCritical() << "Expected 'busses', got '" << element.tagName() << "'.";
    if ( ok ) *ok = false;
    return Busses();
  }

  Busses result = Busses();

  QDomNode n;
  for( n = element.firstChild(); !n.isNull(); n = n.nextSibling() ) {
    QDomElement e = n.toElement();
    if ( e.tagName() == "bus" ) {
      bool ok;
      Bus o = Bus::parseElement( e, &ok );
      if ( ok ) result.addBus( o );
    }
  }


  if ( ok ) *ok = true;
  return result;
}

void Busses::writeElement( QXmlStreamWriter &xml ) const
{
  if ( !busList().isEmpty() ) {
    xml.writeStartElement( "busses" );
    foreach( Bus e, busList() ) {
      e.writeElement( xml );
    }
    xml.writeEndElement();
  }
}


void Instance::setPart( const QString &v )
{
  mPart = v;
}

QString Instance::part() const
{
  return mPart;
}

void Instance::setGate( const QString &v )
{
  mGate = v;
}

QString Instance::gate() const
{
  return mGate;
}

void Instance::setX( double v )
{
  mX = v;
}

double Instance::x() const
{
  return mX;
}

void Instance::setY( double v )
{
  mY = v;
}

double Instance::y() const
{
  return mY;
}

void Instance::setSmashed( const SmashedEnum &v )
{
  mSmashed = v;
}

Instance::SmashedEnum Instance::smashed() const
{
  return mSmashed;
}

void Instance::setRot( const QString &v )
{
  mRot = v;
}

QString Instance::rot() const
{
  return mRot;
}

void Instance::addAttribute( const Attribute &v )
{
  mAttributeList.append( v );
}

void Instance::setAttributeList( const Attribute::List &v )
{
  mAttributeList = v;
}

Attribute::List Instance::attributeList() const
{
  return mAttributeList;
}

Instance::SmashedEnum Instance::smashedEnumFromString( const QString & v, bool *ok )
{
  if (ok) *ok = true;

  if ( v == "no" ) {
    return Smashed_no;
  } else if ( v == "yes" ) {
    return Smashed_yes;
  } else {
    if (ok) *ok = false;
    return Smashed_Invalid;
  }

  return Smashed_Invalid;
}

QString Instance::smashedEnumToString( const SmashedEnum & v )
{
  switch( v ) {
    case Smashed_no: return "no";
    case Smashed_yes: return "yes";
    case Smashed_Invalid:
    default:
      qCritical() << "Unable to serialize a(n) SmashedEnum enum because it has invalid value" << v;
      return QString();
  }
}

Instance Instance::parseElement( const QDomElement &element, bool *ok )
{
  if ( element.tagName() != "instance" ) {
    qCritical() << "Expected 'instance', got '" << element.tagName() << "'.";
    if ( ok ) *ok = false;
    return Instance();
  }

  Instance result = Instance();

  QDomNode n;
  for( n = element.firstChild(); !n.isNull(); n = n.nextSibling() ) {
    QDomElement e = n.toElement();
    if ( e.tagName() == "attribute" ) {
      bool ok;
      Attribute o = Attribute::parseElement( e, &ok );
      if ( ok ) result.addAttribute( o );
    }
  }

  result.setPart( element.attribute( "part" ) );
  result.setGate( element.attribute( "gate" ) );
  result.setX( element.attribute( "x" ).toDouble() );
  result.setY( element.attribute( "y" ).toDouble() );
  if (element.hasAttribute("smashed"))  {
    SmashedEnum smashed = smashedEnumFromString( element.attribute( "smashed" ), ok  );
    if (ok && *ok == false) {
      qCritical() << "Invalid string: \"" << element.attribute( "smashed" ) << "\" in the \"smashed\" element";
      return Instance();
    } else {
      result.setSmashed( smashed );
    }
  } else {
    result.setSmashed(smashedEnumFromString("no"));
  }
  result.setRot( element.attribute( "rot" ) );

  if ( ok ) *ok = true;
  return result;
}

void Instance::writeElement( QXmlStreamWriter &xml ) const
{
  xml.writeStartElement( "instance" );
      xml.writeAttribute( "part", part() );
      xml.writeAttribute( "gate", gate() );
      xml.writeAttribute( "x", QString::number( x() ) );
      xml.writeAttribute( "y", QString::number( y() ) );
      xml.writeAttribute("smashed", smashedEnumToString( smashed() ));
      xml.writeAttribute( "rot", rot() );
  foreach( Attribute e, attributeList() ) {
    e.writeElement( xml );
  }
  xml.writeEndElement();
}


void Instances::addInstance( const Instance &v )
{
  mInstanceList.append( v );
}

void Instances::setInstanceList( const Instance::List &v )
{
  mInstanceList = v;
}

Instance::List Instances::instanceList() const
{
  return mInstanceList;
}

Instances Instances::parseElement( const QDomElement &element, bool *ok )
{
  if ( element.tagName() != "instances" ) {
    qCritical() << "Expected 'instances', got '" << element.tagName() << "'.";
    if ( ok ) *ok = false;
    return Instances();
  }

  Instances result = Instances();

  QDomNode n;
  for( n = element.firstChild(); !n.isNull(); n = n.nextSibling() ) {
    QDomElement e = n.toElement();
    if ( e.tagName() == "instance" ) {
      bool ok;
      Instance o = Instance::parseElement( e, &ok );
      if ( ok ) result.addInstance( o );
    }
  }


  if ( ok ) *ok = true;
  return result;
}

void Instances::writeElement( QXmlStreamWriter &xml ) const
{
  if ( !instanceList().isEmpty() ) {
    xml.writeStartElement( "instances" );
    foreach( Instance e, instanceList() ) {
      e.writeElement( xml );
    }
    xml.writeEndElement();
  }
}


void Moduleinst::setName( const QString &v )
{
  mName = v;
}

QString Moduleinst::name() const
{
  return mName;
}

void Moduleinst::setModule( const QString &v )
{
  mModule = v;
}

QString Moduleinst::module() const
{
  return mModule;
}

void Moduleinst::setModulevariant( const QString &v )
{
  mModulevariant = v;
}

QString Moduleinst::modulevariant() const
{
  return mModulevariant;
}

void Moduleinst::setX( double v )
{
  mX = v;
}

double Moduleinst::x() const
{
  return mX;
}

void Moduleinst::setY( double v )
{
  mY = v;
}

double Moduleinst::y() const
{
  return mY;
}

void Moduleinst::setOffset( int v )
{
  mOffset = v;
}

int Moduleinst::offset() const
{
  return mOffset;
}

void Moduleinst::setSmashed( const SmashedEnum &v )
{
  mSmashed = v;
}

Moduleinst::SmashedEnum Moduleinst::smashed() const
{
  return mSmashed;
}

void Moduleinst::setRot( const QString &v )
{
  mRot = v;
}

QString Moduleinst::rot() const
{
  return mRot;
}

void Moduleinst::addAttribute( const Attribute &v )
{
  mAttributeList.append( v );
}

void Moduleinst::setAttributeList( const Attribute::List &v )
{
  mAttributeList = v;
}

Attribute::List Moduleinst::attributeList() const
{
  return mAttributeList;
}

Moduleinst::SmashedEnum Moduleinst::smashedEnumFromString( const QString & v, bool *ok )
{
  if (ok) *ok = true;

  if ( v == "no" ) {
    return Smashed_no;
  } else if ( v == "yes" ) {
    return Smashed_yes;
  } else {
    if (ok) *ok = false;
    return Smashed_Invalid;
  }

  return Smashed_Invalid;
}

QString Moduleinst::smashedEnumToString( const SmashedEnum & v )
{
  switch( v ) {
    case Smashed_no: return "no";
    case Smashed_yes: return "yes";
    case Smashed_Invalid:
    default:
      qCritical() << "Unable to serialize a(n) SmashedEnum enum because it has invalid value" << v;
      return QString();
  }
}

Moduleinst Moduleinst::parseElement( const QDomElement &element, bool *ok )
{
  if ( element.tagName() != "moduleinst" ) {
    qCritical() << "Expected 'moduleinst', got '" << element.tagName() << "'.";
    if ( ok ) *ok = false;
    return Moduleinst();
  }

  Moduleinst result = Moduleinst();

  QDomNode n;
  for( n = element.firstChild(); !n.isNull(); n = n.nextSibling() ) {
    QDomElement e = n.toElement();
    if ( e.tagName() == "attribute" ) {
      bool ok;
      Attribute o = Attribute::parseElement( e, &ok );
      if ( ok ) result.addAttribute( o );
    }
  }

  result.setName( element.attribute( "name" ) );
  result.setModule( element.attribute( "module" ) );
  result.setModulevariant( element.attribute( "modulevariant" ) );
  result.setX( element.attribute( "x" ).toDouble() );
  result.setY( element.attribute( "y" ).toDouble() );
  result.setOffset( element.attribute( "offset" ).toInt() );
  if (element.hasAttribute("smashed"))  {
    SmashedEnum smashed = smashedEnumFromString( element.attribute( "smashed" ), ok  );
    if (ok && *ok == false) {
      qCritical() << "Invalid string: \"" << element.attribute( "smashed" ) << "\" in the \"smashed\" element";
      return Moduleinst();
    } else {
      result.setSmashed( smashed );
    }
  } else {
    result.setSmashed(smashedEnumFromString("no"));
  }
  result.setRot( element.attribute( "rot" ) );

  if ( ok ) *ok = true;
  return result;
}

void Moduleinst::writeElement( QXmlStreamWriter &xml ) const
{
  xml.writeStartElement( "moduleinst" );
      xml.writeAttribute( "name", name() );
      xml.writeAttribute( "module", module() );
      xml.writeAttribute( "modulevariant", modulevariant() );
      xml.writeAttribute( "x", QString::number( x() ) );
      xml.writeAttribute( "y", QString::number( y() ) );
      xml.writeAttribute( "offset", QString::number( offset() ) );
      xml.writeAttribute("smashed", smashedEnumToString( smashed() ));
      xml.writeAttribute( "rot", rot() );
  foreach( Attribute e, attributeList() ) {
    e.writeElement( xml );
  }
  xml.writeEndElement();
}


void Moduleinsts::addModuleinst( const Moduleinst &v )
{
  mModuleinstList.append( v );
}

void Moduleinsts::setModuleinstList( const Moduleinst::List &v )
{
  mModuleinstList = v;
}

Moduleinst::List Moduleinsts::moduleinstList() const
{
  return mModuleinstList;
}

Moduleinsts Moduleinsts::parseElement( const QDomElement &element, bool *ok )
{
  if ( element.tagName() != "moduleinsts" ) {
    qCritical() << "Expected 'moduleinsts', got '" << element.tagName() << "'.";
    if ( ok ) *ok = false;
    return Moduleinsts();
  }

  Moduleinsts result = Moduleinsts();

  QDomNode n;
  for( n = element.firstChild(); !n.isNull(); n = n.nextSibling() ) {
    QDomElement e = n.toElement();
    if ( e.tagName() == "moduleinst" ) {
      bool ok;
      Moduleinst o = Moduleinst::parseElement( e, &ok );
      if ( ok ) result.addModuleinst( o );
    }
  }


  if ( ok ) *ok = true;
  return result;
}

void Moduleinsts::writeElement( QXmlStreamWriter &xml ) const
{
  if ( !moduleinstList().isEmpty() ) {
    xml.writeStartElement( "moduleinsts" );
    foreach( Moduleinst e, moduleinstList() ) {
      e.writeElement( xml );
    }
    xml.writeEndElement();
  }
}


void Sheet::setDescription( const Description &v )
{
  mDescription = v;
}

Description Sheet::description() const
{
  return mDescription;
}

void Sheet::setPlain( const Plain &v )
{
  mPlain = v;
}

Plain Sheet::plain() const
{
  return mPlain;
}

void Sheet::setModuleinsts( const Moduleinsts &v )
{
  mModuleinsts = v;
}

Moduleinsts Sheet::moduleinsts() const
{
  return mModuleinsts;
}

void Sheet::setInstances( const Instances &v )
{
  mInstances = v;
}

Instances Sheet::instances() const
{
  return mInstances;
}

void Sheet::setBusses( const Busses &v )
{
  mBusses = v;
}

Busses Sheet::busses() const
{
  return mBusses;
}

void Sheet::setNets( const Nets &v )
{
  mNets = v;
}

Nets Sheet::nets() const
{
  return mNets;
}

Sheet Sheet::parseElement( const QDomElement &element, bool *ok )
{
  if ( element.tagName() != "sheet" ) {
    qCritical() << "Expected 'sheet', got '" << element.tagName() << "'.";
    if ( ok ) *ok = false;
    return Sheet();
  }

  Sheet result = Sheet();

  QDomNode n;
  for( n = element.firstChild(); !n.isNull(); n = n.nextSibling() ) {
    QDomElement e = n.toElement();
    if ( e.tagName() == "description" ) {
      bool ok;
      Description o = Description::parseElement( e, &ok );
      if ( ok ) result.setDescription( o );
    }
    else if ( e.tagName() == "plain" ) {
      bool ok;
      Plain o = Plain::parseElement( e, &ok );
      if ( ok ) result.setPlain( o );
    }
    else if ( e.tagName() == "moduleinsts" ) {
      bool ok;
      Moduleinsts o = Moduleinsts::parseElement( e, &ok );
      if ( ok ) result.setModuleinsts( o );
    }
    else if ( e.tagName() == "instances" ) {
      bool ok;
      Instances o = Instances::parseElement( e, &ok );
      if ( ok ) result.setInstances( o );
    }
    else if ( e.tagName() == "busses" ) {
      bool ok;
      Busses o = Busses::parseElement( e, &ok );
      if ( ok ) result.setBusses( o );
    }
    else if ( e.tagName() == "nets" ) {
      bool ok;
      Nets o = Nets::parseElement( e, &ok );
      if ( ok ) result.setNets( o );
    }
  }


  if ( ok ) *ok = true;
  return result;
}

void Sheet::writeElement( QXmlStreamWriter &xml ) const
{
  xml.writeStartElement( "sheet" );
  description().writeElement( xml );
  plain().writeElement( xml );
  moduleinsts().writeElement( xml );
  instances().writeElement( xml );
  busses().writeElement( xml );
  nets().writeElement( xml );
  xml.writeEndElement();
}


void Sheets::addSheet( const Sheet &v )
{
  mSheetList.append( v );
}

void Sheets::setSheetList( const Sheet::List &v )
{
  mSheetList = v;
}

Sheet::List Sheets::sheetList() const
{
  return mSheetList;
}

Sheets Sheets::parseElement( const QDomElement &element, bool *ok )
{
  if ( element.tagName() != "sheets" ) {
    qCritical() << "Expected 'sheets', got '" << element.tagName() << "'.";
    if ( ok ) *ok = false;
    return Sheets();
  }

  Sheets result = Sheets();

  QDomNode n;
  for( n = element.firstChild(); !n.isNull(); n = n.nextSibling() ) {
    QDomElement e = n.toElement();
    if ( e.tagName() == "sheet" ) {
      bool ok;
      Sheet o = Sheet::parseElement( e, &ok );
      if ( ok ) result.addSheet( o );
    }
  }


  if ( ok ) *ok = true;
  return result;
}

void Sheets::writeElement( QXmlStreamWriter &xml ) const
{
  if ( !sheetList().isEmpty() ) {
    xml.writeStartElement( "sheets" );
    foreach( Sheet e, sheetList() ) {
      e.writeElement( xml );
    }
    xml.writeEndElement();
  }
}


void Part::setName( const QString &v )
{
  mName = v;
}

QString Part::name() const
{
  return mName;
}

void Part::setLibrary( const QString &v )
{
  mLibrary = v;
}

QString Part::library() const
{
  return mLibrary;
}

void Part::setLibraryUrn( const QString &v )
{
  mLibraryUrn = v;
}

QString Part::libraryUrn() const
{
  return mLibraryUrn;
}

void Part::setDeviceset( const QString &v )
{
  mDeviceset = v;
}

QString Part::deviceset() const
{
  return mDeviceset;
}

void Part::setDevice( const QString &v )
{
  mDevice = v;
}

QString Part::device() const
{
  return mDevice;
}

void Part::setPackage3dUrn( const QString &v )
{
  mPackage3dUrn = v;
}

QString Part::package3dUrn() const
{
  return mPackage3dUrn;
}

void Part::setTechnology( const QString &v )
{
  mTechnology = v;
}

QString Part::technology() const
{
  return mTechnology;
}

void Part::setValue( const QString &v )
{
  mValue = v;
}

QString Part::value() const
{
  return mValue;
}

void Part::addAttribute( const Attribute &v )
{
  mAttributeList.append( v );
}

void Part::setAttributeList( const Attribute::List &v )
{
  mAttributeList = v;
}

Attribute::List Part::attributeList() const
{
  return mAttributeList;
}

void Part::addVariant( const Variant &v )
{
  mVariantList.append( v );
}

void Part::setVariantList( const Variant::List &v )
{
  mVariantList = v;
}

Variant::List Part::variantList() const
{
  return mVariantList;
}

void Part::setSpice( const Spice &v )
{
  mSpice = v;
}

Spice Part::spice() const
{
  return mSpice;
}

Part Part::parseElement( const QDomElement &element, bool *ok )
{
  if ( element.tagName() != "part" ) {
    qCritical() << "Expected 'part', got '" << element.tagName() << "'.";
    if ( ok ) *ok = false;
    return Part();
  }

  Part result = Part();

  QDomNode n;
  for( n = element.firstChild(); !n.isNull(); n = n.nextSibling() ) {
    QDomElement e = n.toElement();
    if ( e.tagName() == "attribute" ) {
      bool ok;
      Attribute o = Attribute::parseElement( e, &ok );
      if ( ok ) result.addAttribute( o );
    }
    else if ( e.tagName() == "variant" ) {
      bool ok;
      Variant o = Variant::parseElement( e, &ok );
      if ( ok ) result.addVariant( o );
    }
    else if ( e.tagName() == "spice" ) {
      bool ok;
      Spice o = Spice::parseElement( e, &ok );
      if ( ok ) result.setSpice( o );
    }
  }

  result.setName( element.attribute( "name" ) );
  result.setLibrary( element.attribute( "library" ) );
  result.setLibraryUrn( element.attribute( "library_urn" ) );
  result.setDeviceset( element.attribute( "deviceset" ) );
  result.setDevice( element.attribute( "device" ) );
  result.setPackage3dUrn( element.attribute( "package3d_urn" ) );
  result.setTechnology( element.attribute( "technology" ) );
  result.setValue( element.attribute( "value" ) );

  if ( ok ) *ok = true;
  return result;
}

void Part::writeElement( QXmlStreamWriter &xml ) const
{
  xml.writeStartElement( "part" );
      xml.writeAttribute( "name", name() );
      xml.writeAttribute( "library", library() );
      xml.writeAttribute( "library_urn", libraryUrn() );
      xml.writeAttribute( "deviceset", deviceset() );
      xml.writeAttribute( "device", device() );
      xml.writeAttribute( "package3d_urn", package3dUrn() );
      xml.writeAttribute( "technology", technology() );
      xml.writeAttribute( "value", value() );
  foreach( Attribute e, attributeList() ) {
    e.writeElement( xml );
  }
  foreach( Variant e, variantList() ) {
    e.writeElement( xml );
  }
  spice().writeElement( xml );
  xml.writeEndElement();
}


void Parts::addPart( const Part &v )
{
  mPartList.append( v );
}

void Parts::setPartList( const Part::List &v )
{
  mPartList = v;
}

Part::List Parts::partList() const
{
  return mPartList;
}

Parts Parts::parseElement( const QDomElement &element, bool *ok )
{
  if ( element.tagName() != "parts" ) {
    qCritical() << "Expected 'parts', got '" << element.tagName() << "'.";
    if ( ok ) *ok = false;
    return Parts();
  }

  Parts result = Parts();

  QDomNode n;
  for( n = element.firstChild(); !n.isNull(); n = n.nextSibling() ) {
    QDomElement e = n.toElement();
    if ( e.tagName() == "part" ) {
      bool ok;
      Part o = Part::parseElement( e, &ok );
      if ( ok ) result.addPart( o );
    }
  }


  if ( ok ) *ok = true;
  return result;
}

void Parts::writeElement( QXmlStreamWriter &xml ) const
{
  if ( !partList().isEmpty() ) {
    xml.writeStartElement( "parts" );
    foreach( Part e, partList() ) {
      e.writeElement( xml );
    }
    xml.writeEndElement();
  }
}


void Port::setName( const QString &v )
{
  mName = v;
}

QString Port::name() const
{
  return mName;
}

void Port::setSide( int v )
{
  mSide = v;
}

int Port::side() const
{
  return mSide;
}

void Port::setCoord( double v )
{
  mCoord = v;
}

double Port::coord() const
{
  return mCoord;
}

void Port::setDirection( const DirectionEnum &v )
{
  mDirection = v;
}

Port::DirectionEnum Port::direction() const
{
  return mDirection;
}

Port::DirectionEnum Port::directionEnumFromString( const QString & v, bool *ok )
{
  if (ok) *ok = true;

  if ( v == "nc" ) {
    return Direction_nc;
  } else if ( v == "in" ) {
    return Direction_in;
  } else if ( v == "out" ) {
    return Direction_out;
  } else if ( v == "io" ) {
    return Direction_io;
  } else if ( v == "oc" ) {
    return Direction_oc;
  } else if ( v == "pwr" ) {
    return Direction_pwr;
  } else if ( v == "pas" ) {
    return Direction_pas;
  } else if ( v == "hiz" ) {
    return Direction_hiz;
  } else if ( v == "sup" ) {
    return Direction_sup;
  } else {
    if (ok) *ok = false;
    return Direction_Invalid;
  }

  return Direction_Invalid;
}

QString Port::directionEnumToString( const DirectionEnum & v )
{
  switch( v ) {
    case Direction_nc: return "nc";
    case Direction_in: return "in";
    case Direction_out: return "out";
    case Direction_io: return "io";
    case Direction_oc: return "oc";
    case Direction_pwr: return "pwr";
    case Direction_pas: return "pas";
    case Direction_hiz: return "hiz";
    case Direction_sup: return "sup";
    case Direction_Invalid:
    default:
      qCritical() << "Unable to serialize a(n) DirectionEnum enum because it has invalid value" << v;
      return QString();
  }
}

Port Port::parseElement( const QDomElement &element, bool *ok )
{
  if ( element.tagName() != "port" ) {
    qCritical() << "Expected 'port', got '" << element.tagName() << "'.";
    if ( ok ) *ok = false;
    return Port();
  }

  Port result = Port();

  result.setName( element.attribute( "name" ) );
  result.setSide( element.attribute( "side" ).toInt() );
  result.setCoord( element.attribute( "coord" ).toDouble() );
  if (element.hasAttribute("direction"))  {
    DirectionEnum direction = directionEnumFromString( element.attribute( "direction" ), ok  );
    if (ok && *ok == false) {
      qCritical() << "Invalid string: \"" << element.attribute( "direction" ) << "\" in the \"direction\" element";
      return Port();
    } else {
      result.setDirection( direction );
    }
  } else {
    result.setDirection(directionEnumFromString("io"));
  }

  if ( ok ) *ok = true;
  return result;
}

void Port::writeElement( QXmlStreamWriter &xml ) const
{
  xml.writeEmptyElement( "port" );
}


void Ports::addPort( const Port &v )
{
  mPortList.append( v );
}

void Ports::setPortList( const Port::List &v )
{
  mPortList = v;
}

Port::List Ports::portList() const
{
  return mPortList;
}

Ports Ports::parseElement( const QDomElement &element, bool *ok )
{
  if ( element.tagName() != "ports" ) {
    qCritical() << "Expected 'ports', got '" << element.tagName() << "'.";
    if ( ok ) *ok = false;
    return Ports();
  }

  Ports result = Ports();

  QDomNode n;
  for( n = element.firstChild(); !n.isNull(); n = n.nextSibling() ) {
    QDomElement e = n.toElement();
    if ( e.tagName() == "port" ) {
      bool ok;
      Port o = Port::parseElement( e, &ok );
      if ( ok ) result.addPort( o );
    }
  }


  if ( ok ) *ok = true;
  return result;
}

void Ports::writeElement( QXmlStreamWriter &xml ) const
{
  if ( !portList().isEmpty() ) {
    xml.writeStartElement( "ports" );
    foreach( Port e, portList() ) {
      e.writeElement( xml );
    }
    xml.writeEndElement();
  }
}


void Module::setName( const QString &v )
{
  mName = v;
}

QString Module::name() const
{
  return mName;
}

void Module::setPrefix( const QString &v )
{
  mPrefix = v;
}

QString Module::prefix() const
{
  return mPrefix;
}

void Module::setDx( double v )
{
  mDx = v;
}

double Module::dx() const
{
  return mDx;
}

void Module::setDy( double v )
{
  mDy = v;
}

double Module::dy() const
{
  return mDy;
}

void Module::setDescription( const Description &v )
{
  mDescription = v;
}

Description Module::description() const
{
  return mDescription;
}

void Module::setPorts( const Ports &v )
{
  mPorts = v;
}

Ports Module::ports() const
{
  return mPorts;
}

void Module::setVariantdefs( const Variantdefs &v )
{
  mVariantdefs = v;
}

Variantdefs Module::variantdefs() const
{
  return mVariantdefs;
}

void Module::setParts( const Parts &v )
{
  mParts = v;
}

Parts Module::parts() const
{
  return mParts;
}

void Module::setSheets( const Sheets &v )
{
  mSheets = v;
}

Sheets Module::sheets() const
{
  return mSheets;
}

Module Module::parseElement( const QDomElement &element, bool *ok )
{
  if ( element.tagName() != "module" ) {
    qCritical() << "Expected 'module', got '" << element.tagName() << "'.";
    if ( ok ) *ok = false;
    return Module();
  }

  Module result = Module();

  QDomNode n;
  for( n = element.firstChild(); !n.isNull(); n = n.nextSibling() ) {
    QDomElement e = n.toElement();
    if ( e.tagName() == "description" ) {
      bool ok;
      Description o = Description::parseElement( e, &ok );
      if ( ok ) result.setDescription( o );
    }
    else if ( e.tagName() == "ports" ) {
      bool ok;
      Ports o = Ports::parseElement( e, &ok );
      if ( ok ) result.setPorts( o );
    }
    else if ( e.tagName() == "variantdefs" ) {
      bool ok;
      Variantdefs o = Variantdefs::parseElement( e, &ok );
      if ( ok ) result.setVariantdefs( o );
    }
    else if ( e.tagName() == "parts" ) {
      bool ok;
      Parts o = Parts::parseElement( e, &ok );
      if ( ok ) result.setParts( o );
    }
    else if ( e.tagName() == "sheets" ) {
      bool ok;
      Sheets o = Sheets::parseElement( e, &ok );
      if ( ok ) result.setSheets( o );
    }
  }

  result.setName( element.attribute( "name" ) );
  result.setPrefix( element.attribute( "prefix" ) );
  result.setDx( element.attribute( "dx" ).toDouble() );
  result.setDy( element.attribute( "dy" ).toDouble() );

  if ( ok ) *ok = true;
  return result;
}

void Module::writeElement( QXmlStreamWriter &xml ) const
{
  xml.writeStartElement( "module" );
      xml.writeAttribute( "name", name() );
      xml.writeAttribute( "prefix", prefix() );
      xml.writeAttribute( "dx", QString::number( dx() ) );
      xml.writeAttribute( "dy", QString::number( dy() ) );
  description().writeElement( xml );
  ports().writeElement( xml );
  variantdefs().writeElement( xml );
  parts().writeElement( xml );
  sheets().writeElement( xml );
  xml.writeEndElement();
}


void Modules::addModule( const Module &v )
{
  mModuleList.append( v );
}

void Modules::setModuleList( const Module::List &v )
{
  mModuleList = v;
}

Module::List Modules::moduleList() const
{
  return mModuleList;
}

Modules Modules::parseElement( const QDomElement &element, bool *ok )
{
  if ( element.tagName() != "modules" ) {
    qCritical() << "Expected 'modules', got '" << element.tagName() << "'.";
    if ( ok ) *ok = false;
    return Modules();
  }

  Modules result = Modules();

  QDomNode n;
  for( n = element.firstChild(); !n.isNull(); n = n.nextSibling() ) {
    QDomElement e = n.toElement();
    if ( e.tagName() == "module" ) {
      bool ok;
      Module o = Module::parseElement( e, &ok );
      if ( ok ) result.addModule( o );
    }
  }


  if ( ok ) *ok = true;
  return result;
}

void Modules::writeElement( QXmlStreamWriter &xml ) const
{
  if ( !moduleList().isEmpty() ) {
    xml.writeStartElement( "modules" );
    foreach( Module e, moduleList() ) {
      e.writeElement( xml );
    }
    xml.writeEndElement();
  }
}


void Schematic::setXreflabel( const QString &v )
{
  mXreflabel = v;
}

QString Schematic::xreflabel() const
{
  return mXreflabel;
}

void Schematic::setXrefpart( const QString &v )
{
  mXrefpart = v;
}

QString Schematic::xrefpart() const
{
  return mXrefpart;
}

void Schematic::setDescription( const Description &v )
{
  mDescription = v;
}

Description Schematic::description() const
{
  return mDescription;
}

void Schematic::setLibraries( const Libraries &v )
{
  mLibraries = v;
}

Libraries Schematic::libraries() const
{
  return mLibraries;
}

void Schematic::setAttributes( const Attributes &v )
{
  mAttributes = v;
}

Attributes Schematic::attributes() const
{
  return mAttributes;
}

void Schematic::setVariantdefs( const Variantdefs &v )
{
  mVariantdefs = v;
}

Variantdefs Schematic::variantdefs() const
{
  return mVariantdefs;
}

void Schematic::setClasses( const Classes &v )
{
  mClasses = v;
}

Classes Schematic::classes() const
{
  return mClasses;
}

void Schematic::setModules( const Modules &v )
{
  mModules = v;
}

Modules Schematic::modules() const
{
  return mModules;
}

void Schematic::setParts( const Parts &v )
{
  mParts = v;
}

Parts Schematic::parts() const
{
  return mParts;
}

void Schematic::setSheets( const Sheets &v )
{
  mSheets = v;
}

Sheets Schematic::sheets() const
{
  return mSheets;
}

void Schematic::setErrors( const Errors &v )
{
  mErrors = v;
}

Errors Schematic::errors() const
{
  return mErrors;
}

Schematic Schematic::parseElement( const QDomElement &element, bool *ok )
{
  if ( element.tagName() != "schematic" ) {
    qCritical() << "Expected 'schematic', got '" << element.tagName() << "'.";
    if ( ok ) *ok = false;
    return Schematic();
  }

  Schematic result = Schematic();

  QDomNode n;
  for( n = element.firstChild(); !n.isNull(); n = n.nextSibling() ) {
    QDomElement e = n.toElement();
    if ( e.tagName() == "description" ) {
      bool ok;
      Description o = Description::parseElement( e, &ok );
      if ( ok ) result.setDescription( o );
    }
    else if ( e.tagName() == "libraries" ) {
      bool ok;
      Libraries o = Libraries::parseElement( e, &ok );
      if ( ok ) result.setLibraries( o );
    }
    else if ( e.tagName() == "attributes" ) {
      bool ok;
      Attributes o = Attributes::parseElement( e, &ok );
      if ( ok ) result.setAttributes( o );
    }
    else if ( e.tagName() == "variantdefs" ) {
      bool ok;
      Variantdefs o = Variantdefs::parseElement( e, &ok );
      if ( ok ) result.setVariantdefs( o );
    }
    else if ( e.tagName() == "classes" ) {
      bool ok;
      Classes o = Classes::parseElement( e, &ok );
      if ( ok ) result.setClasses( o );
    }
    else if ( e.tagName() == "modules" ) {
      bool ok;
      Modules o = Modules::parseElement( e, &ok );
      if ( ok ) result.setModules( o );
    }
    else if ( e.tagName() == "parts" ) {
      bool ok;
      Parts o = Parts::parseElement( e, &ok );
      if ( ok ) result.setParts( o );
    }
    else if ( e.tagName() == "sheets" ) {
      bool ok;
      Sheets o = Sheets::parseElement( e, &ok );
      if ( ok ) result.setSheets( o );
    }
    else if ( e.tagName() == "errors" ) {
      bool ok;
      Errors o = Errors::parseElement( e, &ok );
      if ( ok ) result.setErrors( o );
    }
  }

  result.setXreflabel( element.attribute( "xreflabel" ) );
  result.setXrefpart( element.attribute( "xrefpart" ) );

  if ( ok ) *ok = true;
  return result;
}

void Schematic::writeElement( QXmlStreamWriter &xml ) const
{
  xml.writeStartElement( "schematic" );
      xml.writeAttribute( "xreflabel", xreflabel() );
      xml.writeAttribute( "xrefpart", xrefpart() );
  description().writeElement( xml );
  libraries().writeElement( xml );
  attributes().writeElement( xml );
  variantdefs().writeElement( xml );
  classes().writeElement( xml );
  modules().writeElement( xml );
  parts().writeElement( xml );
  sheets().writeElement( xml );
  errors().writeElement( xml );
  xml.writeEndElement();
}


void Drawing::setLibrary( const Library &v )
{
  mLibrary = v;
}

Library Drawing::library() const
{
  return mLibrary;
}

void Drawing::setSchematic( const Schematic &v )
{
  mSchematic = v;
}

Schematic Drawing::schematic() const
{
  return mSchematic;
}

void Drawing::setBoard( const Board &v )
{
  mBoard = v;
}

Board Drawing::board() const
{
  return mBoard;
}

void Drawing::setSettings( const Settings &v )
{
  mSettings = v;
}

Settings Drawing::settings() const
{
  return mSettings;
}

void Drawing::setGrid( const Grid &v )
{
  mGrid = v;
}

Grid Drawing::grid() const
{
  return mGrid;
}

void Drawing::setLayers( const Layers &v )
{
  mLayers = v;
}

Layers Drawing::layers() const
{
  return mLayers;
}

Drawing Drawing::parseElement( const QDomElement &element, bool *ok )
{
  if ( element.tagName() != "drawing" ) {
    qCritical() << "Expected 'drawing', got '" << element.tagName() << "'.";
    if ( ok ) *ok = false;
    return Drawing();
  }

  Drawing result = Drawing();

  QDomNode n;
  for( n = element.firstChild(); !n.isNull(); n = n.nextSibling() ) {
    QDomElement e = n.toElement();
    if ( e.tagName() == "library" ) {
      bool ok;
      Library o = Library::parseElement( e, &ok );
      if ( ok ) result.setLibrary( o );
    }
    else if ( e.tagName() == "schematic" ) {
      bool ok;
      Schematic o = Schematic::parseElement( e, &ok );
      if ( ok ) result.setSchematic( o );
    }
    else if ( e.tagName() == "board" ) {
      bool ok;
      Board o = Board::parseElement( e, &ok );
      if ( ok ) result.setBoard( o );
    }
    else if ( e.tagName() == "settings" ) {
      bool ok;
      Settings o = Settings::parseElement( e, &ok );
      if ( ok ) result.setSettings( o );
    }
    else if ( e.tagName() == "grid" ) {
      bool ok;
      Grid o = Grid::parseElement( e, &ok );
      if ( ok ) result.setGrid( o );
    }
    else if ( e.tagName() == "layers" ) {
      bool ok;
      Layers o = Layers::parseElement( e, &ok );
      if ( ok ) result.setLayers( o );
    }
  }


  if ( ok ) *ok = true;
  return result;
}

void Drawing::writeElement( QXmlStreamWriter &xml ) const
{
  xml.writeStartElement( "drawing" );
  library().writeElement( xml );
  schematic().writeElement( xml );
  board().writeElement( xml );
  settings().writeElement( xml );
  grid().writeElement( xml );
  layers().writeElement( xml );
  xml.writeEndElement();
}


void Note::setVersion( double v )
{
  mVersion = v;
}

double Note::version() const
{
  return mVersion;
}

void Note::setSeverity( const SeverityEnum &v )
{
  mSeverity = v;
}

Note::SeverityEnum Note::severity() const
{
  return mSeverity;
}

void Note::setValue( const QString &v )
{
  mValue = v;
}

QString Note::value() const
{
  return mValue;
}

Note::SeverityEnum Note::severityEnumFromString( const QString & v, bool *ok )
{
  if (ok) *ok = true;

  if ( v == "info" ) {
    return Severity_info;
  } else if ( v == "warning" ) {
    return Severity_warning;
  } else if ( v == "error" ) {
    return Severity_error;
  } else {
    if (ok) *ok = false;
    return Severity_Invalid;
  }

  return Severity_Invalid;
}

QString Note::severityEnumToString( const SeverityEnum & v )
{
  switch( v ) {
    case Severity_info: return "info";
    case Severity_warning: return "warning";
    case Severity_error: return "error";
    case Severity_Invalid:
    default:
      qCritical() << "Unable to serialize a(n) SeverityEnum enum because it has invalid value" << v;
      return QString();
  }
}

Note Note::parseElement( const QDomElement &element, bool *ok )
{
  if ( element.tagName() != "note" ) {
    qCritical() << "Expected 'note', got '" << element.tagName() << "'.";
    if ( ok ) *ok = false;
    return Note();
  }

  Note result = Note();

  result.setValue( element.text() );
  result.setVersion( element.attribute( "version" ).toDouble() );
  SeverityEnum severity = severityEnumFromString( element.attribute( "severity" ), ok  );
  if (ok && *ok == false) {
    qCritical() << "Invalid string: \"" << element.attribute( "severity" ) << "\" in the \"severity\" element";
    return Note();
  } else {
    result.setSeverity( severity );
  }

  if ( ok ) *ok = true;
  return result;
}

void Note::writeElement( QXmlStreamWriter &xml ) const
{
  if ( !value().isEmpty() ) {
    xml.writeStartElement( "note" );
      xml.writeAttribute( "version", QString::number( version() ) );
      xml.writeAttribute("severity", severityEnumToString( severity() ));
    xml.writeCharacters( value() );
    xml.writeEndElement();
  }
}


void Compatibility::addNote( const Note &v )
{
  mNoteList.append( v );
}

void Compatibility::setNoteList( const Note::List &v )
{
  mNoteList = v;
}

Note::List Compatibility::noteList() const
{
  return mNoteList;
}

Compatibility Compatibility::parseElement( const QDomElement &element, bool *ok )
{
  if ( element.tagName() != "compatibility" ) {
    qCritical() << "Expected 'compatibility', got '" << element.tagName() << "'.";
    if ( ok ) *ok = false;
    return Compatibility();
  }

  Compatibility result = Compatibility();

  QDomNode n;
  for( n = element.firstChild(); !n.isNull(); n = n.nextSibling() ) {
    QDomElement e = n.toElement();
    if ( e.tagName() == "note" ) {
      bool ok;
      Note o = Note::parseElement( e, &ok );
      if ( ok ) result.addNote( o );
    }
  }


  if ( ok ) *ok = true;
  return result;
}

void Compatibility::writeElement( QXmlStreamWriter &xml ) const
{
  if ( !noteList().isEmpty() ) {
    xml.writeStartElement( "compatibility" );
    foreach( Note e, noteList() ) {
      e.writeElement( xml );
    }
    xml.writeEndElement();
  }
}


void Eagle::setVersion( double v )
{
  mVersion = v;
}

double Eagle::version() const
{
  return mVersion;
}

void Eagle::setCompatibility( const Compatibility &v )
{
  mCompatibility = v;
}

Compatibility Eagle::compatibility() const
{
  return mCompatibility;
}

void Eagle::setDrawing( const Drawing &v )
{
  mDrawing = v;
}

Drawing Eagle::drawing() const
{
  return mDrawing;
}

Eagle Eagle::parseElement( const QDomElement &element, bool *ok )
{
  if ( element.tagName() != "eagle" ) {
    qCritical() << "Expected 'eagle', got '" << element.tagName() << "'.";
    if ( ok ) *ok = false;
    return Eagle();
  }

  Eagle result = Eagle();

  QDomNode n;
  for( n = element.firstChild(); !n.isNull(); n = n.nextSibling() ) {
    QDomElement e = n.toElement();
    if ( e.tagName() == "compatibility" ) {
      bool ok;
      Compatibility o = Compatibility::parseElement( e, &ok );
      if ( ok ) result.setCompatibility( o );
    }
    else if ( e.tagName() == "drawing" ) {
      bool ok;
      Drawing o = Drawing::parseElement( e, &ok );
      if ( ok ) result.setDrawing( o );
    }
  }

  result.setVersion( element.attribute( "version" ).toDouble() );

  if ( ok ) *ok = true;
  return result;
}

void Eagle::writeElement( QXmlStreamWriter &xml ) const
{
  xml.writeStartElement( "eagle" );
      xml.writeAttribute( "version", QString::number( version() ) );
  compatibility().writeElement( xml );
  drawing().writeElement( xml );
  xml.writeEndElement();
}

Eagle Eagle::parseFile( const QString &filename, bool *ok )
{
  QFile file( filename );
  if ( !file.open( QIODevice::ReadOnly ) ) {
    qCritical() << "Unable to open file '" << filename << "'";
    if ( ok ) *ok = false;
    return Eagle();
  }

  QString errorMsg;
  int errorLine, errorCol;
  QDomDocument doc;
  if ( !doc.setContent( &file, false, &errorMsg, &errorLine, &errorCol ) ) {
    qCritical() << errorMsg << " at " << errorLine << "," << errorCol;
    if ( ok ) *ok = false;
    return Eagle();
  }

  bool documentOk;
  Eagle c = parseElement( doc.documentElement(), &documentOk );
  if ( ok ) {
    *ok = documentOk;
  }
  return c;
}

Eagle Eagle::parseString( const QString &xml, bool *ok )
{
  QString errorMsg;
  int errorLine, errorCol;
  QDomDocument doc;
  if ( !doc.setContent( xml, false, &errorMsg, &errorLine, &errorCol ) ) {
    qCritical() << errorMsg << " at " << errorLine << "," << errorCol;
    if ( ok ) *ok = false;
    return Eagle();
  }

  bool documentOk;
  Eagle c = parseElement( doc.documentElement(), &documentOk );
  if ( ok ) {
    *ok = documentOk;
  }
  return c;
}

bool Eagle::writeFile( const QString &filename ) const
{
  QFile file( filename );
  if ( !file.open( QIODevice::WriteOnly ) ) {
    qCritical() << "Unable to open file '" << filename << "'";
    return false;
  }

  QXmlStreamWriter xml( &file );
  xml.setAutoFormatting( true );
  xml.setAutoFormattingIndent( 2 );
  xml.writeStartDocument( "1.0" );
  writeElement( xml );
  xml.writeEndDocument();
  file.close();

  return true;
}


