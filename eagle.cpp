// This file is generated by kxml_compiler from /home/mm/Projektek/eagle_power_tools/qt_eagle_xml_parser/tools/eagle.xsd.
// All changes you do to this file will be lost.

#include "eagle.h"

#include <QtDebug>
#include <QFile>
#include <QDomDocument>

Layer::Layer()
  : mNumber(0), mNumber_set(false), mColor(0), mColor_set(false), mFill(0), mFill_set(false), mVisible(Visible_Invalid), mActive(Active_Invalid)
{
}

Layer::~Layer()
{
}

void Layer::setNumber( const int v )
{
  mNumber_set = true;
  mNumber = v;
}

int Layer::number() const
{
  return mNumber;
}

bool Layer::numberSet() const
{
  return mNumber_set;
}

void Layer::setName( const QString &v )
{
  mName = v;
}

QString Layer::name() const
{
  return mName;
}

void Layer::setColor( const int v )
{
  mColor_set = true;
  mColor = v;
}

int Layer::color() const
{
  return mColor;
}

bool Layer::colorSet() const
{
  return mColor_set;
}

void Layer::setFill( const int v )
{
  mFill_set = true;
  mFill = v;
}

int Layer::fill() const
{
  return mFill;
}

bool Layer::fillSet() const
{
  return mFill_set;
}

void Layer::setVisible( const VisibleEnum &v )
{
  mVisible = v;
}

Layer::VisibleEnum Layer::visible() const
{
  return mVisible;
}

void Layer::setActive( const ActiveEnum &v )
{
  mActive = v;
}

Layer::ActiveEnum Layer::active() const
{
  return mActive;
}

Layer::VisibleEnum Layer::visibleEnumFromString( const QString & v, bool *ok )
{
  if (ok) *ok = true;

  if ( v == "no" ) {
    return Visible_no;
  } else if ( v == "yes" ) {
    return Visible_yes;
  } else {
    if (ok) *ok = false;
    return Visible_Invalid;
  }

  return Visible_Invalid;
}

QString Layer::visibleEnumToString( const VisibleEnum & v )
{
  switch( v ) {
  case Visible_no: return "no";
  case Visible_yes: return "yes";
  case Visible_Invalid:
  default:
    qCritical() << "Unable to serialize a(n) VisibleEnum enum because it has invalid value:" << v;
    return QString();
  }
}

Layer::ActiveEnum Layer::activeEnumFromString( const QString & v, bool *ok )
{
  if (ok) *ok = true;

  if ( v == "no" ) {
    return Active_no;
  } else if ( v == "yes" ) {
    return Active_yes;
  } else {
    if (ok) *ok = false;
    return Active_Invalid;
  }

  return Active_Invalid;
}

QString Layer::activeEnumToString( const ActiveEnum & v )
{
  switch( v ) {
  case Active_no: return "no";
  case Active_yes: return "yes";
  case Active_Invalid:
  default:
    qCritical() << "Unable to serialize a(n) ActiveEnum enum because it has invalid value:" << v;
    return QString();
  }
}

Layer *Layer::parseElement( const QDomElement &element, bool *ok )
{
  if ( element.tagName() != "layer" ) {
    qCritical() << "Expected 'layer', got '" << element.tagName() << "'.";
    if ( ok ) *ok = false;
    return nullptr;
  }

  Layer* result = new Layer();

  if (element.hasAttribute("number"))
    result->setNumber( element.attribute( "number" ).toInt() );
  result->setName( element.attribute( "name" ) );
  if (element.hasAttribute("color"))
    result->setColor( element.attribute( "color" ).toInt() );
  if (element.hasAttribute("fill"))
    result->setFill( element.attribute( "fill" ).toInt() );
  if (element.hasAttribute("visible"))  {
    VisibleEnum visible = visibleEnumFromString( element.attribute( "visible" ), ok  );
    if (ok && !(*ok)) {
      qCritical() << "Invalid string: \"" << element.attribute( "visible" ) << "\" in the \"visible\" element";
      return nullptr;
    } else {
      result->setVisible( visible );
    }
  } else {
    // default value
    result->setVisible(Visible_yes);
  }
  if (element.hasAttribute("active"))  {
    ActiveEnum active = activeEnumFromString( element.attribute( "active" ), ok  );
    if (ok && !(*ok)) {
      qCritical() << "Invalid string: \"" << element.attribute( "active" ) << "\" in the \"active\" element";
      return nullptr;
    } else {
      result->setActive( active );
    }
  } else {
    // default value
    result->setActive(Active_yes);
  }

  if ( ok ) *ok = true;
  return result;
}

void Layer::writeElement( QXmlStreamWriter &xml ) const
{
  xml.writeStartElement( "layer" );
  if (mNumber_set)
    xml.writeAttribute("number", QString::number( mNumber ) );
  if (!mName.isEmpty())
    xml.writeAttribute("name", mName );
  if (mColor_set)
    xml.writeAttribute("color", QString::number( mColor ) );
  if (mFill_set)
    xml.writeAttribute("fill", QString::number( mFill ) );
  if (mVisible != Visible_Invalid)
    xml.writeAttribute("visible", visibleEnumToString(mVisible));
  if (mActive != Active_Invalid)
    xml.writeAttribute("active", activeEnumToString(mActive));
  xml.writeEndElement();
}


Layers::Layers()
{
}

Layers::~Layers()
{
}

void Layers::addLayer( Layer* v )
{
  mLayerList.append( v );
}

void Layers::setLayerList( const Layer::List &v )
{
  mLayerList = v;
}

Layer::List *Layers::layerList()
{
  return &mLayerList;
}

Layers *Layers::parseElement( const QDomElement &element, bool *ok )
{
  if ( element.tagName() != "layers" ) {
    qCritical() << "Expected 'layers', got '" << element.tagName() << "'.";
    if ( ok ) *ok = false;
    return nullptr;
  }

  Layers* result = new Layers();

  QDomNode n;
  for( n = element.firstChild(); !n.isNull(); n = n.nextSibling() ) {
    QDomElement e = n.toElement();
    if ( e.tagName() == "layer" ) {
      bool ok;
      Layer *o = Layer::parseElement( e, &ok );
      if ( ok ) result->addLayer( o );
    }
  }


  if ( ok ) *ok = true;
  return result;
}

void Layers::writeElement( QXmlStreamWriter &xml ) const
{
  if ( !mLayerList.isEmpty() ) {
    xml.writeStartElement( "layers" );
    foreach( Layer* e, mLayerList ) {
      if (e)
        e->writeElement( xml );
    }
    xml.writeEndElement();
  }
}


Grid::Grid()
  : mDistance(0.0), mDistance_set(false), mUnitdist(Unitdist_Invalid), mUnit(Unit_Invalid), mStyle(Style_Invalid), mMultiple(0), mMultiple_set(false), mDisplay(Display_Invalid), mAltdistance(0.0), mAltdistance_set(false), mAltunitdist(Altunitdist_Invalid), mAltunit(Altunit_Invalid)
{
}

Grid::~Grid()
{
}

void Grid::setDistance( const double v )
{
  mDistance_set = true;
  mDistance = v;
}

double Grid::distance() const
{
  return mDistance;
}

bool Grid::distanceSet() const
{
  return mDistance_set;
}

void Grid::setUnitdist( const UnitdistEnum &v )
{
  mUnitdist = v;
}

Grid::UnitdistEnum Grid::unitdist() const
{
  return mUnitdist;
}

void Grid::setUnit( const UnitEnum &v )
{
  mUnit = v;
}

Grid::UnitEnum Grid::unit() const
{
  return mUnit;
}

void Grid::setStyle( const StyleEnum &v )
{
  mStyle = v;
}

Grid::StyleEnum Grid::style() const
{
  return mStyle;
}

void Grid::setMultiple( const int v )
{
  mMultiple_set = true;
  mMultiple = v;
}

int Grid::multiple() const
{
  return mMultiple;
}

bool Grid::multipleSet() const
{
  return mMultiple_set;
}

void Grid::setDisplay( const DisplayEnum &v )
{
  mDisplay = v;
}

Grid::DisplayEnum Grid::display() const
{
  return mDisplay;
}

void Grid::setAltdistance( const double v )
{
  mAltdistance_set = true;
  mAltdistance = v;
}

double Grid::altdistance() const
{
  return mAltdistance;
}

bool Grid::altdistanceSet() const
{
  return mAltdistance_set;
}

void Grid::setAltunitdist( const AltunitdistEnum &v )
{
  mAltunitdist = v;
}

Grid::AltunitdistEnum Grid::altunitdist() const
{
  return mAltunitdist;
}

void Grid::setAltunit( const AltunitEnum &v )
{
  mAltunit = v;
}

Grid::AltunitEnum Grid::altunit() const
{
  return mAltunit;
}

Grid::UnitdistEnum Grid::unitdistEnumFromString( const QString & v, bool *ok )
{
  if (ok) *ok = true;

  if ( v == "mic" ) {
    return Unitdist_mic;
  } else if ( v == "mm" ) {
    return Unitdist_mm;
  } else if ( v == "mil" ) {
    return Unitdist_mil;
  } else if ( v == "inch" ) {
    return Unitdist_inch;
  } else {
    if (ok) *ok = false;
    return Unitdist_Invalid;
  }

  return Unitdist_Invalid;
}

QString Grid::unitdistEnumToString( const UnitdistEnum & v )
{
  switch( v ) {
  case Unitdist_mic: return "mic";
  case Unitdist_mm: return "mm";
  case Unitdist_mil: return "mil";
  case Unitdist_inch: return "inch";
  case Unitdist_Invalid:
  default:
    qCritical() << "Unable to serialize a(n) UnitdistEnum enum because it has invalid value:" << v;
    return QString();
  }
}

Grid::UnitEnum Grid::unitEnumFromString( const QString & v, bool *ok )
{
  if (ok) *ok = true;

  if ( v == "mic" ) {
    return Unit_mic;
  } else if ( v == "mm" ) {
    return Unit_mm;
  } else if ( v == "mil" ) {
    return Unit_mil;
  } else if ( v == "inch" ) {
    return Unit_inch;
  } else {
    if (ok) *ok = false;
    return Unit_Invalid;
  }

  return Unit_Invalid;
}

QString Grid::unitEnumToString( const UnitEnum & v )
{
  switch( v ) {
  case Unit_mic: return "mic";
  case Unit_mm: return "mm";
  case Unit_mil: return "mil";
  case Unit_inch: return "inch";
  case Unit_Invalid:
  default:
    qCritical() << "Unable to serialize a(n) UnitEnum enum because it has invalid value:" << v;
    return QString();
  }
}

Grid::StyleEnum Grid::styleEnumFromString( const QString & v, bool *ok )
{
  if (ok) *ok = true;

  if ( v == "lines" ) {
    return Style_lines;
  } else if ( v == "dots" ) {
    return Style_dots;
  } else {
    if (ok) *ok = false;
    return Style_Invalid;
  }

  return Style_Invalid;
}

QString Grid::styleEnumToString( const StyleEnum & v )
{
  switch( v ) {
  case Style_lines: return "lines";
  case Style_dots: return "dots";
  case Style_Invalid:
  default:
    qCritical() << "Unable to serialize a(n) StyleEnum enum because it has invalid value:" << v;
    return QString();
  }
}

Grid::DisplayEnum Grid::displayEnumFromString( const QString & v, bool *ok )
{
  if (ok) *ok = true;

  if ( v == "no" ) {
    return Display_no;
  } else if ( v == "yes" ) {
    return Display_yes;
  } else {
    if (ok) *ok = false;
    return Display_Invalid;
  }

  return Display_Invalid;
}

QString Grid::displayEnumToString( const DisplayEnum & v )
{
  switch( v ) {
  case Display_no: return "no";
  case Display_yes: return "yes";
  case Display_Invalid:
  default:
    qCritical() << "Unable to serialize a(n) DisplayEnum enum because it has invalid value:" << v;
    return QString();
  }
}

Grid::AltunitdistEnum Grid::altunitdistEnumFromString( const QString & v, bool *ok )
{
  if (ok) *ok = true;

  if ( v == "mic" ) {
    return Altunitdist_mic;
  } else if ( v == "mm" ) {
    return Altunitdist_mm;
  } else if ( v == "mil" ) {
    return Altunitdist_mil;
  } else if ( v == "inch" ) {
    return Altunitdist_inch;
  } else {
    if (ok) *ok = false;
    return Altunitdist_Invalid;
  }

  return Altunitdist_Invalid;
}

QString Grid::altunitdistEnumToString( const AltunitdistEnum & v )
{
  switch( v ) {
  case Altunitdist_mic: return "mic";
  case Altunitdist_mm: return "mm";
  case Altunitdist_mil: return "mil";
  case Altunitdist_inch: return "inch";
  case Altunitdist_Invalid:
  default:
    qCritical() << "Unable to serialize a(n) AltunitdistEnum enum because it has invalid value:" << v;
    return QString();
  }
}

Grid::AltunitEnum Grid::altunitEnumFromString( const QString & v, bool *ok )
{
  if (ok) *ok = true;

  if ( v == "mic" ) {
    return Altunit_mic;
  } else if ( v == "mm" ) {
    return Altunit_mm;
  } else if ( v == "mil" ) {
    return Altunit_mil;
  } else if ( v == "inch" ) {
    return Altunit_inch;
  } else {
    if (ok) *ok = false;
    return Altunit_Invalid;
  }

  return Altunit_Invalid;
}

QString Grid::altunitEnumToString( const AltunitEnum & v )
{
  switch( v ) {
  case Altunit_mic: return "mic";
  case Altunit_mm: return "mm";
  case Altunit_mil: return "mil";
  case Altunit_inch: return "inch";
  case Altunit_Invalid:
  default:
    qCritical() << "Unable to serialize a(n) AltunitEnum enum because it has invalid value:" << v;
    return QString();
  }
}

Grid *Grid::parseElement( const QDomElement &element, bool *ok )
{
  if ( element.tagName() != "grid" ) {
    qCritical() << "Expected 'grid', got '" << element.tagName() << "'.";
    if ( ok ) *ok = false;
    return nullptr;
  }

  Grid* result = new Grid();

  if (element.hasAttribute("distance"))
    result->setDistance( element.attribute( "distance" ).toDouble() );
  if (element.hasAttribute("unitdist"))  {
    UnitdistEnum unitdist = unitdistEnumFromString( element.attribute( "unitdist" ), ok  );
    if (ok && !(*ok)) {
      qCritical() << "Invalid string: \"" << element.attribute( "unitdist" ) << "\" in the \"unitdist\" element";
      return nullptr;
    } else {
      result->setUnitdist( unitdist );
    }
  } else {
    result->setUnitdist(Unitdist_Invalid);
  }
  if (element.hasAttribute("unit"))  {
    UnitEnum unit = unitEnumFromString( element.attribute( "unit" ), ok  );
    if (ok && !(*ok)) {
      qCritical() << "Invalid string: \"" << element.attribute( "unit" ) << "\" in the \"unit\" element";
      return nullptr;
    } else {
      result->setUnit( unit );
    }
  } else {
    result->setUnit(Unit_Invalid);
  }
  if (element.hasAttribute("style"))  {
    StyleEnum style = styleEnumFromString( element.attribute( "style" ), ok  );
    if (ok && !(*ok)) {
      qCritical() << "Invalid string: \"" << element.attribute( "style" ) << "\" in the \"style\" element";
      return nullptr;
    } else {
      result->setStyle( style );
    }
  } else {
    // default value
    result->setStyle(Style_lines);
  }
  if (element.hasAttribute("multiple"))
    result->setMultiple( element.attribute( "multiple" ).toInt() );
  if (element.hasAttribute("display"))  {
    DisplayEnum display = displayEnumFromString( element.attribute( "display" ), ok  );
    if (ok && !(*ok)) {
      qCritical() << "Invalid string: \"" << element.attribute( "display" ) << "\" in the \"display\" element";
      return nullptr;
    } else {
      result->setDisplay( display );
    }
  } else {
    // default value
    result->setDisplay(Display_no);
  }
  if (element.hasAttribute("altdistance"))
    result->setAltdistance( element.attribute( "altdistance" ).toDouble() );
  if (element.hasAttribute("altunitdist"))  {
    AltunitdistEnum altunitdist = altunitdistEnumFromString( element.attribute( "altunitdist" ), ok  );
    if (ok && !(*ok)) {
      qCritical() << "Invalid string: \"" << element.attribute( "altunitdist" ) << "\" in the \"altunitdist\" element";
      return nullptr;
    } else {
      result->setAltunitdist( altunitdist );
    }
  } else {
    result->setAltunitdist(Altunitdist_Invalid);
  }
  if (element.hasAttribute("altunit"))  {
    AltunitEnum altunit = altunitEnumFromString( element.attribute( "altunit" ), ok  );
    if (ok && !(*ok)) {
      qCritical() << "Invalid string: \"" << element.attribute( "altunit" ) << "\" in the \"altunit\" element";
      return nullptr;
    } else {
      result->setAltunit( altunit );
    }
  } else {
    result->setAltunit(Altunit_Invalid);
  }

  if ( ok ) *ok = true;
  return result;
}

void Grid::writeElement( QXmlStreamWriter &xml ) const
{
  xml.writeStartElement( "grid" );
  if (mDistance_set)
    xml.writeAttribute("distance", QString::number( mDistance ) );
  if (mUnitdist != Unitdist_Invalid)
    xml.writeAttribute("unitdist", unitdistEnumToString(mUnitdist));
  if (mUnit != Unit_Invalid)
    xml.writeAttribute("unit", unitEnumToString(mUnit));
  if (mStyle != Style_Invalid)
    xml.writeAttribute("style", styleEnumToString(mStyle));
  if (mMultiple_set)
    xml.writeAttribute("multiple", QString::number( mMultiple ) );
  if (mDisplay != Display_Invalid)
    xml.writeAttribute("display", displayEnumToString(mDisplay));
  if (mAltdistance_set)
    xml.writeAttribute("altdistance", QString::number( mAltdistance ) );
  if (mAltunitdist != Altunitdist_Invalid)
    xml.writeAttribute("altunitdist", altunitdistEnumToString(mAltunitdist));
  if (mAltunit != Altunit_Invalid)
    xml.writeAttribute("altunit", altunitEnumToString(mAltunit));
  xml.writeEndElement();
}


Setting::Setting()
  : mAlwaysvectorfont(Alwaysvectorfont_Invalid), mVerticaltext(Verticaltext_Invalid), mKeepoldvectorfont(Keepoldvectorfont_Invalid)
{
}

Setting::~Setting()
{
}

void Setting::setAlwaysvectorfont( const AlwaysvectorfontEnum &v )
{
  mAlwaysvectorfont = v;
}

Setting::AlwaysvectorfontEnum Setting::alwaysvectorfont() const
{
  return mAlwaysvectorfont;
}

void Setting::setVerticaltext( const VerticaltextEnum &v )
{
  mVerticaltext = v;
}

Setting::VerticaltextEnum Setting::verticaltext() const
{
  return mVerticaltext;
}

void Setting::setKeepoldvectorfont( const KeepoldvectorfontEnum &v )
{
  mKeepoldvectorfont = v;
}

Setting::KeepoldvectorfontEnum Setting::keepoldvectorfont() const
{
  return mKeepoldvectorfont;
}

Setting::AlwaysvectorfontEnum Setting::alwaysvectorfontEnumFromString( const QString & v, bool *ok )
{
  if (ok) *ok = true;

  if ( v == "no" ) {
    return Alwaysvectorfont_no;
  } else if ( v == "yes" ) {
    return Alwaysvectorfont_yes;
  } else {
    if (ok) *ok = false;
    return Alwaysvectorfont_Invalid;
  }

  return Alwaysvectorfont_Invalid;
}

QString Setting::alwaysvectorfontEnumToString( const AlwaysvectorfontEnum & v )
{
  switch( v ) {
  case Alwaysvectorfont_no: return "no";
  case Alwaysvectorfont_yes: return "yes";
  case Alwaysvectorfont_Invalid:
  default:
    qCritical() << "Unable to serialize a(n) AlwaysvectorfontEnum enum because it has invalid value:" << v;
    return QString();
  }
}

Setting::VerticaltextEnum Setting::verticaltextEnumFromString( const QString & v, bool *ok )
{
  if (ok) *ok = true;

  if ( v == "up" ) {
    return Verticaltext_up;
  } else if ( v == "down" ) {
    return Verticaltext_down;
  } else {
    if (ok) *ok = false;
    return Verticaltext_Invalid;
  }

  return Verticaltext_Invalid;
}

QString Setting::verticaltextEnumToString( const VerticaltextEnum & v )
{
  switch( v ) {
  case Verticaltext_up: return "up";
  case Verticaltext_down: return "down";
  case Verticaltext_Invalid:
  default:
    qCritical() << "Unable to serialize a(n) VerticaltextEnum enum because it has invalid value:" << v;
    return QString();
  }
}

Setting::KeepoldvectorfontEnum Setting::keepoldvectorfontEnumFromString( const QString & v, bool *ok )
{
  if (ok) *ok = true;

  if ( v == "no" ) {
    return Keepoldvectorfont_no;
  } else if ( v == "yes" ) {
    return Keepoldvectorfont_yes;
  } else {
    if (ok) *ok = false;
    return Keepoldvectorfont_Invalid;
  }

  return Keepoldvectorfont_Invalid;
}

QString Setting::keepoldvectorfontEnumToString( const KeepoldvectorfontEnum & v )
{
  switch( v ) {
  case Keepoldvectorfont_no: return "no";
  case Keepoldvectorfont_yes: return "yes";
  case Keepoldvectorfont_Invalid:
  default:
    qCritical() << "Unable to serialize a(n) KeepoldvectorfontEnum enum because it has invalid value:" << v;
    return QString();
  }
}

Setting *Setting::parseElement( const QDomElement &element, bool *ok )
{
  if ( element.tagName() != "setting" ) {
    qCritical() << "Expected 'setting', got '" << element.tagName() << "'.";
    if ( ok ) *ok = false;
    return nullptr;
  }

  Setting* result = new Setting();

  if (element.hasAttribute("alwaysvectorfont"))  {
    AlwaysvectorfontEnum alwaysvectorfont = alwaysvectorfontEnumFromString( element.attribute( "alwaysvectorfont" ), ok  );
    if (ok && !(*ok)) {
      qCritical() << "Invalid string: \"" << element.attribute( "alwaysvectorfont" ) << "\" in the \"alwaysvectorfont\" element";
      return nullptr;
    } else {
      result->setAlwaysvectorfont( alwaysvectorfont );
    }
  } else {
    result->setAlwaysvectorfont(Alwaysvectorfont_Invalid);
  }
  if (element.hasAttribute("verticaltext"))  {
    VerticaltextEnum verticaltext = verticaltextEnumFromString( element.attribute( "verticaltext" ), ok  );
    if (ok && !(*ok)) {
      qCritical() << "Invalid string: \"" << element.attribute( "verticaltext" ) << "\" in the \"verticaltext\" element";
      return nullptr;
    } else {
      result->setVerticaltext( verticaltext );
    }
  } else {
    // default value
    result->setVerticaltext(Verticaltext_up);
  }
  if (element.hasAttribute("keepoldvectorfont"))  {
    KeepoldvectorfontEnum keepoldvectorfont = keepoldvectorfontEnumFromString( element.attribute( "keepoldvectorfont" ), ok  );
    if (ok && !(*ok)) {
      qCritical() << "Invalid string: \"" << element.attribute( "keepoldvectorfont" ) << "\" in the \"keepoldvectorfont\" element";
      return nullptr;
    } else {
      result->setKeepoldvectorfont( keepoldvectorfont );
    }
  } else {
    // default value
    result->setKeepoldvectorfont(Keepoldvectorfont_no);
  }

  if ( ok ) *ok = true;
  return result;
}

void Setting::writeElement( QXmlStreamWriter &xml ) const
{
  xml.writeStartElement( "setting" );
  if (mAlwaysvectorfont != Alwaysvectorfont_Invalid)
    xml.writeAttribute("alwaysvectorfont", alwaysvectorfontEnumToString(mAlwaysvectorfont));
  if (mVerticaltext != Verticaltext_Invalid)
    xml.writeAttribute("verticaltext", verticaltextEnumToString(mVerticaltext));
  if (mKeepoldvectorfont != Keepoldvectorfont_Invalid)
    xml.writeAttribute("keepoldvectorfont", keepoldvectorfontEnumToString(mKeepoldvectorfont));
  xml.writeEndElement();
}


Settings::Settings()
{
}

Settings::~Settings()
{
}

void Settings::addSetting( Setting* v )
{
  mSettingList.append( v );
}

void Settings::setSettingList( const Setting::List &v )
{
  mSettingList = v;
}

Setting::List *Settings::settingList()
{
  return &mSettingList;
}

Settings *Settings::parseElement( const QDomElement &element, bool *ok )
{
  if ( element.tagName() != "settings" ) {
    qCritical() << "Expected 'settings', got '" << element.tagName() << "'.";
    if ( ok ) *ok = false;
    return nullptr;
  }

  Settings* result = new Settings();

  QDomNode n;
  for( n = element.firstChild(); !n.isNull(); n = n.nextSibling() ) {
    QDomElement e = n.toElement();
    if ( e.tagName() == "setting" ) {
      bool ok;
      Setting *o = Setting::parseElement( e, &ok );
      if ( ok ) result->addSetting( o );
    }
  }


  if ( ok ) *ok = true;
  return result;
}

void Settings::writeElement( QXmlStreamWriter &xml ) const
{
  if ( !mSettingList.isEmpty() ) {
    xml.writeStartElement( "settings" );
    foreach( Setting* e, mSettingList ) {
      if (e)
        e->writeElement( xml );
    }
    xml.writeEndElement();
  }
}


Mfgpreviewcolor::Mfgpreviewcolor()
{
}

Mfgpreviewcolor::~Mfgpreviewcolor()
{
}

void Mfgpreviewcolor::setName( const QString &v )
{
  mName = v;
}

QString Mfgpreviewcolor::name() const
{
  return mName;
}

void Mfgpreviewcolor::setColor( const QString &v )
{
  mColor = v;
}

QString Mfgpreviewcolor::color() const
{
  return mColor;
}

Mfgpreviewcolor *Mfgpreviewcolor::parseElement( const QDomElement &element, bool *ok )
{
  if ( element.tagName() != "mfgpreviewcolor" ) {
    qCritical() << "Expected 'mfgpreviewcolor', got '" << element.tagName() << "'.";
    if ( ok ) *ok = false;
    return nullptr;
  }

  Mfgpreviewcolor* result = new Mfgpreviewcolor();

  result->setName( element.attribute( "name" ) );
  result->setColor( element.attribute( "color" ) );

  if ( ok ) *ok = true;
  return result;
}

void Mfgpreviewcolor::writeElement( QXmlStreamWriter &xml ) const
{
  xml.writeStartElement( "mfgpreviewcolor" );
  if (!mName.isEmpty())
    xml.writeAttribute("name", mName );
  if (!mColor.isEmpty())
    xml.writeAttribute("color", mColor );
  xml.writeEndElement();
}


Mfgpreviewcolors::Mfgpreviewcolors()
{
}

Mfgpreviewcolors::~Mfgpreviewcolors()
{
}

void Mfgpreviewcolors::addMfgpreviewcolor( Mfgpreviewcolor* v )
{
  mMfgpreviewcolorList.append( v );
}

void Mfgpreviewcolors::setMfgpreviewcolorList( const Mfgpreviewcolor::List &v )
{
  mMfgpreviewcolorList = v;
}

Mfgpreviewcolor::List *Mfgpreviewcolors::mfgpreviewcolorList()
{
  return &mMfgpreviewcolorList;
}

Mfgpreviewcolors *Mfgpreviewcolors::parseElement( const QDomElement &element, bool *ok )
{
  if ( element.tagName() != "mfgpreviewcolors" ) {
    qCritical() << "Expected 'mfgpreviewcolors', got '" << element.tagName() << "'.";
    if ( ok ) *ok = false;
    return nullptr;
  }

  Mfgpreviewcolors* result = new Mfgpreviewcolors();

  QDomNode n;
  for( n = element.firstChild(); !n.isNull(); n = n.nextSibling() ) {
    QDomElement e = n.toElement();
    if ( e.tagName() == "mfgpreviewcolor" ) {
      bool ok;
      Mfgpreviewcolor *o = Mfgpreviewcolor::parseElement( e, &ok );
      if ( ok ) result->addMfgpreviewcolor( o );
    }
  }


  if ( ok ) *ok = true;
  return result;
}

void Mfgpreviewcolors::writeElement( QXmlStreamWriter &xml ) const
{
  if ( !mMfgpreviewcolorList.isEmpty() ) {
    xml.writeStartElement( "mfgpreviewcolors" );
    foreach( Mfgpreviewcolor* e, mMfgpreviewcolorList ) {
      if (e)
        e->writeElement( xml );
    }
    xml.writeEndElement();
  }
}


Via::Via()
  : mX(0.0), mX_set(false), mY(0.0), mY_set(false), mDrill(0.0), mDrill_set(false), mDiameter(0.0), mDiameter_set(false), mShape(Shape_Invalid), mAlwaysstop(Alwaysstop_Invalid)
{
}

Via::~Via()
{
}

void Via::setX( const double v )
{
  mX_set = true;
  mX = v;
}

double Via::x() const
{
  return mX;
}

bool Via::xSet() const
{
  return mX_set;
}

void Via::setY( const double v )
{
  mY_set = true;
  mY = v;
}

double Via::y() const
{
  return mY;
}

bool Via::ySet() const
{
  return mY_set;
}

void Via::setExtent( const QString &v )
{
  mExtent = v;
}

QString Via::extent() const
{
  return mExtent;
}

void Via::setDrill( const double v )
{
  mDrill_set = true;
  mDrill = v;
}

double Via::drill() const
{
  return mDrill;
}

bool Via::drillSet() const
{
  return mDrill_set;
}

void Via::setDiameter( const double v )
{
  mDiameter_set = true;
  mDiameter = v;
}

double Via::diameter() const
{
  return mDiameter;
}

bool Via::diameterSet() const
{
  return mDiameter_set;
}

void Via::setShape( const ShapeEnum &v )
{
  mShape = v;
}

Via::ShapeEnum Via::shape() const
{
  return mShape;
}

void Via::setAlwaysstop( const AlwaysstopEnum &v )
{
  mAlwaysstop = v;
}

Via::AlwaysstopEnum Via::alwaysstop() const
{
  return mAlwaysstop;
}

Via::ShapeEnum Via::shapeEnumFromString( const QString & v, bool *ok )
{
  if (ok) *ok = true;

  if ( v == "square" ) {
    return Shape_square;
  } else if ( v == "round" ) {
    return Shape_round;
  } else if ( v == "octagon" ) {
    return Shape_octagon;
  } else {
    if (ok) *ok = false;
    return Shape_Invalid;
  }

  return Shape_Invalid;
}

QString Via::shapeEnumToString( const ShapeEnum & v )
{
  switch( v ) {
  case Shape_square: return "square";
  case Shape_round: return "round";
  case Shape_octagon: return "octagon";
  case Shape_Invalid:
  default:
    qCritical() << "Unable to serialize a(n) ShapeEnum enum because it has invalid value:" << v;
    return QString();
  }
}

Via::AlwaysstopEnum Via::alwaysstopEnumFromString( const QString & v, bool *ok )
{
  if (ok) *ok = true;

  if ( v == "no" ) {
    return Alwaysstop_no;
  } else if ( v == "yes" ) {
    return Alwaysstop_yes;
  } else {
    if (ok) *ok = false;
    return Alwaysstop_Invalid;
  }

  return Alwaysstop_Invalid;
}

QString Via::alwaysstopEnumToString( const AlwaysstopEnum & v )
{
  switch( v ) {
  case Alwaysstop_no: return "no";
  case Alwaysstop_yes: return "yes";
  case Alwaysstop_Invalid:
  default:
    qCritical() << "Unable to serialize a(n) AlwaysstopEnum enum because it has invalid value:" << v;
    return QString();
  }
}

Via *Via::parseElement( const QDomElement &element, bool *ok )
{
  if ( element.tagName() != "via" ) {
    qCritical() << "Expected 'via', got '" << element.tagName() << "'.";
    if ( ok ) *ok = false;
    return nullptr;
  }

  Via* result = new Via();

  if (element.hasAttribute("x"))
    result->setX( element.attribute( "x" ).toDouble() );
  if (element.hasAttribute("y"))
    result->setY( element.attribute( "y" ).toDouble() );
  result->setExtent( element.attribute( "extent" ) );
  if (element.hasAttribute("drill"))
    result->setDrill( element.attribute( "drill" ).toDouble() );
  if (element.hasAttribute("diameter"))
    result->setDiameter( element.attribute( "diameter" ).toDouble() );
  if (element.hasAttribute("shape"))  {
    ShapeEnum shape = shapeEnumFromString( element.attribute( "shape" ), ok  );
    if (ok && !(*ok)) {
      qCritical() << "Invalid string: \"" << element.attribute( "shape" ) << "\" in the \"shape\" element";
      return nullptr;
    } else {
      result->setShape( shape );
    }
  } else {
    // default value
    result->setShape(Shape_round);
  }
  if (element.hasAttribute("alwaysstop"))  {
    AlwaysstopEnum alwaysstop = alwaysstopEnumFromString( element.attribute( "alwaysstop" ), ok  );
    if (ok && !(*ok)) {
      qCritical() << "Invalid string: \"" << element.attribute( "alwaysstop" ) << "\" in the \"alwaysstop\" element";
      return nullptr;
    } else {
      result->setAlwaysstop( alwaysstop );
    }
  } else {
    // default value
    result->setAlwaysstop(Alwaysstop_no);
  }

  if ( ok ) *ok = true;
  return result;
}

void Via::writeElement( QXmlStreamWriter &xml ) const
{
  xml.writeStartElement( "via" );
  if (mX_set)
    xml.writeAttribute("x", QString::number( mX ) );
  if (mY_set)
    xml.writeAttribute("y", QString::number( mY ) );
  if (!mExtent.isEmpty())
    xml.writeAttribute("extent", mExtent );
  if (mDrill_set)
    xml.writeAttribute("drill", QString::number( mDrill ) );
  if (mDiameter_set)
    xml.writeAttribute("diameter", QString::number( mDiameter ) );
  if (mShape != Shape_Invalid)
    xml.writeAttribute("shape", shapeEnumToString(mShape));
  if (mAlwaysstop != Alwaysstop_Invalid)
    xml.writeAttribute("alwaysstop", alwaysstopEnumToString(mAlwaysstop));
  xml.writeEndElement();
}


Contactref::Contactref()
  : mRoute(Route_Invalid)
{
}

Contactref::~Contactref()
{
}

void Contactref::setElement( const QString &v )
{
  mElement = v;
}

QString Contactref::element() const
{
  return mElement;
}

void Contactref::setPad( const QString &v )
{
  mPad = v;
}

QString Contactref::pad() const
{
  return mPad;
}

void Contactref::setRoute( const RouteEnum &v )
{
  mRoute = v;
}

Contactref::RouteEnum Contactref::route() const
{
  return mRoute;
}

void Contactref::setRoutetag( const QString &v )
{
  mRoutetag = v;
}

QString Contactref::routetag() const
{
  return mRoutetag;
}

Contactref::RouteEnum Contactref::routeEnumFromString( const QString & v, bool *ok )
{
  if (ok) *ok = true;

  if ( v == "all" ) {
    return Route_all;
  } else if ( v == "any" ) {
    return Route_any;
  } else {
    if (ok) *ok = false;
    return Route_Invalid;
  }

  return Route_Invalid;
}

QString Contactref::routeEnumToString( const RouteEnum & v )
{
  switch( v ) {
  case Route_all: return "all";
  case Route_any: return "any";
  case Route_Invalid:
  default:
    qCritical() << "Unable to serialize a(n) RouteEnum enum because it has invalid value:" << v;
    return QString();
  }
}

Contactref *Contactref::parseElement( const QDomElement &element, bool *ok )
{
  if ( element.tagName() != "contactref" ) {
    qCritical() << "Expected 'contactref', got '" << element.tagName() << "'.";
    if ( ok ) *ok = false;
    return nullptr;
  }

  Contactref* result = new Contactref();

  result->setElement( element.attribute( "element" ) );
  result->setPad( element.attribute( "pad" ) );
  if (element.hasAttribute("route"))  {
    RouteEnum route = routeEnumFromString( element.attribute( "route" ), ok  );
    if (ok && !(*ok)) {
      qCritical() << "Invalid string: \"" << element.attribute( "route" ) << "\" in the \"route\" element";
      return nullptr;
    } else {
      result->setRoute( route );
    }
  } else {
    // default value
    result->setRoute(Route_all);
  }
  result->setRoutetag( element.attribute( "routetag" ) );

  if ( ok ) *ok = true;
  return result;
}

void Contactref::writeElement( QXmlStreamWriter &xml ) const
{
  xml.writeStartElement( "contactref" );
  if (!mElement.isEmpty())
    xml.writeAttribute("element", mElement );
  if (!mPad.isEmpty())
    xml.writeAttribute("pad", mPad );
  if (mRoute != Route_Invalid)
    xml.writeAttribute("route", routeEnumToString(mRoute));
  if (!mRoutetag.isEmpty())
    xml.writeAttribute("routetag", mRoutetag );
  xml.writeEndElement();
}


Vertex::Vertex()
  : mX(0.0), mX_set(false), mY(0.0), mY_set(false), mCurve(0.0), mCurve_set(false)
{
}

Vertex::~Vertex()
{
}

void Vertex::setX( const double v )
{
  mX_set = true;
  mX = v;
}

double Vertex::x() const
{
  return mX;
}

bool Vertex::xSet() const
{
  return mX_set;
}

void Vertex::setY( const double v )
{
  mY_set = true;
  mY = v;
}

double Vertex::y() const
{
  return mY;
}

bool Vertex::ySet() const
{
  return mY_set;
}

void Vertex::setCurve( const double v )
{
  mCurve_set = true;
  mCurve = v;
}

double Vertex::curve() const
{
  return mCurve;
}

bool Vertex::curveSet() const
{
  return mCurve_set;
}

Vertex *Vertex::parseElement( const QDomElement &element, bool *ok )
{
  if ( element.tagName() != "vertex" ) {
    qCritical() << "Expected 'vertex', got '" << element.tagName() << "'.";
    if ( ok ) *ok = false;
    return nullptr;
  }

  Vertex* result = new Vertex();

  if (element.hasAttribute("x"))
    result->setX( element.attribute( "x" ).toDouble() );
  if (element.hasAttribute("y"))
    result->setY( element.attribute( "y" ).toDouble() );
  if (element.hasAttribute("curve"))
    result->setCurve( element.attribute( "curve" ).toDouble() );

  if ( ok ) *ok = true;
  return result;
}

void Vertex::writeElement( QXmlStreamWriter &xml ) const
{
  xml.writeStartElement( "vertex" );
  if (mX_set)
    xml.writeAttribute("x", QString::number( mX ) );
  if (mY_set)
    xml.writeAttribute("y", QString::number( mY ) );
  if (mCurve_set)
    xml.writeAttribute("curve", QString::number( mCurve ) );
  xml.writeEndElement();
}


Polygon::Polygon()
  : mWidth(0.0), mWidth_set(false), mLayer(0), mLayer_set(false), mSpacing(0.0), mSpacing_set(false), mPour(Pour_Invalid), mIsolate(0.0), mIsolate_set(false), mOrphans(Orphans_Invalid), mThermals(Thermals_Invalid), mRank(0), mRank_set(false)
{
}

Polygon::~Polygon()
{
}

void Polygon::setWidth( const double v )
{
  mWidth_set = true;
  mWidth = v;
}

double Polygon::width() const
{
  return mWidth;
}

bool Polygon::widthSet() const
{
  return mWidth_set;
}

void Polygon::setLayer( const int v )
{
  mLayer_set = true;
  mLayer = v;
}

int Polygon::layer() const
{
  return mLayer;
}

bool Polygon::layerSet() const
{
  return mLayer_set;
}

void Polygon::setSpacing( const double v )
{
  mSpacing_set = true;
  mSpacing = v;
}

double Polygon::spacing() const
{
  return mSpacing;
}

bool Polygon::spacingSet() const
{
  return mSpacing_set;
}

void Polygon::setPour( const PourEnum &v )
{
  mPour = v;
}

Polygon::PourEnum Polygon::pour() const
{
  return mPour;
}

void Polygon::setIsolate( const double v )
{
  mIsolate_set = true;
  mIsolate = v;
}

double Polygon::isolate() const
{
  return mIsolate;
}

bool Polygon::isolateSet() const
{
  return mIsolate_set;
}

void Polygon::setOrphans( const OrphansEnum &v )
{
  mOrphans = v;
}

Polygon::OrphansEnum Polygon::orphans() const
{
  return mOrphans;
}

void Polygon::setThermals( const ThermalsEnum &v )
{
  mThermals = v;
}

Polygon::ThermalsEnum Polygon::thermals() const
{
  return mThermals;
}

void Polygon::setRank( const int v )
{
  mRank_set = true;
  mRank = v;
}

int Polygon::rank() const
{
  return mRank;
}

bool Polygon::rankSet() const
{
  return mRank_set;
}

void Polygon::addVertex( Vertex* v )
{
  mVertexList.append( v );
}

void Polygon::setVertexList( const Vertex::List &v )
{
  mVertexList = v;
}

Vertex::List *Polygon::vertexList()
{
  return &mVertexList;
}

Polygon::PourEnum Polygon::pourEnumFromString( const QString & v, bool *ok )
{
  if (ok) *ok = true;

  if ( v == "solid" ) {
    return Pour_solid;
  } else if ( v == "hatch" ) {
    return Pour_hatch;
  } else if ( v == "cutout" ) {
    return Pour_cutout;
  } else {
    if (ok) *ok = false;
    return Pour_Invalid;
  }

  return Pour_Invalid;
}

QString Polygon::pourEnumToString( const PourEnum & v )
{
  switch( v ) {
  case Pour_solid: return "solid";
  case Pour_hatch: return "hatch";
  case Pour_cutout: return "cutout";
  case Pour_Invalid:
  default:
    qCritical() << "Unable to serialize a(n) PourEnum enum because it has invalid value:" << v;
    return QString();
  }
}

Polygon::OrphansEnum Polygon::orphansEnumFromString( const QString & v, bool *ok )
{
  if (ok) *ok = true;

  if ( v == "no" ) {
    return Orphans_no;
  } else if ( v == "yes" ) {
    return Orphans_yes;
  } else {
    if (ok) *ok = false;
    return Orphans_Invalid;
  }

  return Orphans_Invalid;
}

QString Polygon::orphansEnumToString( const OrphansEnum & v )
{
  switch( v ) {
  case Orphans_no: return "no";
  case Orphans_yes: return "yes";
  case Orphans_Invalid:
  default:
    qCritical() << "Unable to serialize a(n) OrphansEnum enum because it has invalid value:" << v;
    return QString();
  }
}

Polygon::ThermalsEnum Polygon::thermalsEnumFromString( const QString & v, bool *ok )
{
  if (ok) *ok = true;

  if ( v == "no" ) {
    return Thermals_no;
  } else if ( v == "yes" ) {
    return Thermals_yes;
  } else {
    if (ok) *ok = false;
    return Thermals_Invalid;
  }

  return Thermals_Invalid;
}

QString Polygon::thermalsEnumToString( const ThermalsEnum & v )
{
  switch( v ) {
  case Thermals_no: return "no";
  case Thermals_yes: return "yes";
  case Thermals_Invalid:
  default:
    qCritical() << "Unable to serialize a(n) ThermalsEnum enum because it has invalid value:" << v;
    return QString();
  }
}

Polygon *Polygon::parseElement( const QDomElement &element, bool *ok )
{
  if ( element.tagName() != "polygon" ) {
    qCritical() << "Expected 'polygon', got '" << element.tagName() << "'.";
    if ( ok ) *ok = false;
    return nullptr;
  }

  Polygon* result = new Polygon();

  QDomNode n;
  for( n = element.firstChild(); !n.isNull(); n = n.nextSibling() ) {
    QDomElement e = n.toElement();
    if ( e.tagName() == "vertex" ) {
      bool ok;
      Vertex *o = Vertex::parseElement( e, &ok );
      if ( ok ) result->addVertex( o );
    }
  }

  if (element.hasAttribute("width"))
    result->setWidth( element.attribute( "width" ).toDouble() );
  if (element.hasAttribute("layer"))
    result->setLayer( element.attribute( "layer" ).toInt() );
  if (element.hasAttribute("spacing"))
    result->setSpacing( element.attribute( "spacing" ).toDouble() );
  if (element.hasAttribute("pour"))  {
    PourEnum pour = pourEnumFromString( element.attribute( "pour" ), ok  );
    if (ok && !(*ok)) {
      qCritical() << "Invalid string: \"" << element.attribute( "pour" ) << "\" in the \"pour\" element";
      return nullptr;
    } else {
      result->setPour( pour );
    }
  } else {
    // default value
    result->setPour(Pour_solid);
  }
  if (element.hasAttribute("isolate"))
    result->setIsolate( element.attribute( "isolate" ).toDouble() );
  if (element.hasAttribute("orphans"))  {
    OrphansEnum orphans = orphansEnumFromString( element.attribute( "orphans" ), ok  );
    if (ok && !(*ok)) {
      qCritical() << "Invalid string: \"" << element.attribute( "orphans" ) << "\" in the \"orphans\" element";
      return nullptr;
    } else {
      result->setOrphans( orphans );
    }
  } else {
    // default value
    result->setOrphans(Orphans_no);
  }
  if (element.hasAttribute("thermals"))  {
    ThermalsEnum thermals = thermalsEnumFromString( element.attribute( "thermals" ), ok  );
    if (ok && !(*ok)) {
      qCritical() << "Invalid string: \"" << element.attribute( "thermals" ) << "\" in the \"thermals\" element";
      return nullptr;
    } else {
      result->setThermals( thermals );
    }
  } else {
    // default value
    result->setThermals(Thermals_yes);
  }
  if (element.hasAttribute("rank"))
    result->setRank( element.attribute( "rank" ).toInt() );

  if ( ok ) *ok = true;
  return result;
}

void Polygon::writeElement( QXmlStreamWriter &xml ) const
{
  xml.writeStartElement( "polygon" );
  if (mWidth_set)
    xml.writeAttribute("width", QString::number( mWidth ) );
  if (mLayer_set)
    xml.writeAttribute("layer", QString::number( mLayer ) );
  if (mSpacing_set)
    xml.writeAttribute("spacing", QString::number( mSpacing ) );
  if (mPour != Pour_Invalid)
    xml.writeAttribute("pour", pourEnumToString(mPour));
  if (mIsolate_set)
    xml.writeAttribute("isolate", QString::number( mIsolate ) );
  if (mOrphans != Orphans_Invalid)
    xml.writeAttribute("orphans", orphansEnumToString(mOrphans));
  if (mThermals != Thermals_Invalid)
    xml.writeAttribute("thermals", thermalsEnumToString(mThermals));
  if (mRank_set)
    xml.writeAttribute("rank", QString::number( mRank ) );
  foreach( Vertex* e, mVertexList ) {
    if (e)
      e->writeElement( xml );
  }
  xml.writeEndElement();
}


Wire::Wire()
  : mX1(0.0), mX1_set(false), mY1(0.0), mY1_set(false), mX2(0.0), mX2_set(false), mY2(0.0), mY2_set(false), mWidth(0.0), mWidth_set(false), mLayer(0), mLayer_set(false), mStyle(Style_Invalid), mCurve(0.0), mCurve_set(false), mCap(Cap_Invalid)
{
}

Wire::~Wire()
{
}

void Wire::setX1( const double v )
{
  mX1_set = true;
  mX1 = v;
}

double Wire::x1() const
{
  return mX1;
}

bool Wire::x1Set() const
{
  return mX1_set;
}

void Wire::setY1( const double v )
{
  mY1_set = true;
  mY1 = v;
}

double Wire::y1() const
{
  return mY1;
}

bool Wire::y1Set() const
{
  return mY1_set;
}

void Wire::setX2( const double v )
{
  mX2_set = true;
  mX2 = v;
}

double Wire::x2() const
{
  return mX2;
}

bool Wire::x2Set() const
{
  return mX2_set;
}

void Wire::setY2( const double v )
{
  mY2_set = true;
  mY2 = v;
}

double Wire::y2() const
{
  return mY2;
}

bool Wire::y2Set() const
{
  return mY2_set;
}

void Wire::setWidth( const double v )
{
  mWidth_set = true;
  mWidth = v;
}

double Wire::width() const
{
  return mWidth;
}

bool Wire::widthSet() const
{
  return mWidth_set;
}

void Wire::setLayer( const int v )
{
  mLayer_set = true;
  mLayer = v;
}

int Wire::layer() const
{
  return mLayer;
}

bool Wire::layerSet() const
{
  return mLayer_set;
}

void Wire::setExtent( const QString &v )
{
  mExtent = v;
}

QString Wire::extent() const
{
  return mExtent;
}

void Wire::setStyle( const StyleEnum &v )
{
  mStyle = v;
}

Wire::StyleEnum Wire::style() const
{
  return mStyle;
}

void Wire::setCurve( const double v )
{
  mCurve_set = true;
  mCurve = v;
}

double Wire::curve() const
{
  return mCurve;
}

bool Wire::curveSet() const
{
  return mCurve_set;
}

void Wire::setCap( const CapEnum &v )
{
  mCap = v;
}

Wire::CapEnum Wire::cap() const
{
  return mCap;
}

Wire::StyleEnum Wire::styleEnumFromString( const QString & v, bool *ok )
{
  if (ok) *ok = true;

  if ( v == "continuous" ) {
    return Style_continuous;
  } else if ( v == "longdash" ) {
    return Style_longdash;
  } else if ( v == "shortdash" ) {
    return Style_shortdash;
  } else if ( v == "dashdot" ) {
    return Style_dashdot;
  } else {
    if (ok) *ok = false;
    return Style_Invalid;
  }

  return Style_Invalid;
}

QString Wire::styleEnumToString( const StyleEnum & v )
{
  switch( v ) {
  case Style_continuous: return "continuous";
  case Style_longdash: return "longdash";
  case Style_shortdash: return "shortdash";
  case Style_dashdot: return "dashdot";
  case Style_Invalid:
  default:
    qCritical() << "Unable to serialize a(n) StyleEnum enum because it has invalid value:" << v;
    return QString();
  }
}

Wire::CapEnum Wire::capEnumFromString( const QString & v, bool *ok )
{
  if (ok) *ok = true;

  if ( v == "flat" ) {
    return Cap_flat;
  } else if ( v == "round" ) {
    return Cap_round;
  } else {
    if (ok) *ok = false;
    return Cap_Invalid;
  }

  return Cap_Invalid;
}

QString Wire::capEnumToString( const CapEnum & v )
{
  switch( v ) {
  case Cap_flat: return "flat";
  case Cap_round: return "round";
  case Cap_Invalid:
  default:
    qCritical() << "Unable to serialize a(n) CapEnum enum because it has invalid value:" << v;
    return QString();
  }
}

Wire *Wire::parseElement( const QDomElement &element, bool *ok )
{
  if ( element.tagName() != "wire" ) {
    qCritical() << "Expected 'wire', got '" << element.tagName() << "'.";
    if ( ok ) *ok = false;
    return nullptr;
  }

  Wire* result = new Wire();

  if (element.hasAttribute("x1"))
    result->setX1( element.attribute( "x1" ).toDouble() );
  if (element.hasAttribute("y1"))
    result->setY1( element.attribute( "y1" ).toDouble() );
  if (element.hasAttribute("x2"))
    result->setX2( element.attribute( "x2" ).toDouble() );
  if (element.hasAttribute("y2"))
    result->setY2( element.attribute( "y2" ).toDouble() );
  if (element.hasAttribute("width"))
    result->setWidth( element.attribute( "width" ).toDouble() );
  if (element.hasAttribute("layer"))
    result->setLayer( element.attribute( "layer" ).toInt() );
  result->setExtent( element.attribute( "extent" ) );
  if (element.hasAttribute("style"))  {
    StyleEnum style = styleEnumFromString( element.attribute( "style" ), ok  );
    if (ok && !(*ok)) {
      qCritical() << "Invalid string: \"" << element.attribute( "style" ) << "\" in the \"style\" element";
      return nullptr;
    } else {
      result->setStyle( style );
    }
  } else {
    // default value
    result->setStyle(Style_continuous);
  }
  if (element.hasAttribute("curve"))
    result->setCurve( element.attribute( "curve" ).toDouble() );
  if (element.hasAttribute("cap"))  {
    CapEnum cap = capEnumFromString( element.attribute( "cap" ), ok  );
    if (ok && !(*ok)) {
      qCritical() << "Invalid string: \"" << element.attribute( "cap" ) << "\" in the \"cap\" element";
      return nullptr;
    } else {
      result->setCap( cap );
    }
  } else {
    // default value
    result->setCap(Cap_round);
  }

  if ( ok ) *ok = true;
  return result;
}

void Wire::writeElement( QXmlStreamWriter &xml ) const
{
  xml.writeStartElement( "wire" );
  if (mX1_set)
    xml.writeAttribute("x1", QString::number( mX1 ) );
  if (mY1_set)
    xml.writeAttribute("y1", QString::number( mY1 ) );
  if (mX2_set)
    xml.writeAttribute("x2", QString::number( mX2 ) );
  if (mY2_set)
    xml.writeAttribute("y2", QString::number( mY2 ) );
  if (mWidth_set)
    xml.writeAttribute("width", QString::number( mWidth ) );
  if (mLayer_set)
    xml.writeAttribute("layer", QString::number( mLayer ) );
  if (!mExtent.isEmpty())
    xml.writeAttribute("extent", mExtent );
  if (mStyle != Style_Invalid)
    xml.writeAttribute("style", styleEnumToString(mStyle));
  if (mCurve_set)
    xml.writeAttribute("curve", QString::number( mCurve ) );
  if (mCap != Cap_Invalid)
    xml.writeAttribute("cap", capEnumToString(mCap));
  xml.writeEndElement();
}


Signal::Signal()
  : mClass(0), mClass_set(false), mAirwireshidden(Airwireshidden_Invalid)
{
}

Signal::~Signal()
{
}

void Signal::setName( const QString &v )
{
  mName = v;
}

QString Signal::name() const
{
  return mName;
}

void Signal::setClass( const int v )
{
  mClass_set = true;
  mClass = v;
}

int Signal::class_() const
{
  return mClass;
}

bool Signal::classSet() const
{
  return mClass_set;
}

void Signal::setAirwireshidden( const AirwireshiddenEnum &v )
{
  mAirwireshidden = v;
}

Signal::AirwireshiddenEnum Signal::airwireshidden() const
{
  return mAirwireshidden;
}

void Signal::addContactref( Contactref* v )
{
  mContactrefList.append( v );
}

void Signal::setContactrefList( const Contactref::List &v )
{
  mContactrefList = v;
}

Contactref::List *Signal::contactrefList()
{
  return &mContactrefList;
}

void Signal::addPolygon( Polygon* v )
{
  mPolygonList.append( v );
}

void Signal::setPolygonList( const Polygon::List &v )
{
  mPolygonList = v;
}

Polygon::List *Signal::polygonList()
{
  return &mPolygonList;
}

void Signal::addWire( Wire* v )
{
  mWireList.append( v );
}

void Signal::setWireList( const Wire::List &v )
{
  mWireList = v;
}

Wire::List *Signal::wireList()
{
  return &mWireList;
}

void Signal::addVia( Via* v )
{
  mViaList.append( v );
}

void Signal::setViaList( const Via::List &v )
{
  mViaList = v;
}

Via::List *Signal::viaList()
{
  return &mViaList;
}

Signal::AirwireshiddenEnum Signal::airwireshiddenEnumFromString( const QString & v, bool *ok )
{
  if (ok) *ok = true;

  if ( v == "no" ) {
    return Airwireshidden_no;
  } else if ( v == "yes" ) {
    return Airwireshidden_yes;
  } else {
    if (ok) *ok = false;
    return Airwireshidden_Invalid;
  }

  return Airwireshidden_Invalid;
}

QString Signal::airwireshiddenEnumToString( const AirwireshiddenEnum & v )
{
  switch( v ) {
  case Airwireshidden_no: return "no";
  case Airwireshidden_yes: return "yes";
  case Airwireshidden_Invalid:
  default:
    qCritical() << "Unable to serialize a(n) AirwireshiddenEnum enum because it has invalid value:" << v;
    return QString();
  }
}

Signal *Signal::parseElement( const QDomElement &element, bool *ok )
{
  if ( element.tagName() != "signal" ) {
    qCritical() << "Expected 'signal', got '" << element.tagName() << "'.";
    if ( ok ) *ok = false;
    return nullptr;
  }

  Signal* result = new Signal();

  QDomNode n;
  for( n = element.firstChild(); !n.isNull(); n = n.nextSibling() ) {
    QDomElement e = n.toElement();
    if ( e.tagName() == "contactref" ) {
      bool ok;
      Contactref *o = Contactref::parseElement( e, &ok );
      if ( ok ) result->addContactref( o );
    }
    else if ( e.tagName() == "polygon" ) {
      bool ok;
      Polygon *o = Polygon::parseElement( e, &ok );
      if ( ok ) result->addPolygon( o );
    }
    else if ( e.tagName() == "wire" ) {
      bool ok;
      Wire *o = Wire::parseElement( e, &ok );
      if ( ok ) result->addWire( o );
    }
    else if ( e.tagName() == "via" ) {
      bool ok;
      Via *o = Via::parseElement( e, &ok );
      if ( ok ) result->addVia( o );
    }
  }

  result->setName( element.attribute( "name" ) );
  if (element.hasAttribute("class"))
    result->setClass( element.attribute( "class" ).toInt() );
  if (element.hasAttribute("airwireshidden"))  {
    AirwireshiddenEnum airwireshidden = airwireshiddenEnumFromString( element.attribute( "airwireshidden" ), ok  );
    if (ok && !(*ok)) {
      qCritical() << "Invalid string: \"" << element.attribute( "airwireshidden" ) << "\" in the \"airwireshidden\" element";
      return nullptr;
    } else {
      result->setAirwireshidden( airwireshidden );
    }
  } else {
    // default value
    result->setAirwireshidden(Airwireshidden_no);
  }

  if ( ok ) *ok = true;
  return result;
}

void Signal::writeElement( QXmlStreamWriter &xml ) const
{
  xml.writeStartElement( "signal" );
  if (!mName.isEmpty())
    xml.writeAttribute("name", mName );
  if (mClass_set)
    xml.writeAttribute("class", QString::number( mClass ) );
  if (mAirwireshidden != Airwireshidden_Invalid)
    xml.writeAttribute("airwireshidden", airwireshiddenEnumToString(mAirwireshidden));
  foreach( Contactref* e, mContactrefList ) {
    if (e)
      e->writeElement( xml );
  }
  foreach( Polygon* e, mPolygonList ) {
    if (e)
      e->writeElement( xml );
  }
  foreach( Wire* e, mWireList ) {
    if (e)
      e->writeElement( xml );
  }
  foreach( Via* e, mViaList ) {
    if (e)
      e->writeElement( xml );
  }
  xml.writeEndElement();
}


Signals::Signals()
{
}

Signals::~Signals()
{
}

void Signals::addSignal( Signal* v )
{
  mSignalList.append( v );
}

void Signals::setSignalList( const Signal::List &v )
{
  mSignalList = v;
}

Signal::List *Signals::signalList()
{
  return &mSignalList;
}

Signals *Signals::parseElement( const QDomElement &element, bool *ok )
{
  if ( element.tagName() != "signals" ) {
    qCritical() << "Expected 'signals', got '" << element.tagName() << "'.";
    if ( ok ) *ok = false;
    return nullptr;
  }

  Signals* result = new Signals();

  QDomNode n;
  for( n = element.firstChild(); !n.isNull(); n = n.nextSibling() ) {
    QDomElement e = n.toElement();
    if ( e.tagName() == "signal" ) {
      bool ok;
      Signal *o = Signal::parseElement( e, &ok );
      if ( ok ) result->addSignal( o );
    }
  }


  if ( ok ) *ok = true;
  return result;
}

void Signals::writeElement( QXmlStreamWriter &xml ) const
{
  if ( !mSignalList.isEmpty() ) {
    xml.writeStartElement( "signals" );
    foreach( Signal* e, mSignalList ) {
      if (e)
        e->writeElement( xml );
    }
    xml.writeEndElement();
  }
}


Attribute::Attribute()
  : mX(0.0), mX_set(false), mY(0.0), mY_set(false), mSize(0.0), mSize_set(false), mLayer(0), mLayer_set(false), mFont(Font_Invalid), mRatio(0), mRatio_set(false), mDisplay(Display_Invalid), mConstant(Constant_Invalid), mAlign(Align_Invalid)
{
}

Attribute::~Attribute()
{
}

void Attribute::setName( const QString &v )
{
  mName = v;
}

QString Attribute::name() const
{
  return mName;
}

void Attribute::setValue( const QString &v )
{
  mValue = v;
}

QString Attribute::value() const
{
  return mValue;
}

void Attribute::setX( const double v )
{
  mX_set = true;
  mX = v;
}

double Attribute::x() const
{
  return mX;
}

bool Attribute::xSet() const
{
  return mX_set;
}

void Attribute::setY( const double v )
{
  mY_set = true;
  mY = v;
}

double Attribute::y() const
{
  return mY;
}

bool Attribute::ySet() const
{
  return mY_set;
}

void Attribute::setSize( const double v )
{
  mSize_set = true;
  mSize = v;
}

double Attribute::size() const
{
  return mSize;
}

bool Attribute::sizeSet() const
{
  return mSize_set;
}

void Attribute::setLayer( const int v )
{
  mLayer_set = true;
  mLayer = v;
}

int Attribute::layer() const
{
  return mLayer;
}

bool Attribute::layerSet() const
{
  return mLayer_set;
}

void Attribute::setFont( const FontEnum &v )
{
  mFont = v;
}

Attribute::FontEnum Attribute::font() const
{
  return mFont;
}

void Attribute::setRatio( const int v )
{
  mRatio_set = true;
  mRatio = v;
}

int Attribute::ratio() const
{
  return mRatio;
}

bool Attribute::ratioSet() const
{
  return mRatio_set;
}

void Attribute::setRot( const QString &v )
{
  mRot = v;
}

QString Attribute::rot() const
{
  return mRot;
}

void Attribute::setDisplay( const DisplayEnum &v )
{
  mDisplay = v;
}

Attribute::DisplayEnum Attribute::display() const
{
  return mDisplay;
}

void Attribute::setConstant( const ConstantEnum &v )
{
  mConstant = v;
}

Attribute::ConstantEnum Attribute::constant() const
{
  return mConstant;
}

void Attribute::setAlign( const AlignEnum &v )
{
  mAlign = v;
}

Attribute::AlignEnum Attribute::align() const
{
  return mAlign;
}

Attribute::FontEnum Attribute::fontEnumFromString( const QString & v, bool *ok )
{
  if (ok) *ok = true;

  if ( v == "vector" ) {
    return Font_vector;
  } else if ( v == "proportional" ) {
    return Font_proportional;
  } else if ( v == "fixed" ) {
    return Font_fixed;
  } else {
    if (ok) *ok = false;
    return Font_Invalid;
  }

  return Font_Invalid;
}

QString Attribute::fontEnumToString( const FontEnum & v )
{
  switch( v ) {
  case Font_vector: return "vector";
  case Font_proportional: return "proportional";
  case Font_fixed: return "fixed";
  case Font_Invalid:
  default:
    qCritical() << "Unable to serialize a(n) FontEnum enum because it has invalid value:" << v;
    return QString();
  }
}

Attribute::DisplayEnum Attribute::displayEnumFromString( const QString & v, bool *ok )
{
  if (ok) *ok = true;

  if ( v == "off" ) {
    return Display_off;
  } else if ( v == "value" ) {
    return Display_value;
  } else if ( v == "name" ) {
    return Display_name;
  } else if ( v == "both" ) {
    return Display_both;
  } else {
    if (ok) *ok = false;
    return Display_Invalid;
  }

  return Display_Invalid;
}

QString Attribute::displayEnumToString( const DisplayEnum & v )
{
  switch( v ) {
  case Display_off: return "off";
  case Display_value: return "value";
  case Display_name: return "name";
  case Display_both: return "both";
  case Display_Invalid:
  default:
    qCritical() << "Unable to serialize a(n) DisplayEnum enum because it has invalid value:" << v;
    return QString();
  }
}

Attribute::ConstantEnum Attribute::constantEnumFromString( const QString & v, bool *ok )
{
  if (ok) *ok = true;

  if ( v == "no" ) {
    return Constant_no;
  } else if ( v == "yes" ) {
    return Constant_yes;
  } else {
    if (ok) *ok = false;
    return Constant_Invalid;
  }

  return Constant_Invalid;
}

QString Attribute::constantEnumToString( const ConstantEnum & v )
{
  switch( v ) {
  case Constant_no: return "no";
  case Constant_yes: return "yes";
  case Constant_Invalid:
  default:
    qCritical() << "Unable to serialize a(n) ConstantEnum enum because it has invalid value:" << v;
    return QString();
  }
}

Attribute::AlignEnum Attribute::alignEnumFromString( const QString & v, bool *ok )
{
  if (ok) *ok = true;

  if ( v == "bottom-left" ) {
    return Align_bottom_left;
  } else if ( v == "bottom-center" ) {
    return Align_bottom_center;
  } else if ( v == "bottom-right" ) {
    return Align_bottom_right;
  } else if ( v == "center-left" ) {
    return Align_center_left;
  } else if ( v == "center" ) {
    return Align_center;
  } else if ( v == "center-right" ) {
    return Align_center_right;
  } else if ( v == "top-left" ) {
    return Align_top_left;
  } else if ( v == "top-center" ) {
    return Align_top_center;
  } else if ( v == "top-right" ) {
    return Align_top_right;
  } else {
    if (ok) *ok = false;
    return Align_Invalid;
  }

  return Align_Invalid;
}

QString Attribute::alignEnumToString( const AlignEnum & v )
{
  switch( v ) {
  case Align_bottom_left: return "bottom-left";
  case Align_bottom_center: return "bottom-center";
  case Align_bottom_right: return "bottom-right";
  case Align_center_left: return "center-left";
  case Align_center: return "center";
  case Align_center_right: return "center-right";
  case Align_top_left: return "top-left";
  case Align_top_center: return "top-center";
  case Align_top_right: return "top-right";
  case Align_Invalid:
  default:
    qCritical() << "Unable to serialize a(n) AlignEnum enum because it has invalid value:" << v;
    return QString();
  }
}

Attribute *Attribute::parseElement( const QDomElement &element, bool *ok )
{
  if ( element.tagName() != "attribute" ) {
    qCritical() << "Expected 'attribute', got '" << element.tagName() << "'.";
    if ( ok ) *ok = false;
    return nullptr;
  }

  Attribute* result = new Attribute();

  result->setName( element.attribute( "name" ) );
  result->setValue( element.attribute( "value" ) );
  if (element.hasAttribute("x"))
    result->setX( element.attribute( "x" ).toDouble() );
  if (element.hasAttribute("y"))
    result->setY( element.attribute( "y" ).toDouble() );
  if (element.hasAttribute("size"))
    result->setSize( element.attribute( "size" ).toDouble() );
  if (element.hasAttribute("layer"))
    result->setLayer( element.attribute( "layer" ).toInt() );
  if (element.hasAttribute("font"))  {
    FontEnum font = fontEnumFromString( element.attribute( "font" ), ok  );
    if (ok && !(*ok)) {
      qCritical() << "Invalid string: \"" << element.attribute( "font" ) << "\" in the \"font\" element";
      return nullptr;
    } else {
      result->setFont( font );
    }
  } else {
    result->setFont(Font_Invalid);
  }
  if (element.hasAttribute("ratio"))
    result->setRatio( element.attribute( "ratio" ).toInt() );
  result->setRot( element.attribute( "rot" ) );
  if (element.hasAttribute("display"))  {
    DisplayEnum display = displayEnumFromString( element.attribute( "display" ), ok  );
    if (ok && !(*ok)) {
      qCritical() << "Invalid string: \"" << element.attribute( "display" ) << "\" in the \"display\" element";
      return nullptr;
    } else {
      result->setDisplay( display );
    }
  } else {
    // default value
    result->setDisplay(Display_value);
  }
  if (element.hasAttribute("constant"))  {
    ConstantEnum constant = constantEnumFromString( element.attribute( "constant" ), ok  );
    if (ok && !(*ok)) {
      qCritical() << "Invalid string: \"" << element.attribute( "constant" ) << "\" in the \"constant\" element";
      return nullptr;
    } else {
      result->setConstant( constant );
    }
  } else {
    // default value
    result->setConstant(Constant_no);
  }
  if (element.hasAttribute("align"))  {
    AlignEnum align = alignEnumFromString( element.attribute( "align" ), ok  );
    if (ok && !(*ok)) {
      qCritical() << "Invalid string: \"" << element.attribute( "align" ) << "\" in the \"align\" element";
      return nullptr;
    } else {
      result->setAlign( align );
    }
  } else {
    // default value
    result->setAlign(Align_bottom-left);
  }

  if ( ok ) *ok = true;
  return result;
}

void Attribute::writeElement( QXmlStreamWriter &xml ) const
{
  xml.writeStartElement( "attribute" );
  if (!mName.isEmpty())
    xml.writeAttribute("name", mName );
  if (!mValue.isEmpty())
    xml.writeAttribute("value", mValue );
  if (mX_set)
    xml.writeAttribute("x", QString::number( mX ) );
  if (mY_set)
    xml.writeAttribute("y", QString::number( mY ) );
  if (mSize_set)
    xml.writeAttribute("size", QString::number( mSize ) );
  if (mLayer_set)
    xml.writeAttribute("layer", QString::number( mLayer ) );
  if (mFont != Font_Invalid)
    xml.writeAttribute("font", fontEnumToString(mFont));
  if (mRatio_set)
    xml.writeAttribute("ratio", QString::number( mRatio ) );
  if (!mRot.isEmpty())
    xml.writeAttribute("rot", mRot );
  if (mDisplay != Display_Invalid)
    xml.writeAttribute("display", displayEnumToString(mDisplay));
  if (mConstant != Constant_Invalid)
    xml.writeAttribute("constant", constantEnumToString(mConstant));
  if (mAlign != Align_Invalid)
    xml.writeAttribute("align", alignEnumToString(mAlign));
  xml.writeEndElement();
}


Variant::Variant()
  : mPopulate(Populate_Invalid)
{
}

Variant::~Variant()
{
}

void Variant::setName( const QString &v )
{
  mName = v;
}

QString Variant::name() const
{
  return mName;
}

void Variant::setPopulate( const PopulateEnum &v )
{
  mPopulate = v;
}

Variant::PopulateEnum Variant::populate() const
{
  return mPopulate;
}

void Variant::setValue( const QString &v )
{
  mValue = v;
}

QString Variant::value() const
{
  return mValue;
}

void Variant::setTechnology( const QString &v )
{
  mTechnology = v;
}

QString Variant::technology() const
{
  return mTechnology;
}

Variant::PopulateEnum Variant::populateEnumFromString( const QString & v, bool *ok )
{
  if (ok) *ok = true;

  if ( v == "no" ) {
    return Populate_no;
  } else if ( v == "yes" ) {
    return Populate_yes;
  } else {
    if (ok) *ok = false;
    return Populate_Invalid;
  }

  return Populate_Invalid;
}

QString Variant::populateEnumToString( const PopulateEnum & v )
{
  switch( v ) {
  case Populate_no: return "no";
  case Populate_yes: return "yes";
  case Populate_Invalid:
  default:
    qCritical() << "Unable to serialize a(n) PopulateEnum enum because it has invalid value:" << v;
    return QString();
  }
}

Variant *Variant::parseElement( const QDomElement &element, bool *ok )
{
  if ( element.tagName() != "variant" ) {
    qCritical() << "Expected 'variant', got '" << element.tagName() << "'.";
    if ( ok ) *ok = false;
    return nullptr;
  }

  Variant* result = new Variant();

  result->setName( element.attribute( "name" ) );
  if (element.hasAttribute("populate"))  {
    PopulateEnum populate = populateEnumFromString( element.attribute( "populate" ), ok  );
    if (ok && !(*ok)) {
      qCritical() << "Invalid string: \"" << element.attribute( "populate" ) << "\" in the \"populate\" element";
      return nullptr;
    } else {
      result->setPopulate( populate );
    }
  } else {
    // default value
    result->setPopulate(Populate_yes);
  }
  result->setValue( element.attribute( "value" ) );
  result->setTechnology( element.attribute( "technology" ) );

  if ( ok ) *ok = true;
  return result;
}

void Variant::writeElement( QXmlStreamWriter &xml ) const
{
  xml.writeStartElement( "variant" );
  if (!mName.isEmpty())
    xml.writeAttribute("name", mName );
  if (mPopulate != Populate_Invalid)
    xml.writeAttribute("populate", populateEnumToString(mPopulate));
  if (!mValue.isEmpty())
    xml.writeAttribute("value", mValue );
  if (!mTechnology.isEmpty())
    xml.writeAttribute("technology", mTechnology );
  xml.writeEndElement();
}


Element::Element()
  : mX(0.0), mX_set(false), mY(0.0), mY_set(false), mLocked(Locked_Invalid), mPopulate(Populate_Invalid), mSmashed(Smashed_Invalid)
{
}

Element::~Element()
{
}

void Element::setName( const QString &v )
{
  mName = v;
}

QString Element::name() const
{
  return mName;
}

void Element::setLibrary( const QString &v )
{
  mLibrary = v;
}

QString Element::library() const
{
  return mLibrary;
}

void Element::setLibraryUrn( const QString &v )
{
  mLibraryUrn = v;
}

QString Element::libraryUrn() const
{
  return mLibraryUrn;
}

void Element::setPackage( const QString &v )
{
  mPackage = v;
}

QString Element::package() const
{
  return mPackage;
}

void Element::setPackage3dUrn( const QString &v )
{
  mPackage3dUrn = v;
}

QString Element::package3dUrn() const
{
  return mPackage3dUrn;
}

void Element::setValue( const QString &v )
{
  mValue = v;
}

QString Element::value() const
{
  return mValue;
}

void Element::setX( const double v )
{
  mX_set = true;
  mX = v;
}

double Element::x() const
{
  return mX;
}

bool Element::xSet() const
{
  return mX_set;
}

void Element::setY( const double v )
{
  mY_set = true;
  mY = v;
}

double Element::y() const
{
  return mY;
}

bool Element::ySet() const
{
  return mY_set;
}

void Element::setLocked( const LockedEnum &v )
{
  mLocked = v;
}

Element::LockedEnum Element::locked() const
{
  return mLocked;
}

void Element::setPopulate( const PopulateEnum &v )
{
  mPopulate = v;
}

Element::PopulateEnum Element::populate() const
{
  return mPopulate;
}

void Element::setSmashed( const SmashedEnum &v )
{
  mSmashed = v;
}

Element::SmashedEnum Element::smashed() const
{
  return mSmashed;
}

void Element::setRot( const QString &v )
{
  mRot = v;
}

QString Element::rot() const
{
  return mRot;
}

void Element::addAttribute( Attribute* v )
{
  mAttributeList.append( v );
}

void Element::setAttributeList( const Attribute::List &v )
{
  mAttributeList = v;
}

Attribute::List *Element::attributeList()
{
  return &mAttributeList;
}

void Element::addVariant( Variant* v )
{
  mVariantList.append( v );
}

void Element::setVariantList( const Variant::List &v )
{
  mVariantList = v;
}

Variant::List *Element::variantList()
{
  return &mVariantList;
}

Element::LockedEnum Element::lockedEnumFromString( const QString & v, bool *ok )
{
  if (ok) *ok = true;

  if ( v == "no" ) {
    return Locked_no;
  } else if ( v == "yes" ) {
    return Locked_yes;
  } else {
    if (ok) *ok = false;
    return Locked_Invalid;
  }

  return Locked_Invalid;
}

QString Element::lockedEnumToString( const LockedEnum & v )
{
  switch( v ) {
  case Locked_no: return "no";
  case Locked_yes: return "yes";
  case Locked_Invalid:
  default:
    qCritical() << "Unable to serialize a(n) LockedEnum enum because it has invalid value:" << v;
    return QString();
  }
}

Element::PopulateEnum Element::populateEnumFromString( const QString & v, bool *ok )
{
  if (ok) *ok = true;

  if ( v == "no" ) {
    return Populate_no;
  } else if ( v == "yes" ) {
    return Populate_yes;
  } else {
    if (ok) *ok = false;
    return Populate_Invalid;
  }

  return Populate_Invalid;
}

QString Element::populateEnumToString( const PopulateEnum & v )
{
  switch( v ) {
  case Populate_no: return "no";
  case Populate_yes: return "yes";
  case Populate_Invalid:
  default:
    qCritical() << "Unable to serialize a(n) PopulateEnum enum because it has invalid value:" << v;
    return QString();
  }
}

Element::SmashedEnum Element::smashedEnumFromString( const QString & v, bool *ok )
{
  if (ok) *ok = true;

  if ( v == "no" ) {
    return Smashed_no;
  } else if ( v == "yes" ) {
    return Smashed_yes;
  } else {
    if (ok) *ok = false;
    return Smashed_Invalid;
  }

  return Smashed_Invalid;
}

QString Element::smashedEnumToString( const SmashedEnum & v )
{
  switch( v ) {
  case Smashed_no: return "no";
  case Smashed_yes: return "yes";
  case Smashed_Invalid:
  default:
    qCritical() << "Unable to serialize a(n) SmashedEnum enum because it has invalid value:" << v;
    return QString();
  }
}

Element *Element::parseElement( const QDomElement &element, bool *ok )
{
  if ( element.tagName() != "element" ) {
    qCritical() << "Expected 'element', got '" << element.tagName() << "'.";
    if ( ok ) *ok = false;
    return nullptr;
  }

  Element* result = new Element();

  QDomNode n;
  for( n = element.firstChild(); !n.isNull(); n = n.nextSibling() ) {
    QDomElement e = n.toElement();
    if ( e.tagName() == "attribute" ) {
      bool ok;
      Attribute *o = Attribute::parseElement( e, &ok );
      if ( ok ) result->addAttribute( o );
    }
    else if ( e.tagName() == "variant" ) {
      bool ok;
      Variant *o = Variant::parseElement( e, &ok );
      if ( ok ) result->addVariant( o );
    }
  }

  result->setName( element.attribute( "name" ) );
  result->setLibrary( element.attribute( "library" ) );
  result->setLibraryUrn( element.attribute( "library_urn" ) );
  result->setPackage( element.attribute( "package" ) );
  result->setPackage3dUrn( element.attribute( "package3d_urn" ) );
  result->setValue( element.attribute( "value" ) );
  if (element.hasAttribute("x"))
    result->setX( element.attribute( "x" ).toDouble() );
  if (element.hasAttribute("y"))
    result->setY( element.attribute( "y" ).toDouble() );
  if (element.hasAttribute("locked"))  {
    LockedEnum locked = lockedEnumFromString( element.attribute( "locked" ), ok  );
    if (ok && !(*ok)) {
      qCritical() << "Invalid string: \"" << element.attribute( "locked" ) << "\" in the \"locked\" element";
      return nullptr;
    } else {
      result->setLocked( locked );
    }
  } else {
    // default value
    result->setLocked(Locked_no);
  }
  if (element.hasAttribute("populate"))  {
    PopulateEnum populate = populateEnumFromString( element.attribute( "populate" ), ok  );
    if (ok && !(*ok)) {
      qCritical() << "Invalid string: \"" << element.attribute( "populate" ) << "\" in the \"populate\" element";
      return nullptr;
    } else {
      result->setPopulate( populate );
    }
  } else {
    // default value
    result->setPopulate(Populate_yes);
  }
  if (element.hasAttribute("smashed"))  {
    SmashedEnum smashed = smashedEnumFromString( element.attribute( "smashed" ), ok  );
    if (ok && !(*ok)) {
      qCritical() << "Invalid string: \"" << element.attribute( "smashed" ) << "\" in the \"smashed\" element";
      return nullptr;
    } else {
      result->setSmashed( smashed );
    }
  } else {
    // default value
    result->setSmashed(Smashed_no);
  }
  result->setRot( element.attribute( "rot" ) );

  if ( ok ) *ok = true;
  return result;
}

void Element::writeElement( QXmlStreamWriter &xml ) const
{
  xml.writeStartElement( "element" );
  if (!mName.isEmpty())
    xml.writeAttribute("name", mName );
  if (!mLibrary.isEmpty())
    xml.writeAttribute("library", mLibrary );
  if (!mLibraryUrn.isEmpty())
    xml.writeAttribute("library_urn", mLibraryUrn );
  if (!mPackage.isEmpty())
    xml.writeAttribute("package", mPackage );
  if (!mPackage3dUrn.isEmpty())
    xml.writeAttribute("package3d_urn", mPackage3dUrn );
  if (!mValue.isEmpty())
    xml.writeAttribute("value", mValue );
  if (mX_set)
    xml.writeAttribute("x", QString::number( mX ) );
  if (mY_set)
    xml.writeAttribute("y", QString::number( mY ) );
  if (mLocked != Locked_Invalid)
    xml.writeAttribute("locked", lockedEnumToString(mLocked));
  if (mPopulate != Populate_Invalid)
    xml.writeAttribute("populate", populateEnumToString(mPopulate));
  if (mSmashed != Smashed_Invalid)
    xml.writeAttribute("smashed", smashedEnumToString(mSmashed));
  if (!mRot.isEmpty())
    xml.writeAttribute("rot", mRot );
  foreach( Attribute* e, mAttributeList ) {
    if (e)
      e->writeElement( xml );
  }
  foreach( Variant* e, mVariantList ) {
    if (e)
      e->writeElement( xml );
  }
  xml.writeEndElement();
}


Elements::Elements()
{
}

Elements::~Elements()
{
}

void Elements::addElement( Element* v )
{
  mElementList.append( v );
}

void Elements::setElementList( const Element::List &v )
{
  mElementList = v;
}

Element::List *Elements::elementList()
{
  return &mElementList;
}

Elements *Elements::parseElement( const QDomElement &element, bool *ok )
{
  if ( element.tagName() != "elements" ) {
    qCritical() << "Expected 'elements', got '" << element.tagName() << "'.";
    if ( ok ) *ok = false;
    return nullptr;
  }

  Elements* result = new Elements();

  QDomNode n;
  for( n = element.firstChild(); !n.isNull(); n = n.nextSibling() ) {
    QDomElement e = n.toElement();
    if ( e.tagName() == "element" ) {
      bool ok;
      Element *o = Element::parseElement( e, &ok );
      if ( ok ) result->addElement( o );
    }
  }


  if ( ok ) *ok = true;
  return result;
}

void Elements::writeElement( QXmlStreamWriter &xml ) const
{
  if ( !mElementList.isEmpty() ) {
    xml.writeStartElement( "elements" );
    foreach( Element* e, mElementList ) {
      if (e)
        e->writeElement( xml );
    }
    xml.writeEndElement();
  }
}


Param::Param()
{
}

Param::~Param()
{
}

void Param::setName( const QString &v )
{
  mName = v;
}

QString Param::name() const
{
  return mName;
}

void Param::setValue( const QString &v )
{
  mValue = v;
}

QString Param::value() const
{
  return mValue;
}

Param *Param::parseElement( const QDomElement &element, bool *ok )
{
  if ( element.tagName() != "param" ) {
    qCritical() << "Expected 'param', got '" << element.tagName() << "'.";
    if ( ok ) *ok = false;
    return nullptr;
  }

  Param* result = new Param();

  result->setName( element.attribute( "name" ) );
  result->setValue( element.attribute( "value" ) );

  if ( ok ) *ok = true;
  return result;
}

void Param::writeElement( QXmlStreamWriter &xml ) const
{
  xml.writeStartElement( "param" );
  if (!mName.isEmpty())
    xml.writeAttribute("name", mName );
  if (!mValue.isEmpty())
    xml.writeAttribute("value", mValue );
  xml.writeEndElement();
}


Pass::Pass()
  : mActive(Active_Invalid)
{
}

Pass::~Pass()
{
}

void Pass::setName( const QString &v )
{
  mName = v;
}

QString Pass::name() const
{
  return mName;
}

void Pass::setRefer( const QString &v )
{
  mRefer = v;
}

QString Pass::refer() const
{
  return mRefer;
}

void Pass::setActive( const ActiveEnum &v )
{
  mActive = v;
}

Pass::ActiveEnum Pass::active() const
{
  return mActive;
}

void Pass::addParam( Param* v )
{
  mParamList.append( v );
}

void Pass::setParamList( const Param::List &v )
{
  mParamList = v;
}

Param::List *Pass::paramList()
{
  return &mParamList;
}

Pass::ActiveEnum Pass::activeEnumFromString( const QString & v, bool *ok )
{
  if (ok) *ok = true;

  if ( v == "no" ) {
    return Active_no;
  } else if ( v == "yes" ) {
    return Active_yes;
  } else {
    if (ok) *ok = false;
    return Active_Invalid;
  }

  return Active_Invalid;
}

QString Pass::activeEnumToString( const ActiveEnum & v )
{
  switch( v ) {
  case Active_no: return "no";
  case Active_yes: return "yes";
  case Active_Invalid:
  default:
    qCritical() << "Unable to serialize a(n) ActiveEnum enum because it has invalid value:" << v;
    return QString();
  }
}

Pass *Pass::parseElement( const QDomElement &element, bool *ok )
{
  if ( element.tagName() != "pass" ) {
    qCritical() << "Expected 'pass', got '" << element.tagName() << "'.";
    if ( ok ) *ok = false;
    return nullptr;
  }

  Pass* result = new Pass();

  QDomNode n;
  for( n = element.firstChild(); !n.isNull(); n = n.nextSibling() ) {
    QDomElement e = n.toElement();
    if ( e.tagName() == "param" ) {
      bool ok;
      Param *o = Param::parseElement( e, &ok );
      if ( ok ) result->addParam( o );
    }
  }

  result->setName( element.attribute( "name" ) );
  result->setRefer( element.attribute( "refer" ) );
  if (element.hasAttribute("active"))  {
    ActiveEnum active = activeEnumFromString( element.attribute( "active" ), ok  );
    if (ok && !(*ok)) {
      qCritical() << "Invalid string: \"" << element.attribute( "active" ) << "\" in the \"active\" element";
      return nullptr;
    } else {
      result->setActive( active );
    }
  } else {
    // default value
    result->setActive(Active_yes);
  }

  if ( ok ) *ok = true;
  return result;
}

void Pass::writeElement( QXmlStreamWriter &xml ) const
{
  xml.writeStartElement( "pass" );
  if (!mName.isEmpty())
    xml.writeAttribute("name", mName );
  if (!mRefer.isEmpty())
    xml.writeAttribute("refer", mRefer );
  if (mActive != Active_Invalid)
    xml.writeAttribute("active", activeEnumToString(mActive));
  foreach( Param* e, mParamList ) {
    if (e)
      e->writeElement( xml );
  }
  xml.writeEndElement();
}


Autorouter::Autorouter()
{
}

Autorouter::~Autorouter()
{
}

void Autorouter::addPass( Pass* v )
{
  mPassList.append( v );
}

void Autorouter::setPassList( const Pass::List &v )
{
  mPassList = v;
}

Pass::List *Autorouter::passList()
{
  return &mPassList;
}

Autorouter *Autorouter::parseElement( const QDomElement &element, bool *ok )
{
  if ( element.tagName() != "autorouter" ) {
    qCritical() << "Expected 'autorouter', got '" << element.tagName() << "'.";
    if ( ok ) *ok = false;
    return nullptr;
  }

  Autorouter* result = new Autorouter();

  QDomNode n;
  for( n = element.firstChild(); !n.isNull(); n = n.nextSibling() ) {
    QDomElement e = n.toElement();
    if ( e.tagName() == "pass" ) {
      bool ok;
      Pass *o = Pass::parseElement( e, &ok );
      if ( ok ) result->addPass( o );
    }
  }


  if ( ok ) *ok = true;
  return result;
}

void Autorouter::writeElement( QXmlStreamWriter &xml ) const
{
  if ( !mPassList.isEmpty() ) {
    xml.writeStartElement( "autorouter" );
    foreach( Pass* e, mPassList ) {
      if (e)
        e->writeElement( xml );
    }
    xml.writeEndElement();
  }
}


Description::Description()
{
}

Description::~Description()
{
}

void Description::setLanguage( const QString &v )
{
  mLanguage = v;
}

QString Description::language() const
{
  return mLanguage;
}

void Description::setValue( const QString &v )
{
  mValue = v;
}

QString Description::value() const
{
  return mValue;
}

Description *Description::parseElement( const QDomElement &element, bool *ok )
{
  if ( element.tagName() != "description" ) {
    qCritical() << "Expected 'description', got '" << element.tagName() << "'.";
    if ( ok ) *ok = false;
    return nullptr;
  }

  Description* result = new Description();

  result->setValue( element.text() );
  result->setLanguage( element.attribute( "language" ) );

  if ( ok ) *ok = true;
  return result;
}

void Description::writeElement( QXmlStreamWriter &xml ) const
{
  if ( !value().isEmpty() ) {
    xml.writeStartElement( "description" );
    if (!mLanguage.isEmpty())
      xml.writeAttribute("language", mLanguage );
    xml.writeCharacters( value() );
    xml.writeEndElement();
  }
}


Designrules::Designrules()
{
}

Designrules::~Designrules()
{
}

void Designrules::setName( const QString &v )
{
  mName = v;
}

QString Designrules::name() const
{
  return mName;
}

void Designrules::addDescription( Description* v )
{
  mDescriptionList.append( v );
}

void Designrules::setDescriptionList( const Description::List &v )
{
  mDescriptionList = v;
}

Description::List *Designrules::descriptionList()
{
  return &mDescriptionList;
}

void Designrules::addParam( Param* v )
{
  mParamList.append( v );
}

void Designrules::setParamList( const Param::List &v )
{
  mParamList = v;
}

Param::List *Designrules::paramList()
{
  return &mParamList;
}

Designrules *Designrules::parseElement( const QDomElement &element, bool *ok )
{
  if ( element.tagName() != "designrules" ) {
    qCritical() << "Expected 'designrules', got '" << element.tagName() << "'.";
    if ( ok ) *ok = false;
    return nullptr;
  }

  Designrules* result = new Designrules();

  QDomNode n;
  for( n = element.firstChild(); !n.isNull(); n = n.nextSibling() ) {
    QDomElement e = n.toElement();
    if ( e.tagName() == "description" ) {
      bool ok;
      Description *o = Description::parseElement( e, &ok );
      if ( ok ) result->addDescription( o );
    }
    else if ( e.tagName() == "param" ) {
      bool ok;
      Param *o = Param::parseElement( e, &ok );
      if ( ok ) result->addParam( o );
    }
  }

  result->setName( element.attribute( "name" ) );

  if ( ok ) *ok = true;
  return result;
}

void Designrules::writeElement( QXmlStreamWriter &xml ) const
{
  xml.writeStartElement( "designrules" );
  if (!mName.isEmpty())
    xml.writeAttribute("name", mName );
  foreach( Description* e, mDescriptionList ) {
    if (e)
      e->writeElement( xml );
  }
  foreach( Param* e, mParamList ) {
    if (e)
      e->writeElement( xml );
  }
  xml.writeEndElement();
}


Fusionsync::Fusionsync()
{
}

Fusionsync::~Fusionsync()
{
}

void Fusionsync::setHuburn( const QString &v )
{
  mHuburn = v;
}

QString Fusionsync::huburn() const
{
  return mHuburn;
}

void Fusionsync::setProjecturn( const QString &v )
{
  mProjecturn = v;
}

QString Fusionsync::projecturn() const
{
  return mProjecturn;
}

void Fusionsync::setF3durn( const QString &v )
{
  mF3durn = v;
}

QString Fusionsync::f3durn() const
{
  return mF3durn;
}

void Fusionsync::setPcbguid( const QString &v )
{
  mPcbguid = v;
}

QString Fusionsync::pcbguid() const
{
  return mPcbguid;
}

void Fusionsync::setLastsyncedchangeguid( const QString &v )
{
  mLastsyncedchangeguid = v;
}

QString Fusionsync::lastsyncedchangeguid() const
{
  return mLastsyncedchangeguid;
}

void Fusionsync::setLastpulledtime( const QString &v )
{
  mLastpulledtime = v;
}

QString Fusionsync::lastpulledtime() const
{
  return mLastpulledtime;
}

Fusionsync *Fusionsync::parseElement( const QDomElement &element, bool *ok )
{
  if ( element.tagName() != "fusionsync" ) {
    qCritical() << "Expected 'fusionsync', got '" << element.tagName() << "'.";
    if ( ok ) *ok = false;
    return nullptr;
  }

  Fusionsync* result = new Fusionsync();

  result->setHuburn( element.attribute( "huburn" ) );
  result->setProjecturn( element.attribute( "projecturn" ) );
  result->setF3durn( element.attribute( "f3durn" ) );
  result->setPcbguid( element.attribute( "pcbguid" ) );
  result->setLastsyncedchangeguid( element.attribute( "lastsyncedchangeguid" ) );
  result->setLastpulledtime( element.attribute( "lastpulledtime" ) );

  if ( ok ) *ok = true;
  return result;
}

void Fusionsync::writeElement( QXmlStreamWriter &xml ) const
{
  xml.writeStartElement( "fusionsync" );
  if (!mHuburn.isEmpty())
    xml.writeAttribute("huburn", mHuburn );
  if (!mProjecturn.isEmpty())
    xml.writeAttribute("projecturn", mProjecturn );
  if (!mF3durn.isEmpty())
    xml.writeAttribute("f3durn", mF3durn );
  if (!mPcbguid.isEmpty())
    xml.writeAttribute("pcbguid", mPcbguid );
  if (!mLastsyncedchangeguid.isEmpty())
    xml.writeAttribute("lastsyncedchangeguid", mLastsyncedchangeguid );
  if (!mLastpulledtime.isEmpty())
    xml.writeAttribute("lastpulledtime", mLastpulledtime );
  xml.writeEndElement();
}


Text::Text()
  : mX(0.0), mX_set(false), mY(0.0), mY_set(false), mSize(0.0), mSize_set(false), mLayer(0), mLayer_set(false), mFont(Font_Invalid), mRatio(0), mRatio_set(false), mAlign(Align_Invalid), mDistance(0), mDistance_set(false)
{
}

Text::~Text()
{
}

void Text::setX( const double v )
{
  mX_set = true;
  mX = v;
}

double Text::x() const
{
  return mX;
}

bool Text::xSet() const
{
  return mX_set;
}

void Text::setY( const double v )
{
  mY_set = true;
  mY = v;
}

double Text::y() const
{
  return mY;
}

bool Text::ySet() const
{
  return mY_set;
}

void Text::setSize( const double v )
{
  mSize_set = true;
  mSize = v;
}

double Text::size() const
{
  return mSize;
}

bool Text::sizeSet() const
{
  return mSize_set;
}

void Text::setLayer( const int v )
{
  mLayer_set = true;
  mLayer = v;
}

int Text::layer() const
{
  return mLayer;
}

bool Text::layerSet() const
{
  return mLayer_set;
}

void Text::setFont( const FontEnum &v )
{
  mFont = v;
}

Text::FontEnum Text::font() const
{
  return mFont;
}

void Text::setRatio( const int v )
{
  mRatio_set = true;
  mRatio = v;
}

int Text::ratio() const
{
  return mRatio;
}

bool Text::ratioSet() const
{
  return mRatio_set;
}

void Text::setRot( const QString &v )
{
  mRot = v;
}

QString Text::rot() const
{
  return mRot;
}

void Text::setAlign( const AlignEnum &v )
{
  mAlign = v;
}

Text::AlignEnum Text::align() const
{
  return mAlign;
}

void Text::setDistance( const int v )
{
  mDistance_set = true;
  mDistance = v;
}

int Text::distance() const
{
  return mDistance;
}

bool Text::distanceSet() const
{
  return mDistance_set;
}

void Text::setValue( const QString &v )
{
  mValue = v;
}

QString Text::value() const
{
  return mValue;
}

Text::FontEnum Text::fontEnumFromString( const QString & v, bool *ok )
{
  if (ok) *ok = true;

  if ( v == "vector" ) {
    return Font_vector;
  } else if ( v == "proportional" ) {
    return Font_proportional;
  } else if ( v == "fixed" ) {
    return Font_fixed;
  } else {
    if (ok) *ok = false;
    return Font_Invalid;
  }

  return Font_Invalid;
}

QString Text::fontEnumToString( const FontEnum & v )
{
  switch( v ) {
  case Font_vector: return "vector";
  case Font_proportional: return "proportional";
  case Font_fixed: return "fixed";
  case Font_Invalid:
  default:
    qCritical() << "Unable to serialize a(n) FontEnum enum because it has invalid value:" << v;
    return QString();
  }
}

Text::AlignEnum Text::alignEnumFromString( const QString & v, bool *ok )
{
  if (ok) *ok = true;

  if ( v == "bottom-left" ) {
    return Align_bottom_left;
  } else if ( v == "bottom-center" ) {
    return Align_bottom_center;
  } else if ( v == "bottom-right" ) {
    return Align_bottom_right;
  } else if ( v == "center-left" ) {
    return Align_center_left;
  } else if ( v == "center" ) {
    return Align_center;
  } else if ( v == "center-right" ) {
    return Align_center_right;
  } else if ( v == "top-left" ) {
    return Align_top_left;
  } else if ( v == "top-center" ) {
    return Align_top_center;
  } else if ( v == "top-right" ) {
    return Align_top_right;
  } else {
    if (ok) *ok = false;
    return Align_Invalid;
  }

  return Align_Invalid;
}

QString Text::alignEnumToString( const AlignEnum & v )
{
  switch( v ) {
  case Align_bottom_left: return "bottom-left";
  case Align_bottom_center: return "bottom-center";
  case Align_bottom_right: return "bottom-right";
  case Align_center_left: return "center-left";
  case Align_center: return "center";
  case Align_center_right: return "center-right";
  case Align_top_left: return "top-left";
  case Align_top_center: return "top-center";
  case Align_top_right: return "top-right";
  case Align_Invalid:
  default:
    qCritical() << "Unable to serialize a(n) AlignEnum enum because it has invalid value:" << v;
    return QString();
  }
}

Text *Text::parseElement( const QDomElement &element, bool *ok )
{
  if ( element.tagName() != "text" ) {
    qCritical() << "Expected 'text', got '" << element.tagName() << "'.";
    if ( ok ) *ok = false;
    return nullptr;
  }

  Text* result = new Text();

  result->setValue( element.text() );
  if (element.hasAttribute("x"))
    result->setX( element.attribute( "x" ).toDouble() );
  if (element.hasAttribute("y"))
    result->setY( element.attribute( "y" ).toDouble() );
  if (element.hasAttribute("size"))
    result->setSize( element.attribute( "size" ).toDouble() );
  if (element.hasAttribute("layer"))
    result->setLayer( element.attribute( "layer" ).toInt() );
  if (element.hasAttribute("font"))  {
    FontEnum font = fontEnumFromString( element.attribute( "font" ), ok  );
    if (ok && !(*ok)) {
      qCritical() << "Invalid string: \"" << element.attribute( "font" ) << "\" in the \"font\" element";
      return nullptr;
    } else {
      result->setFont( font );
    }
  } else {
    // default value
    result->setFont(Font_proportional);
  }
  if (element.hasAttribute("ratio"))
    result->setRatio( element.attribute( "ratio" ).toInt() );
  result->setRot( element.attribute( "rot" ) );
  if (element.hasAttribute("align"))  {
    AlignEnum align = alignEnumFromString( element.attribute( "align" ), ok  );
    if (ok && !(*ok)) {
      qCritical() << "Invalid string: \"" << element.attribute( "align" ) << "\" in the \"align\" element";
      return nullptr;
    } else {
      result->setAlign( align );
    }
  } else {
    // default value
    result->setAlign(Align_bottom-left);
  }
  if (element.hasAttribute("distance"))
    result->setDistance( element.attribute( "distance" ).toInt() );

  if ( ok ) *ok = true;
  return result;
}

void Text::writeElement( QXmlStreamWriter &xml ) const
{
  if ( !value().isEmpty() ) {
    xml.writeStartElement( "text" );
    if (mX_set)
      xml.writeAttribute("x", QString::number( mX ) );
    if (mY_set)
      xml.writeAttribute("y", QString::number( mY ) );
    if (mSize_set)
      xml.writeAttribute("size", QString::number( mSize ) );
    if (mLayer_set)
      xml.writeAttribute("layer", QString::number( mLayer ) );
    if (mFont != Font_Invalid)
      xml.writeAttribute("font", fontEnumToString(mFont));
    if (mRatio_set)
      xml.writeAttribute("ratio", QString::number( mRatio ) );
    if (!mRot.isEmpty())
      xml.writeAttribute("rot", mRot );
    if (mAlign != Align_Invalid)
      xml.writeAttribute("align", alignEnumToString(mAlign));
    if (mDistance_set)
      xml.writeAttribute("distance", QString::number( mDistance ) );
    xml.writeCharacters( value() );
    xml.writeEndElement();
  }
}


Dimension::Dimension()
  : mX1(0.0), mX1_set(false), mY1(0.0), mY1_set(false), mX2(0.0), mX2_set(false), mY2(0.0), mY2_set(false), mX3(0.0), mX3_set(false), mY3(0.0), mY3_set(false), mLayer(0), mLayer_set(false), mDtype(Dtype_Invalid), mWidth(0.0), mWidth_set(false), mExtwidth(0.0), mExtwidth_set(false), mExtlength(0.0), mExtlength_set(false), mExtoffset(0.0), mExtoffset_set(false), mTextsize(0.0), mTextsize_set(false), mTextratio(0), mTextratio_set(false), mUnit(Unit_Invalid), mPrecision(0), mPrecision_set(false), mVisible(Visible_Invalid)
{
}

Dimension::~Dimension()
{
}

void Dimension::setX1( const double v )
{
  mX1_set = true;
  mX1 = v;
}

double Dimension::x1() const
{
  return mX1;
}

bool Dimension::x1Set() const
{
  return mX1_set;
}

void Dimension::setY1( const double v )
{
  mY1_set = true;
  mY1 = v;
}

double Dimension::y1() const
{
  return mY1;
}

bool Dimension::y1Set() const
{
  return mY1_set;
}

void Dimension::setX2( const double v )
{
  mX2_set = true;
  mX2 = v;
}

double Dimension::x2() const
{
  return mX2;
}

bool Dimension::x2Set() const
{
  return mX2_set;
}

void Dimension::setY2( const double v )
{
  mY2_set = true;
  mY2 = v;
}

double Dimension::y2() const
{
  return mY2;
}

bool Dimension::y2Set() const
{
  return mY2_set;
}

void Dimension::setX3( const double v )
{
  mX3_set = true;
  mX3 = v;
}

double Dimension::x3() const
{
  return mX3;
}

bool Dimension::x3Set() const
{
  return mX3_set;
}

void Dimension::setY3( const double v )
{
  mY3_set = true;
  mY3 = v;
}

double Dimension::y3() const
{
  return mY3;
}

bool Dimension::y3Set() const
{
  return mY3_set;
}

void Dimension::setLayer( const int v )
{
  mLayer_set = true;
  mLayer = v;
}

int Dimension::layer() const
{
  return mLayer;
}

bool Dimension::layerSet() const
{
  return mLayer_set;
}

void Dimension::setDtype( const DtypeEnum &v )
{
  mDtype = v;
}

Dimension::DtypeEnum Dimension::dtype() const
{
  return mDtype;
}

void Dimension::setWidth( const double v )
{
  mWidth_set = true;
  mWidth = v;
}

double Dimension::width() const
{
  return mWidth;
}

bool Dimension::widthSet() const
{
  return mWidth_set;
}

void Dimension::setExtwidth( const double v )
{
  mExtwidth_set = true;
  mExtwidth = v;
}

double Dimension::extwidth() const
{
  return mExtwidth;
}

bool Dimension::extwidthSet() const
{
  return mExtwidth_set;
}

void Dimension::setExtlength( const double v )
{
  mExtlength_set = true;
  mExtlength = v;
}

double Dimension::extlength() const
{
  return mExtlength;
}

bool Dimension::extlengthSet() const
{
  return mExtlength_set;
}

void Dimension::setExtoffset( const double v )
{
  mExtoffset_set = true;
  mExtoffset = v;
}

double Dimension::extoffset() const
{
  return mExtoffset;
}

bool Dimension::extoffsetSet() const
{
  return mExtoffset_set;
}

void Dimension::setTextsize( const double v )
{
  mTextsize_set = true;
  mTextsize = v;
}

double Dimension::textsize() const
{
  return mTextsize;
}

bool Dimension::textsizeSet() const
{
  return mTextsize_set;
}

void Dimension::setTextratio( const int v )
{
  mTextratio_set = true;
  mTextratio = v;
}

int Dimension::textratio() const
{
  return mTextratio;
}

bool Dimension::textratioSet() const
{
  return mTextratio_set;
}

void Dimension::setUnit( const UnitEnum &v )
{
  mUnit = v;
}

Dimension::UnitEnum Dimension::unit() const
{
  return mUnit;
}

void Dimension::setPrecision( const int v )
{
  mPrecision_set = true;
  mPrecision = v;
}

int Dimension::precision() const
{
  return mPrecision;
}

bool Dimension::precisionSet() const
{
  return mPrecision_set;
}

void Dimension::setVisible( const VisibleEnum &v )
{
  mVisible = v;
}

Dimension::VisibleEnum Dimension::visible() const
{
  return mVisible;
}

Dimension::DtypeEnum Dimension::dtypeEnumFromString( const QString & v, bool *ok )
{
  if (ok) *ok = true;

  if ( v == "parallel" ) {
    return Dtype_parallel;
  } else if ( v == "horizontal" ) {
    return Dtype_horizontal;
  } else if ( v == "vertical" ) {
    return Dtype_vertical;
  } else if ( v == "radius" ) {
    return Dtype_radius;
  } else if ( v == "diameter" ) {
    return Dtype_diameter;
  } else if ( v == "leader" ) {
    return Dtype_leader;
  } else {
    if (ok) *ok = false;
    return Dtype_Invalid;
  }

  return Dtype_Invalid;
}

QString Dimension::dtypeEnumToString( const DtypeEnum & v )
{
  switch( v ) {
  case Dtype_parallel: return "parallel";
  case Dtype_horizontal: return "horizontal";
  case Dtype_vertical: return "vertical";
  case Dtype_radius: return "radius";
  case Dtype_diameter: return "diameter";
  case Dtype_leader: return "leader";
  case Dtype_Invalid:
  default:
    qCritical() << "Unable to serialize a(n) DtypeEnum enum because it has invalid value:" << v;
    return QString();
  }
}

Dimension::UnitEnum Dimension::unitEnumFromString( const QString & v, bool *ok )
{
  if (ok) *ok = true;

  if ( v == "mic" ) {
    return Unit_mic;
  } else if ( v == "mm" ) {
    return Unit_mm;
  } else if ( v == "mil" ) {
    return Unit_mil;
  } else if ( v == "inch" ) {
    return Unit_inch;
  } else {
    if (ok) *ok = false;
    return Unit_Invalid;
  }

  return Unit_Invalid;
}

QString Dimension::unitEnumToString( const UnitEnum & v )
{
  switch( v ) {
  case Unit_mic: return "mic";
  case Unit_mm: return "mm";
  case Unit_mil: return "mil";
  case Unit_inch: return "inch";
  case Unit_Invalid:
  default:
    qCritical() << "Unable to serialize a(n) UnitEnum enum because it has invalid value:" << v;
    return QString();
  }
}

Dimension::VisibleEnum Dimension::visibleEnumFromString( const QString & v, bool *ok )
{
  if (ok) *ok = true;

  if ( v == "no" ) {
    return Visible_no;
  } else if ( v == "yes" ) {
    return Visible_yes;
  } else {
    if (ok) *ok = false;
    return Visible_Invalid;
  }

  return Visible_Invalid;
}

QString Dimension::visibleEnumToString( const VisibleEnum & v )
{
  switch( v ) {
  case Visible_no: return "no";
  case Visible_yes: return "yes";
  case Visible_Invalid:
  default:
    qCritical() << "Unable to serialize a(n) VisibleEnum enum because it has invalid value:" << v;
    return QString();
  }
}

Dimension *Dimension::parseElement( const QDomElement &element, bool *ok )
{
  if ( element.tagName() != "dimension" ) {
    qCritical() << "Expected 'dimension', got '" << element.tagName() << "'.";
    if ( ok ) *ok = false;
    return nullptr;
  }

  Dimension* result = new Dimension();

  if (element.hasAttribute("x1"))
    result->setX1( element.attribute( "x1" ).toDouble() );
  if (element.hasAttribute("y1"))
    result->setY1( element.attribute( "y1" ).toDouble() );
  if (element.hasAttribute("x2"))
    result->setX2( element.attribute( "x2" ).toDouble() );
  if (element.hasAttribute("y2"))
    result->setY2( element.attribute( "y2" ).toDouble() );
  if (element.hasAttribute("x3"))
    result->setX3( element.attribute( "x3" ).toDouble() );
  if (element.hasAttribute("y3"))
    result->setY3( element.attribute( "y3" ).toDouble() );
  if (element.hasAttribute("layer"))
    result->setLayer( element.attribute( "layer" ).toInt() );
  if (element.hasAttribute("dtype"))  {
    DtypeEnum dtype = dtypeEnumFromString( element.attribute( "dtype" ), ok  );
    if (ok && !(*ok)) {
      qCritical() << "Invalid string: \"" << element.attribute( "dtype" ) << "\" in the \"dtype\" element";
      return nullptr;
    } else {
      result->setDtype( dtype );
    }
  } else {
    // default value
    result->setDtype(Dtype_parallel);
  }
  if (element.hasAttribute("width"))
    result->setWidth( element.attribute( "width" ).toDouble() );
  if (element.hasAttribute("extwidth"))
    result->setExtwidth( element.attribute( "extwidth" ).toDouble() );
  if (element.hasAttribute("extlength"))
    result->setExtlength( element.attribute( "extlength" ).toDouble() );
  if (element.hasAttribute("extoffset"))
    result->setExtoffset( element.attribute( "extoffset" ).toDouble() );
  if (element.hasAttribute("textsize"))
    result->setTextsize( element.attribute( "textsize" ).toDouble() );
  if (element.hasAttribute("textratio"))
    result->setTextratio( element.attribute( "textratio" ).toInt() );
  if (element.hasAttribute("unit"))  {
    UnitEnum unit = unitEnumFromString( element.attribute( "unit" ), ok  );
    if (ok && !(*ok)) {
      qCritical() << "Invalid string: \"" << element.attribute( "unit" ) << "\" in the \"unit\" element";
      return nullptr;
    } else {
      result->setUnit( unit );
    }
  } else {
    // default value
    result->setUnit(Unit_mm);
  }
  if (element.hasAttribute("precision"))
    result->setPrecision( element.attribute( "precision" ).toInt() );
  if (element.hasAttribute("visible"))  {
    VisibleEnum visible = visibleEnumFromString( element.attribute( "visible" ), ok  );
    if (ok && !(*ok)) {
      qCritical() << "Invalid string: \"" << element.attribute( "visible" ) << "\" in the \"visible\" element";
      return nullptr;
    } else {
      result->setVisible( visible );
    }
  } else {
    // default value
    result->setVisible(Visible_no);
  }

  if ( ok ) *ok = true;
  return result;
}

void Dimension::writeElement( QXmlStreamWriter &xml ) const
{
  xml.writeStartElement( "dimension" );
  if (mX1_set)
    xml.writeAttribute("x1", QString::number( mX1 ) );
  if (mY1_set)
    xml.writeAttribute("y1", QString::number( mY1 ) );
  if (mX2_set)
    xml.writeAttribute("x2", QString::number( mX2 ) );
  if (mY2_set)
    xml.writeAttribute("y2", QString::number( mY2 ) );
  if (mX3_set)
    xml.writeAttribute("x3", QString::number( mX3 ) );
  if (mY3_set)
    xml.writeAttribute("y3", QString::number( mY3 ) );
  if (mLayer_set)
    xml.writeAttribute("layer", QString::number( mLayer ) );
  if (mDtype != Dtype_Invalid)
    xml.writeAttribute("dtype", dtypeEnumToString(mDtype));
  if (mWidth_set)
    xml.writeAttribute("width", QString::number( mWidth ) );
  if (mExtwidth_set)
    xml.writeAttribute("extwidth", QString::number( mExtwidth ) );
  if (mExtlength_set)
    xml.writeAttribute("extlength", QString::number( mExtlength ) );
  if (mExtoffset_set)
    xml.writeAttribute("extoffset", QString::number( mExtoffset ) );
  if (mTextsize_set)
    xml.writeAttribute("textsize", QString::number( mTextsize ) );
  if (mTextratio_set)
    xml.writeAttribute("textratio", QString::number( mTextratio ) );
  if (mUnit != Unit_Invalid)
    xml.writeAttribute("unit", unitEnumToString(mUnit));
  if (mPrecision_set)
    xml.writeAttribute("precision", QString::number( mPrecision ) );
  if (mVisible != Visible_Invalid)
    xml.writeAttribute("visible", visibleEnumToString(mVisible));
  xml.writeEndElement();
}


Circle::Circle()
  : mX(0.0), mX_set(false), mY(0.0), mY_set(false), mRadius(0.0), mRadius_set(false), mWidth(0.0), mWidth_set(false), mLayer(0), mLayer_set(false)
{
}

Circle::~Circle()
{
}

void Circle::setX( const double v )
{
  mX_set = true;
  mX = v;
}

double Circle::x() const
{
  return mX;
}

bool Circle::xSet() const
{
  return mX_set;
}

void Circle::setY( const double v )
{
  mY_set = true;
  mY = v;
}

double Circle::y() const
{
  return mY;
}

bool Circle::ySet() const
{
  return mY_set;
}

void Circle::setRadius( const double v )
{
  mRadius_set = true;
  mRadius = v;
}

double Circle::radius() const
{
  return mRadius;
}

bool Circle::radiusSet() const
{
  return mRadius_set;
}

void Circle::setWidth( const double v )
{
  mWidth_set = true;
  mWidth = v;
}

double Circle::width() const
{
  return mWidth;
}

bool Circle::widthSet() const
{
  return mWidth_set;
}

void Circle::setLayer( const int v )
{
  mLayer_set = true;
  mLayer = v;
}

int Circle::layer() const
{
  return mLayer;
}

bool Circle::layerSet() const
{
  return mLayer_set;
}

Circle *Circle::parseElement( const QDomElement &element, bool *ok )
{
  if ( element.tagName() != "circle" ) {
    qCritical() << "Expected 'circle', got '" << element.tagName() << "'.";
    if ( ok ) *ok = false;
    return nullptr;
  }

  Circle* result = new Circle();

  if (element.hasAttribute("x"))
    result->setX( element.attribute( "x" ).toDouble() );
  if (element.hasAttribute("y"))
    result->setY( element.attribute( "y" ).toDouble() );
  if (element.hasAttribute("radius"))
    result->setRadius( element.attribute( "radius" ).toDouble() );
  if (element.hasAttribute("width"))
    result->setWidth( element.attribute( "width" ).toDouble() );
  if (element.hasAttribute("layer"))
    result->setLayer( element.attribute( "layer" ).toInt() );

  if ( ok ) *ok = true;
  return result;
}

void Circle::writeElement( QXmlStreamWriter &xml ) const
{
  xml.writeStartElement( "circle" );
  if (mX_set)
    xml.writeAttribute("x", QString::number( mX ) );
  if (mY_set)
    xml.writeAttribute("y", QString::number( mY ) );
  if (mRadius_set)
    xml.writeAttribute("radius", QString::number( mRadius ) );
  if (mWidth_set)
    xml.writeAttribute("width", QString::number( mWidth ) );
  if (mLayer_set)
    xml.writeAttribute("layer", QString::number( mLayer ) );
  xml.writeEndElement();
}


Rectangle::Rectangle()
  : mX1(0.0), mX1_set(false), mY1(0.0), mY1_set(false), mX2(0.0), mX2_set(false), mY2(0.0), mY2_set(false), mLayer(0), mLayer_set(false)
{
}

Rectangle::~Rectangle()
{
}

void Rectangle::setX1( const double v )
{
  mX1_set = true;
  mX1 = v;
}

double Rectangle::x1() const
{
  return mX1;
}

bool Rectangle::x1Set() const
{
  return mX1_set;
}

void Rectangle::setY1( const double v )
{
  mY1_set = true;
  mY1 = v;
}

double Rectangle::y1() const
{
  return mY1;
}

bool Rectangle::y1Set() const
{
  return mY1_set;
}

void Rectangle::setX2( const double v )
{
  mX2_set = true;
  mX2 = v;
}

double Rectangle::x2() const
{
  return mX2;
}

bool Rectangle::x2Set() const
{
  return mX2_set;
}

void Rectangle::setY2( const double v )
{
  mY2_set = true;
  mY2 = v;
}

double Rectangle::y2() const
{
  return mY2;
}

bool Rectangle::y2Set() const
{
  return mY2_set;
}

void Rectangle::setLayer( const int v )
{
  mLayer_set = true;
  mLayer = v;
}

int Rectangle::layer() const
{
  return mLayer;
}

bool Rectangle::layerSet() const
{
  return mLayer_set;
}

void Rectangle::setRot( const QString &v )
{
  mRot = v;
}

QString Rectangle::rot() const
{
  return mRot;
}

Rectangle *Rectangle::parseElement( const QDomElement &element, bool *ok )
{
  if ( element.tagName() != "rectangle" ) {
    qCritical() << "Expected 'rectangle', got '" << element.tagName() << "'.";
    if ( ok ) *ok = false;
    return nullptr;
  }

  Rectangle* result = new Rectangle();

  if (element.hasAttribute("x1"))
    result->setX1( element.attribute( "x1" ).toDouble() );
  if (element.hasAttribute("y1"))
    result->setY1( element.attribute( "y1" ).toDouble() );
  if (element.hasAttribute("x2"))
    result->setX2( element.attribute( "x2" ).toDouble() );
  if (element.hasAttribute("y2"))
    result->setY2( element.attribute( "y2" ).toDouble() );
  if (element.hasAttribute("layer"))
    result->setLayer( element.attribute( "layer" ).toInt() );
  result->setRot( element.attribute( "rot" ) );

  if ( ok ) *ok = true;
  return result;
}

void Rectangle::writeElement( QXmlStreamWriter &xml ) const
{
  xml.writeStartElement( "rectangle" );
  if (mX1_set)
    xml.writeAttribute("x1", QString::number( mX1 ) );
  if (mY1_set)
    xml.writeAttribute("y1", QString::number( mY1 ) );
  if (mX2_set)
    xml.writeAttribute("x2", QString::number( mX2 ) );
  if (mY2_set)
    xml.writeAttribute("y2", QString::number( mY2 ) );
  if (mLayer_set)
    xml.writeAttribute("layer", QString::number( mLayer ) );
  if (!mRot.isEmpty())
    xml.writeAttribute("rot", mRot );
  xml.writeEndElement();
}


Frame::Frame()
  : mX1(0.0), mX1_set(false), mY1(0.0), mY1_set(false), mX2(0.0), mX2_set(false), mY2(0.0), mY2_set(false), mColumns(0), mColumns_set(false), mRows(0), mRows_set(false), mLayer(0), mLayer_set(false), mBorderLeft(BorderLeft_Invalid), mBorderTop(BorderTop_Invalid), mBorderRight(BorderRight_Invalid), mBorderBottom(BorderBottom_Invalid)
{
}

Frame::~Frame()
{
}

void Frame::setX1( const double v )
{
  mX1_set = true;
  mX1 = v;
}

double Frame::x1() const
{
  return mX1;
}

bool Frame::x1Set() const
{
  return mX1_set;
}

void Frame::setY1( const double v )
{
  mY1_set = true;
  mY1 = v;
}

double Frame::y1() const
{
  return mY1;
}

bool Frame::y1Set() const
{
  return mY1_set;
}

void Frame::setX2( const double v )
{
  mX2_set = true;
  mX2 = v;
}

double Frame::x2() const
{
  return mX2;
}

bool Frame::x2Set() const
{
  return mX2_set;
}

void Frame::setY2( const double v )
{
  mY2_set = true;
  mY2 = v;
}

double Frame::y2() const
{
  return mY2;
}

bool Frame::y2Set() const
{
  return mY2_set;
}

void Frame::setColumns( const int v )
{
  mColumns_set = true;
  mColumns = v;
}

int Frame::columns() const
{
  return mColumns;
}

bool Frame::columnsSet() const
{
  return mColumns_set;
}

void Frame::setRows( const int v )
{
  mRows_set = true;
  mRows = v;
}

int Frame::rows() const
{
  return mRows;
}

bool Frame::rowsSet() const
{
  return mRows_set;
}

void Frame::setLayer( const int v )
{
  mLayer_set = true;
  mLayer = v;
}

int Frame::layer() const
{
  return mLayer;
}

bool Frame::layerSet() const
{
  return mLayer_set;
}

void Frame::setBorderLeft( const BorderLeftEnum &v )
{
  mBorderLeft = v;
}

Frame::BorderLeftEnum Frame::borderLeft() const
{
  return mBorderLeft;
}

void Frame::setBorderTop( const BorderTopEnum &v )
{
  mBorderTop = v;
}

Frame::BorderTopEnum Frame::borderTop() const
{
  return mBorderTop;
}

void Frame::setBorderRight( const BorderRightEnum &v )
{
  mBorderRight = v;
}

Frame::BorderRightEnum Frame::borderRight() const
{
  return mBorderRight;
}

void Frame::setBorderBottom( const BorderBottomEnum &v )
{
  mBorderBottom = v;
}

Frame::BorderBottomEnum Frame::borderBottom() const
{
  return mBorderBottom;
}

Frame::BorderLeftEnum Frame::borderLeftEnumFromString( const QString & v, bool *ok )
{
  if (ok) *ok = true;

  if ( v == "no" ) {
    return BorderLeft_no;
  } else if ( v == "yes" ) {
    return BorderLeft_yes;
  } else {
    if (ok) *ok = false;
    return BorderLeft_Invalid;
  }

  return BorderLeft_Invalid;
}

QString Frame::borderLeftEnumToString( const BorderLeftEnum & v )
{
  switch( v ) {
  case BorderLeft_no: return "no";
  case BorderLeft_yes: return "yes";
  case BorderLeft_Invalid:
  default:
    qCritical() << "Unable to serialize a(n) BorderLeftEnum enum because it has invalid value:" << v;
    return QString();
  }
}

Frame::BorderTopEnum Frame::borderTopEnumFromString( const QString & v, bool *ok )
{
  if (ok) *ok = true;

  if ( v == "no" ) {
    return BorderTop_no;
  } else if ( v == "yes" ) {
    return BorderTop_yes;
  } else {
    if (ok) *ok = false;
    return BorderTop_Invalid;
  }

  return BorderTop_Invalid;
}

QString Frame::borderTopEnumToString( const BorderTopEnum & v )
{
  switch( v ) {
  case BorderTop_no: return "no";
  case BorderTop_yes: return "yes";
  case BorderTop_Invalid:
  default:
    qCritical() << "Unable to serialize a(n) BorderTopEnum enum because it has invalid value:" << v;
    return QString();
  }
}

Frame::BorderRightEnum Frame::borderRightEnumFromString( const QString & v, bool *ok )
{
  if (ok) *ok = true;

  if ( v == "no" ) {
    return BorderRight_no;
  } else if ( v == "yes" ) {
    return BorderRight_yes;
  } else {
    if (ok) *ok = false;
    return BorderRight_Invalid;
  }

  return BorderRight_Invalid;
}

QString Frame::borderRightEnumToString( const BorderRightEnum & v )
{
  switch( v ) {
  case BorderRight_no: return "no";
  case BorderRight_yes: return "yes";
  case BorderRight_Invalid:
  default:
    qCritical() << "Unable to serialize a(n) BorderRightEnum enum because it has invalid value:" << v;
    return QString();
  }
}

Frame::BorderBottomEnum Frame::borderBottomEnumFromString( const QString & v, bool *ok )
{
  if (ok) *ok = true;

  if ( v == "no" ) {
    return BorderBottom_no;
  } else if ( v == "yes" ) {
    return BorderBottom_yes;
  } else {
    if (ok) *ok = false;
    return BorderBottom_Invalid;
  }

  return BorderBottom_Invalid;
}

QString Frame::borderBottomEnumToString( const BorderBottomEnum & v )
{
  switch( v ) {
  case BorderBottom_no: return "no";
  case BorderBottom_yes: return "yes";
  case BorderBottom_Invalid:
  default:
    qCritical() << "Unable to serialize a(n) BorderBottomEnum enum because it has invalid value:" << v;
    return QString();
  }
}

Frame *Frame::parseElement( const QDomElement &element, bool *ok )
{
  if ( element.tagName() != "frame" ) {
    qCritical() << "Expected 'frame', got '" << element.tagName() << "'.";
    if ( ok ) *ok = false;
    return nullptr;
  }

  Frame* result = new Frame();

  if (element.hasAttribute("x1"))
    result->setX1( element.attribute( "x1" ).toDouble() );
  if (element.hasAttribute("y1"))
    result->setY1( element.attribute( "y1" ).toDouble() );
  if (element.hasAttribute("x2"))
    result->setX2( element.attribute( "x2" ).toDouble() );
  if (element.hasAttribute("y2"))
    result->setY2( element.attribute( "y2" ).toDouble() );
  if (element.hasAttribute("columns"))
    result->setColumns( element.attribute( "columns" ).toInt() );
  if (element.hasAttribute("rows"))
    result->setRows( element.attribute( "rows" ).toInt() );
  if (element.hasAttribute("layer"))
    result->setLayer( element.attribute( "layer" ).toInt() );
  if (element.hasAttribute("border-left"))  {
    BorderLeftEnum border_left = borderLeftEnumFromString( element.attribute( "border-left" ), ok  );
    if (ok && !(*ok)) {
      qCritical() << "Invalid string: \"" << element.attribute( "border-left" ) << "\" in the \"border-left\" element";
      return nullptr;
    } else {
      result->setBorderLeft( border_left );
    }
  } else {
    // default value
    result->setBorderLeft(BorderLeft_yes);
  }
  if (element.hasAttribute("border-top"))  {
    BorderTopEnum border_top = borderTopEnumFromString( element.attribute( "border-top" ), ok  );
    if (ok && !(*ok)) {
      qCritical() << "Invalid string: \"" << element.attribute( "border-top" ) << "\" in the \"border-top\" element";
      return nullptr;
    } else {
      result->setBorderTop( border_top );
    }
  } else {
    // default value
    result->setBorderTop(BorderTop_yes);
  }
  if (element.hasAttribute("border-right"))  {
    BorderRightEnum border_right = borderRightEnumFromString( element.attribute( "border-right" ), ok  );
    if (ok && !(*ok)) {
      qCritical() << "Invalid string: \"" << element.attribute( "border-right" ) << "\" in the \"border-right\" element";
      return nullptr;
    } else {
      result->setBorderRight( border_right );
    }
  } else {
    // default value
    result->setBorderRight(BorderRight_yes);
  }
  if (element.hasAttribute("border-bottom"))  {
    BorderBottomEnum border_bottom = borderBottomEnumFromString( element.attribute( "border-bottom" ), ok  );
    if (ok && !(*ok)) {
      qCritical() << "Invalid string: \"" << element.attribute( "border-bottom" ) << "\" in the \"border-bottom\" element";
      return nullptr;
    } else {
      result->setBorderBottom( border_bottom );
    }
  } else {
    // default value
    result->setBorderBottom(BorderBottom_yes);
  }

  if ( ok ) *ok = true;
  return result;
}

void Frame::writeElement( QXmlStreamWriter &xml ) const
{
  xml.writeStartElement( "frame" );
  if (mX1_set)
    xml.writeAttribute("x1", QString::number( mX1 ) );
  if (mY1_set)
    xml.writeAttribute("y1", QString::number( mY1 ) );
  if (mX2_set)
    xml.writeAttribute("x2", QString::number( mX2 ) );
  if (mY2_set)
    xml.writeAttribute("y2", QString::number( mY2 ) );
  if (mColumns_set)
    xml.writeAttribute("columns", QString::number( mColumns ) );
  if (mRows_set)
    xml.writeAttribute("rows", QString::number( mRows ) );
  if (mLayer_set)
    xml.writeAttribute("layer", QString::number( mLayer ) );
  if (mBorderLeft != BorderLeft_Invalid)
    xml.writeAttribute("border-left", borderLeftEnumToString(mBorderLeft));
  if (mBorderTop != BorderTop_Invalid)
    xml.writeAttribute("border-top", borderTopEnumToString(mBorderTop));
  if (mBorderRight != BorderRight_Invalid)
    xml.writeAttribute("border-right", borderRightEnumToString(mBorderRight));
  if (mBorderBottom != BorderBottom_Invalid)
    xml.writeAttribute("border-bottom", borderBottomEnumToString(mBorderBottom));
  xml.writeEndElement();
}


Hole::Hole()
  : mX(0.0), mX_set(false), mY(0.0), mY_set(false), mDrill(0.0), mDrill_set(false)
{
}

Hole::~Hole()
{
}

void Hole::setX( const double v )
{
  mX_set = true;
  mX = v;
}

double Hole::x() const
{
  return mX;
}

bool Hole::xSet() const
{
  return mX_set;
}

void Hole::setY( const double v )
{
  mY_set = true;
  mY = v;
}

double Hole::y() const
{
  return mY;
}

bool Hole::ySet() const
{
  return mY_set;
}

void Hole::setDrill( const double v )
{
  mDrill_set = true;
  mDrill = v;
}

double Hole::drill() const
{
  return mDrill;
}

bool Hole::drillSet() const
{
  return mDrill_set;
}

Hole *Hole::parseElement( const QDomElement &element, bool *ok )
{
  if ( element.tagName() != "hole" ) {
    qCritical() << "Expected 'hole', got '" << element.tagName() << "'.";
    if ( ok ) *ok = false;
    return nullptr;
  }

  Hole* result = new Hole();

  if (element.hasAttribute("x"))
    result->setX( element.attribute( "x" ).toDouble() );
  if (element.hasAttribute("y"))
    result->setY( element.attribute( "y" ).toDouble() );
  if (element.hasAttribute("drill"))
    result->setDrill( element.attribute( "drill" ).toDouble() );

  if ( ok ) *ok = true;
  return result;
}

void Hole::writeElement( QXmlStreamWriter &xml ) const
{
  xml.writeStartElement( "hole" );
  if (mX_set)
    xml.writeAttribute("x", QString::number( mX ) );
  if (mY_set)
    xml.writeAttribute("y", QString::number( mY ) );
  if (mDrill_set)
    xml.writeAttribute("drill", QString::number( mDrill ) );
  xml.writeEndElement();
}


Plain::Plain()
{
}

Plain::~Plain()
{
}

void Plain::addPolygon( Polygon* v )
{
  mPolygonList.append( v );
}

void Plain::setPolygonList( const Polygon::List &v )
{
  mPolygonList = v;
}

Polygon::List *Plain::polygonList()
{
  return &mPolygonList;
}

void Plain::addWire( Wire* v )
{
  mWireList.append( v );
}

void Plain::setWireList( const Wire::List &v )
{
  mWireList = v;
}

Wire::List *Plain::wireList()
{
  return &mWireList;
}

void Plain::addText( Text* v )
{
  mTextList.append( v );
}

void Plain::setTextList( const Text::List &v )
{
  mTextList = v;
}

Text::List *Plain::textList()
{
  return &mTextList;
}

void Plain::addDimension( Dimension* v )
{
  mDimensionList.append( v );
}

void Plain::setDimensionList( const Dimension::List &v )
{
  mDimensionList = v;
}

Dimension::List *Plain::dimensionList()
{
  return &mDimensionList;
}

void Plain::addCircle( Circle* v )
{
  mCircleList.append( v );
}

void Plain::setCircleList( const Circle::List &v )
{
  mCircleList = v;
}

Circle::List *Plain::circleList()
{
  return &mCircleList;
}

void Plain::addRectangle( Rectangle* v )
{
  mRectangleList.append( v );
}

void Plain::setRectangleList( const Rectangle::List &v )
{
  mRectangleList = v;
}

Rectangle::List *Plain::rectangleList()
{
  return &mRectangleList;
}

void Plain::addFrame( Frame* v )
{
  mFrameList.append( v );
}

void Plain::setFrameList( const Frame::List &v )
{
  mFrameList = v;
}

Frame::List *Plain::frameList()
{
  return &mFrameList;
}

void Plain::addHole( Hole* v )
{
  mHoleList.append( v );
}

void Plain::setHoleList( const Hole::List &v )
{
  mHoleList = v;
}

Hole::List *Plain::holeList()
{
  return &mHoleList;
}

Plain *Plain::parseElement( const QDomElement &element, bool *ok )
{
  if ( element.tagName() != "plain" ) {
    qCritical() << "Expected 'plain', got '" << element.tagName() << "'.";
    if ( ok ) *ok = false;
    return nullptr;
  }

  Plain* result = new Plain();

  QDomNode n;
  for( n = element.firstChild(); !n.isNull(); n = n.nextSibling() ) {
    QDomElement e = n.toElement();
    if ( e.tagName() == "polygon" ) {
      bool ok;
      Polygon *o = Polygon::parseElement( e, &ok );
      if ( ok ) result->addPolygon( o );
    }
    else if ( e.tagName() == "wire" ) {
      bool ok;
      Wire *o = Wire::parseElement( e, &ok );
      if ( ok ) result->addWire( o );
    }
    else if ( e.tagName() == "text" ) {
      bool ok;
      Text *o = Text::parseElement( e, &ok );
      if ( ok ) result->addText( o );
    }
    else if ( e.tagName() == "dimension" ) {
      bool ok;
      Dimension *o = Dimension::parseElement( e, &ok );
      if ( ok ) result->addDimension( o );
    }
    else if ( e.tagName() == "circle" ) {
      bool ok;
      Circle *o = Circle::parseElement( e, &ok );
      if ( ok ) result->addCircle( o );
    }
    else if ( e.tagName() == "rectangle" ) {
      bool ok;
      Rectangle *o = Rectangle::parseElement( e, &ok );
      if ( ok ) result->addRectangle( o );
    }
    else if ( e.tagName() == "frame" ) {
      bool ok;
      Frame *o = Frame::parseElement( e, &ok );
      if ( ok ) result->addFrame( o );
    }
    else if ( e.tagName() == "hole" ) {
      bool ok;
      Hole *o = Hole::parseElement( e, &ok );
      if ( ok ) result->addHole( o );
    }
  }


  if ( ok ) *ok = true;
  return result;
}

void Plain::writeElement( QXmlStreamWriter &xml ) const
{
  if ( !mPolygonList.isEmpty() || !mWireList.isEmpty() || !mTextList.isEmpty() || !mDimensionList.isEmpty() || !mCircleList.isEmpty() || !mRectangleList.isEmpty() || !mFrameList.isEmpty() || !mHoleList.isEmpty() ) {
    xml.writeStartElement( "plain" );
    foreach( Polygon* e, mPolygonList ) {
      if (e)
        e->writeElement( xml );
    }
    foreach( Wire* e, mWireList ) {
      if (e)
        e->writeElement( xml );
    }
    foreach( Text* e, mTextList ) {
      if (e)
        e->writeElement( xml );
    }
    foreach( Dimension* e, mDimensionList ) {
      if (e)
        e->writeElement( xml );
    }
    foreach( Circle* e, mCircleList ) {
      if (e)
        e->writeElement( xml );
    }
    foreach( Rectangle* e, mRectangleList ) {
      if (e)
        e->writeElement( xml );
    }
    foreach( Frame* e, mFrameList ) {
      if (e)
        e->writeElement( xml );
    }
    foreach( Hole* e, mHoleList ) {
      if (e)
        e->writeElement( xml );
    }
    xml.writeEndElement();
  }
}


Pad::Pad()
  : mX(0.0), mX_set(false), mY(0.0), mY_set(false), mDrill(0.0), mDrill_set(false), mDiameter(0.0), mDiameter_set(false), mShape(Shape_Invalid), mStop(Stop_Invalid), mThermals(Thermals_Invalid), mFirst(First_Invalid)
{
}

Pad::~Pad()
{
}

void Pad::setName( const QString &v )
{
  mName = v;
}

QString Pad::name() const
{
  return mName;
}

void Pad::setX( const double v )
{
  mX_set = true;
  mX = v;
}

double Pad::x() const
{
  return mX;
}

bool Pad::xSet() const
{
  return mX_set;
}

void Pad::setY( const double v )
{
  mY_set = true;
  mY = v;
}

double Pad::y() const
{
  return mY;
}

bool Pad::ySet() const
{
  return mY_set;
}

void Pad::setDrill( const double v )
{
  mDrill_set = true;
  mDrill = v;
}

double Pad::drill() const
{
  return mDrill;
}

bool Pad::drillSet() const
{
  return mDrill_set;
}

void Pad::setDiameter( const double v )
{
  mDiameter_set = true;
  mDiameter = v;
}

double Pad::diameter() const
{
  return mDiameter;
}

bool Pad::diameterSet() const
{
  return mDiameter_set;
}

void Pad::setShape( const ShapeEnum &v )
{
  mShape = v;
}

Pad::ShapeEnum Pad::shape() const
{
  return mShape;
}

void Pad::setRot( const QString &v )
{
  mRot = v;
}

QString Pad::rot() const
{
  return mRot;
}

void Pad::setStop( const StopEnum &v )
{
  mStop = v;
}

Pad::StopEnum Pad::stop() const
{
  return mStop;
}

void Pad::setThermals( const ThermalsEnum &v )
{
  mThermals = v;
}

Pad::ThermalsEnum Pad::thermals() const
{
  return mThermals;
}

void Pad::setFirst( const FirstEnum &v )
{
  mFirst = v;
}

Pad::FirstEnum Pad::first() const
{
  return mFirst;
}

Pad::ShapeEnum Pad::shapeEnumFromString( const QString & v, bool *ok )
{
  if (ok) *ok = true;

  if ( v == "square" ) {
    return Shape_square;
  } else if ( v == "round" ) {
    return Shape_round;
  } else if ( v == "octagon" ) {
    return Shape_octagon;
  } else if ( v == "long" ) {
    return Shape_long;
  } else if ( v == "offset" ) {
    return Shape_offset;
  } else {
    if (ok) *ok = false;
    return Shape_Invalid;
  }

  return Shape_Invalid;
}

QString Pad::shapeEnumToString( const ShapeEnum & v )
{
  switch( v ) {
  case Shape_square: return "square";
  case Shape_round: return "round";
  case Shape_octagon: return "octagon";
  case Shape_long: return "long";
  case Shape_offset: return "offset";
  case Shape_Invalid:
  default:
    qCritical() << "Unable to serialize a(n) ShapeEnum enum because it has invalid value:" << v;
    return QString();
  }
}

Pad::StopEnum Pad::stopEnumFromString( const QString & v, bool *ok )
{
  if (ok) *ok = true;

  if ( v == "no" ) {
    return Stop_no;
  } else if ( v == "yes" ) {
    return Stop_yes;
  } else {
    if (ok) *ok = false;
    return Stop_Invalid;
  }

  return Stop_Invalid;
}

QString Pad::stopEnumToString( const StopEnum & v )
{
  switch( v ) {
  case Stop_no: return "no";
  case Stop_yes: return "yes";
  case Stop_Invalid:
  default:
    qCritical() << "Unable to serialize a(n) StopEnum enum because it has invalid value:" << v;
    return QString();
  }
}

Pad::ThermalsEnum Pad::thermalsEnumFromString( const QString & v, bool *ok )
{
  if (ok) *ok = true;

  if ( v == "no" ) {
    return Thermals_no;
  } else if ( v == "yes" ) {
    return Thermals_yes;
  } else {
    if (ok) *ok = false;
    return Thermals_Invalid;
  }

  return Thermals_Invalid;
}

QString Pad::thermalsEnumToString( const ThermalsEnum & v )
{
  switch( v ) {
  case Thermals_no: return "no";
  case Thermals_yes: return "yes";
  case Thermals_Invalid:
  default:
    qCritical() << "Unable to serialize a(n) ThermalsEnum enum because it has invalid value:" << v;
    return QString();
  }
}

Pad::FirstEnum Pad::firstEnumFromString( const QString & v, bool *ok )
{
  if (ok) *ok = true;

  if ( v == "no" ) {
    return First_no;
  } else if ( v == "yes" ) {
    return First_yes;
  } else {
    if (ok) *ok = false;
    return First_Invalid;
  }

  return First_Invalid;
}

QString Pad::firstEnumToString( const FirstEnum & v )
{
  switch( v ) {
  case First_no: return "no";
  case First_yes: return "yes";
  case First_Invalid:
  default:
    qCritical() << "Unable to serialize a(n) FirstEnum enum because it has invalid value:" << v;
    return QString();
  }
}

Pad *Pad::parseElement( const QDomElement &element, bool *ok )
{
  if ( element.tagName() != "pad" ) {
    qCritical() << "Expected 'pad', got '" << element.tagName() << "'.";
    if ( ok ) *ok = false;
    return nullptr;
  }

  Pad* result = new Pad();

  result->setName( element.attribute( "name" ) );
  if (element.hasAttribute("x"))
    result->setX( element.attribute( "x" ).toDouble() );
  if (element.hasAttribute("y"))
    result->setY( element.attribute( "y" ).toDouble() );
  if (element.hasAttribute("drill"))
    result->setDrill( element.attribute( "drill" ).toDouble() );
  if (element.hasAttribute("diameter"))
    result->setDiameter( element.attribute( "diameter" ).toDouble() );
  if (element.hasAttribute("shape"))  {
    ShapeEnum shape = shapeEnumFromString( element.attribute( "shape" ), ok  );
    if (ok && !(*ok)) {
      qCritical() << "Invalid string: \"" << element.attribute( "shape" ) << "\" in the \"shape\" element";
      return nullptr;
    } else {
      result->setShape( shape );
    }
  } else {
    // default value
    result->setShape(Shape_round);
  }
  result->setRot( element.attribute( "rot" ) );
  if (element.hasAttribute("stop"))  {
    StopEnum stop = stopEnumFromString( element.attribute( "stop" ), ok  );
    if (ok && !(*ok)) {
      qCritical() << "Invalid string: \"" << element.attribute( "stop" ) << "\" in the \"stop\" element";
      return nullptr;
    } else {
      result->setStop( stop );
    }
  } else {
    // default value
    result->setStop(Stop_yes);
  }
  if (element.hasAttribute("thermals"))  {
    ThermalsEnum thermals = thermalsEnumFromString( element.attribute( "thermals" ), ok  );
    if (ok && !(*ok)) {
      qCritical() << "Invalid string: \"" << element.attribute( "thermals" ) << "\" in the \"thermals\" element";
      return nullptr;
    } else {
      result->setThermals( thermals );
    }
  } else {
    // default value
    result->setThermals(Thermals_yes);
  }
  if (element.hasAttribute("first"))  {
    FirstEnum first = firstEnumFromString( element.attribute( "first" ), ok  );
    if (ok && !(*ok)) {
      qCritical() << "Invalid string: \"" << element.attribute( "first" ) << "\" in the \"first\" element";
      return nullptr;
    } else {
      result->setFirst( first );
    }
  } else {
    // default value
    result->setFirst(First_no);
  }

  if ( ok ) *ok = true;
  return result;
}

void Pad::writeElement( QXmlStreamWriter &xml ) const
{
  xml.writeStartElement( "pad" );
  if (!mName.isEmpty())
    xml.writeAttribute("name", mName );
  if (mX_set)
    xml.writeAttribute("x", QString::number( mX ) );
  if (mY_set)
    xml.writeAttribute("y", QString::number( mY ) );
  if (mDrill_set)
    xml.writeAttribute("drill", QString::number( mDrill ) );
  if (mDiameter_set)
    xml.writeAttribute("diameter", QString::number( mDiameter ) );
  if (mShape != Shape_Invalid)
    xml.writeAttribute("shape", shapeEnumToString(mShape));
  if (!mRot.isEmpty())
    xml.writeAttribute("rot", mRot );
  if (mStop != Stop_Invalid)
    xml.writeAttribute("stop", stopEnumToString(mStop));
  if (mThermals != Thermals_Invalid)
    xml.writeAttribute("thermals", thermalsEnumToString(mThermals));
  if (mFirst != First_Invalid)
    xml.writeAttribute("first", firstEnumToString(mFirst));
  xml.writeEndElement();
}


Smd::Smd()
  : mX(0.0), mX_set(false), mY(0.0), mY_set(false), mDx(0.0), mDx_set(false), mDy(0.0), mDy_set(false), mLayer(0), mLayer_set(false), mRoundness(0), mRoundness_set(false), mStop(Stop_Invalid), mThermals(Thermals_Invalid), mCream(Cream_Invalid)
{
}

Smd::~Smd()
{
}

void Smd::setName( const QString &v )
{
  mName = v;
}

QString Smd::name() const
{
  return mName;
}

void Smd::setX( const double v )
{
  mX_set = true;
  mX = v;
}

double Smd::x() const
{
  return mX;
}

bool Smd::xSet() const
{
  return mX_set;
}

void Smd::setY( const double v )
{
  mY_set = true;
  mY = v;
}

double Smd::y() const
{
  return mY;
}

bool Smd::ySet() const
{
  return mY_set;
}

void Smd::setDx( const double v )
{
  mDx_set = true;
  mDx = v;
}

double Smd::dx() const
{
  return mDx;
}

bool Smd::dxSet() const
{
  return mDx_set;
}

void Smd::setDy( const double v )
{
  mDy_set = true;
  mDy = v;
}

double Smd::dy() const
{
  return mDy;
}

bool Smd::dySet() const
{
  return mDy_set;
}

void Smd::setLayer( const int v )
{
  mLayer_set = true;
  mLayer = v;
}

int Smd::layer() const
{
  return mLayer;
}

bool Smd::layerSet() const
{
  return mLayer_set;
}

void Smd::setRoundness( const int v )
{
  mRoundness_set = true;
  mRoundness = v;
}

int Smd::roundness() const
{
  return mRoundness;
}

bool Smd::roundnessSet() const
{
  return mRoundness_set;
}

void Smd::setRot( const QString &v )
{
  mRot = v;
}

QString Smd::rot() const
{
  return mRot;
}

void Smd::setStop( const StopEnum &v )
{
  mStop = v;
}

Smd::StopEnum Smd::stop() const
{
  return mStop;
}

void Smd::setThermals( const ThermalsEnum &v )
{
  mThermals = v;
}

Smd::ThermalsEnum Smd::thermals() const
{
  return mThermals;
}

void Smd::setCream( const CreamEnum &v )
{
  mCream = v;
}

Smd::CreamEnum Smd::cream() const
{
  return mCream;
}

Smd::StopEnum Smd::stopEnumFromString( const QString & v, bool *ok )
{
  if (ok) *ok = true;

  if ( v == "no" ) {
    return Stop_no;
  } else if ( v == "yes" ) {
    return Stop_yes;
  } else {
    if (ok) *ok = false;
    return Stop_Invalid;
  }

  return Stop_Invalid;
}

QString Smd::stopEnumToString( const StopEnum & v )
{
  switch( v ) {
  case Stop_no: return "no";
  case Stop_yes: return "yes";
  case Stop_Invalid:
  default:
    qCritical() << "Unable to serialize a(n) StopEnum enum because it has invalid value:" << v;
    return QString();
  }
}

Smd::ThermalsEnum Smd::thermalsEnumFromString( const QString & v, bool *ok )
{
  if (ok) *ok = true;

  if ( v == "no" ) {
    return Thermals_no;
  } else if ( v == "yes" ) {
    return Thermals_yes;
  } else {
    if (ok) *ok = false;
    return Thermals_Invalid;
  }

  return Thermals_Invalid;
}

QString Smd::thermalsEnumToString( const ThermalsEnum & v )
{
  switch( v ) {
  case Thermals_no: return "no";
  case Thermals_yes: return "yes";
  case Thermals_Invalid:
  default:
    qCritical() << "Unable to serialize a(n) ThermalsEnum enum because it has invalid value:" << v;
    return QString();
  }
}

Smd::CreamEnum Smd::creamEnumFromString( const QString & v, bool *ok )
{
  if (ok) *ok = true;

  if ( v == "no" ) {
    return Cream_no;
  } else if ( v == "yes" ) {
    return Cream_yes;
  } else {
    if (ok) *ok = false;
    return Cream_Invalid;
  }

  return Cream_Invalid;
}

QString Smd::creamEnumToString( const CreamEnum & v )
{
  switch( v ) {
  case Cream_no: return "no";
  case Cream_yes: return "yes";
  case Cream_Invalid:
  default:
    qCritical() << "Unable to serialize a(n) CreamEnum enum because it has invalid value:" << v;
    return QString();
  }
}

Smd *Smd::parseElement( const QDomElement &element, bool *ok )
{
  if ( element.tagName() != "smd" ) {
    qCritical() << "Expected 'smd', got '" << element.tagName() << "'.";
    if ( ok ) *ok = false;
    return nullptr;
  }

  Smd* result = new Smd();

  result->setName( element.attribute( "name" ) );
  if (element.hasAttribute("x"))
    result->setX( element.attribute( "x" ).toDouble() );
  if (element.hasAttribute("y"))
    result->setY( element.attribute( "y" ).toDouble() );
  if (element.hasAttribute("dx"))
    result->setDx( element.attribute( "dx" ).toDouble() );
  if (element.hasAttribute("dy"))
    result->setDy( element.attribute( "dy" ).toDouble() );
  if (element.hasAttribute("layer"))
    result->setLayer( element.attribute( "layer" ).toInt() );
  if (element.hasAttribute("roundness"))
    result->setRoundness( element.attribute( "roundness" ).toInt() );
  result->setRot( element.attribute( "rot" ) );
  if (element.hasAttribute("stop"))  {
    StopEnum stop = stopEnumFromString( element.attribute( "stop" ), ok  );
    if (ok && !(*ok)) {
      qCritical() << "Invalid string: \"" << element.attribute( "stop" ) << "\" in the \"stop\" element";
      return nullptr;
    } else {
      result->setStop( stop );
    }
  } else {
    // default value
    result->setStop(Stop_yes);
  }
  if (element.hasAttribute("thermals"))  {
    ThermalsEnum thermals = thermalsEnumFromString( element.attribute( "thermals" ), ok  );
    if (ok && !(*ok)) {
      qCritical() << "Invalid string: \"" << element.attribute( "thermals" ) << "\" in the \"thermals\" element";
      return nullptr;
    } else {
      result->setThermals( thermals );
    }
  } else {
    // default value
    result->setThermals(Thermals_yes);
  }
  if (element.hasAttribute("cream"))  {
    CreamEnum cream = creamEnumFromString( element.attribute( "cream" ), ok  );
    if (ok && !(*ok)) {
      qCritical() << "Invalid string: \"" << element.attribute( "cream" ) << "\" in the \"cream\" element";
      return nullptr;
    } else {
      result->setCream( cream );
    }
  } else {
    // default value
    result->setCream(Cream_yes);
  }

  if ( ok ) *ok = true;
  return result;
}

void Smd::writeElement( QXmlStreamWriter &xml ) const
{
  xml.writeStartElement( "smd" );
  if (!mName.isEmpty())
    xml.writeAttribute("name", mName );
  if (mX_set)
    xml.writeAttribute("x", QString::number( mX ) );
  if (mY_set)
    xml.writeAttribute("y", QString::number( mY ) );
  if (mDx_set)
    xml.writeAttribute("dx", QString::number( mDx ) );
  if (mDy_set)
    xml.writeAttribute("dy", QString::number( mDy ) );
  if (mLayer_set)
    xml.writeAttribute("layer", QString::number( mLayer ) );
  if (mRoundness_set)
    xml.writeAttribute("roundness", QString::number( mRoundness ) );
  if (!mRot.isEmpty())
    xml.writeAttribute("rot", mRot );
  if (mStop != Stop_Invalid)
    xml.writeAttribute("stop", stopEnumToString(mStop));
  if (mThermals != Thermals_Invalid)
    xml.writeAttribute("thermals", thermalsEnumToString(mThermals));
  if (mCream != Cream_Invalid)
    xml.writeAttribute("cream", creamEnumToString(mCream));
  xml.writeEndElement();
}


Package::Package()
  : mLocallyModified(LocallyModified_Invalid), mLibraryVersion(0), mLibraryVersion_set(false), mLibraryLocallyModified(LibraryLocallyModified_Invalid), mDescription(nullptr)
{
}

Package::~Package()
{
}

void Package::setName( const QString &v )
{
  mName = v;
}

QString Package::name() const
{
  return mName;
}

void Package::setUrn( const QString &v )
{
  mUrn = v;
}

QString Package::urn() const
{
  return mUrn;
}

void Package::setLocallyModified( const LocallyModifiedEnum &v )
{
  mLocallyModified = v;
}

Package::LocallyModifiedEnum Package::locallyModified() const
{
  return mLocallyModified;
}

void Package::setLibraryVersion( const int v )
{
  mLibraryVersion_set = true;
  mLibraryVersion = v;
}

int Package::libraryVersion() const
{
  return mLibraryVersion;
}

bool Package::libraryVersionSet() const
{
  return mLibraryVersion_set;
}

void Package::setLibraryLocallyModified( const LibraryLocallyModifiedEnum &v )
{
  mLibraryLocallyModified = v;
}

Package::LibraryLocallyModifiedEnum Package::libraryLocallyModified() const
{
  return mLibraryLocallyModified;
}

void Package::addPolygon( Polygon* v )
{
  mPolygonList.append( v );
}

void Package::setPolygonList( const Polygon::List &v )
{
  mPolygonList = v;
}

Polygon::List *Package::polygonList()
{
  return &mPolygonList;
}

void Package::addWire( Wire* v )
{
  mWireList.append( v );
}

void Package::setWireList( const Wire::List &v )
{
  mWireList = v;
}

Wire::List *Package::wireList()
{
  return &mWireList;
}

void Package::addText( Text* v )
{
  mTextList.append( v );
}

void Package::setTextList( const Text::List &v )
{
  mTextList = v;
}

Text::List *Package::textList()
{
  return &mTextList;
}

void Package::addDimension( Dimension* v )
{
  mDimensionList.append( v );
}

void Package::setDimensionList( const Dimension::List &v )
{
  mDimensionList = v;
}

Dimension::List *Package::dimensionList()
{
  return &mDimensionList;
}

void Package::addCircle( Circle* v )
{
  mCircleList.append( v );
}

void Package::setCircleList( const Circle::List &v )
{
  mCircleList = v;
}

Circle::List *Package::circleList()
{
  return &mCircleList;
}

void Package::addRectangle( Rectangle* v )
{
  mRectangleList.append( v );
}

void Package::setRectangleList( const Rectangle::List &v )
{
  mRectangleList = v;
}

Rectangle::List *Package::rectangleList()
{
  return &mRectangleList;
}

void Package::addFrame( Frame* v )
{
  mFrameList.append( v );
}

void Package::setFrameList( const Frame::List &v )
{
  mFrameList = v;
}

Frame::List *Package::frameList()
{
  return &mFrameList;
}

void Package::addHole( Hole* v )
{
  mHoleList.append( v );
}

void Package::setHoleList( const Hole::List &v )
{
  mHoleList = v;
}

Hole::List *Package::holeList()
{
  return &mHoleList;
}

void Package::addPad( Pad* v )
{
  mPadList.append( v );
}

void Package::setPadList( const Pad::List &v )
{
  mPadList = v;
}

Pad::List *Package::padList()
{
  return &mPadList;
}

void Package::addSmd( Smd* v )
{
  mSmdList.append( v );
}

void Package::setSmdList( const Smd::List &v )
{
  mSmdList = v;
}

Smd::List *Package::smdList()
{
  return &mSmdList;
}

void Package::setDescription( Description *v )
{
  mDescription = v;
}

Description *Package::description()
{
  return mDescription;
}

Package::LocallyModifiedEnum Package::locallyModifiedEnumFromString( const QString & v, bool *ok )
{
  if (ok) *ok = true;

  if ( v == "no" ) {
    return LocallyModified_no;
  } else if ( v == "yes" ) {
    return LocallyModified_yes;
  } else {
    if (ok) *ok = false;
    return LocallyModified_Invalid;
  }

  return LocallyModified_Invalid;
}

QString Package::locallyModifiedEnumToString( const LocallyModifiedEnum & v )
{
  switch( v ) {
  case LocallyModified_no: return "no";
  case LocallyModified_yes: return "yes";
  case LocallyModified_Invalid:
  default:
    qCritical() << "Unable to serialize a(n) LocallyModifiedEnum enum because it has invalid value:" << v;
    return QString();
  }
}

Package::LibraryLocallyModifiedEnum Package::libraryLocallyModifiedEnumFromString( const QString & v, bool *ok )
{
  if (ok) *ok = true;

  if ( v == "no" ) {
    return LibraryLocallyModified_no;
  } else if ( v == "yes" ) {
    return LibraryLocallyModified_yes;
  } else {
    if (ok) *ok = false;
    return LibraryLocallyModified_Invalid;
  }

  return LibraryLocallyModified_Invalid;
}

QString Package::libraryLocallyModifiedEnumToString( const LibraryLocallyModifiedEnum & v )
{
  switch( v ) {
  case LibraryLocallyModified_no: return "no";
  case LibraryLocallyModified_yes: return "yes";
  case LibraryLocallyModified_Invalid:
  default:
    qCritical() << "Unable to serialize a(n) LibraryLocallyModifiedEnum enum because it has invalid value:" << v;
    return QString();
  }
}

Package *Package::parseElement( const QDomElement &element, bool *ok )
{
  if ( element.tagName() != "package" ) {
    qCritical() << "Expected 'package', got '" << element.tagName() << "'.";
    if ( ok ) *ok = false;
    return nullptr;
  }

  Package* result = new Package();

  QDomNode n;
  for( n = element.firstChild(); !n.isNull(); n = n.nextSibling() ) {
    QDomElement e = n.toElement();
    if ( e.tagName() == "polygon" ) {
      bool ok;
      Polygon *o = Polygon::parseElement( e, &ok );
      if ( ok ) result->addPolygon( o );
    }
    else if ( e.tagName() == "wire" ) {
      bool ok;
      Wire *o = Wire::parseElement( e, &ok );
      if ( ok ) result->addWire( o );
    }
    else if ( e.tagName() == "text" ) {
      bool ok;
      Text *o = Text::parseElement( e, &ok );
      if ( ok ) result->addText( o );
    }
    else if ( e.tagName() == "dimension" ) {
      bool ok;
      Dimension *o = Dimension::parseElement( e, &ok );
      if ( ok ) result->addDimension( o );
    }
    else if ( e.tagName() == "circle" ) {
      bool ok;
      Circle *o = Circle::parseElement( e, &ok );
      if ( ok ) result->addCircle( o );
    }
    else if ( e.tagName() == "rectangle" ) {
      bool ok;
      Rectangle *o = Rectangle::parseElement( e, &ok );
      if ( ok ) result->addRectangle( o );
    }
    else if ( e.tagName() == "frame" ) {
      bool ok;
      Frame *o = Frame::parseElement( e, &ok );
      if ( ok ) result->addFrame( o );
    }
    else if ( e.tagName() == "hole" ) {
      bool ok;
      Hole *o = Hole::parseElement( e, &ok );
      if ( ok ) result->addHole( o );
    }
    else if ( e.tagName() == "pad" ) {
      bool ok;
      Pad *o = Pad::parseElement( e, &ok );
      if ( ok ) result->addPad( o );
    }
    else if ( e.tagName() == "smd" ) {
      bool ok;
      Smd *o = Smd::parseElement( e, &ok );
      if ( ok ) result->addSmd( o );
    }
    else if ( e.tagName() == "description" ) {
      bool ok;
      Description *o = Description::parseElement( e, &ok );
      if ( ok ) result->setDescription( o );
    }
  }

  result->setName( element.attribute( "name" ) );
  result->setUrn( element.attribute( "urn" ) );
  if (element.hasAttribute("locally_modified"))  {
    LocallyModifiedEnum locally_modified = locallyModifiedEnumFromString( element.attribute( "locally_modified" ), ok  );
    if (ok && !(*ok)) {
      qCritical() << "Invalid string: \"" << element.attribute( "locally_modified" ) << "\" in the \"locally_modified\" element";
      return nullptr;
    } else {
      result->setLocallyModified( locally_modified );
    }
  } else {
    // default value
    result->setLocallyModified(LocallyModified_no);
  }
  if (element.hasAttribute("library_version"))
    result->setLibraryVersion( element.attribute( "library_version" ).toInt() );
  if (element.hasAttribute("library_locally_modified"))  {
    LibraryLocallyModifiedEnum library_locally_modified = libraryLocallyModifiedEnumFromString( element.attribute( "library_locally_modified" ), ok  );
    if (ok && !(*ok)) {
      qCritical() << "Invalid string: \"" << element.attribute( "library_locally_modified" ) << "\" in the \"library_locally_modified\" element";
      return nullptr;
    } else {
      result->setLibraryLocallyModified( library_locally_modified );
    }
  } else {
    // default value
    result->setLibraryLocallyModified(LibraryLocallyModified_no);
  }

  if ( ok ) *ok = true;
  return result;
}

void Package::writeElement( QXmlStreamWriter &xml ) const
{
  xml.writeStartElement( "package" );
  if (!mName.isEmpty())
    xml.writeAttribute("name", mName );
  if (!mUrn.isEmpty())
    xml.writeAttribute("urn", mUrn );
  if (mLocallyModified != LocallyModified_Invalid)
    xml.writeAttribute("locally_modified", locallyModifiedEnumToString(mLocallyModified));
  if (mLibraryVersion_set)
    xml.writeAttribute("library_version", QString::number( mLibraryVersion ) );
  if (mLibraryLocallyModified != LibraryLocallyModified_Invalid)
    xml.writeAttribute("library_locally_modified", libraryLocallyModifiedEnumToString(mLibraryLocallyModified));
  foreach( Polygon* e, mPolygonList ) {
    if (e)
      e->writeElement( xml );
  }
  foreach( Wire* e, mWireList ) {
    if (e)
      e->writeElement( xml );
  }
  foreach( Text* e, mTextList ) {
    if (e)
      e->writeElement( xml );
  }
  foreach( Dimension* e, mDimensionList ) {
    if (e)
      e->writeElement( xml );
  }
  foreach( Circle* e, mCircleList ) {
    if (e)
      e->writeElement( xml );
  }
  foreach( Rectangle* e, mRectangleList ) {
    if (e)
      e->writeElement( xml );
  }
  foreach( Frame* e, mFrameList ) {
    if (e)
      e->writeElement( xml );
  }
  foreach( Hole* e, mHoleList ) {
    if (e)
      e->writeElement( xml );
  }
  foreach( Pad* e, mPadList ) {
    if (e)
      e->writeElement( xml );
  }
  foreach( Smd* e, mSmdList ) {
    if (e)
      e->writeElement( xml );
  }
  if (mDescription)
    mDescription->writeElement( xml );
  xml.writeEndElement();
}


Packages::Packages()
{
}

Packages::~Packages()
{
}

void Packages::addPackage( Package* v )
{
  mPackageList.append( v );
}

void Packages::setPackageList( const Package::List &v )
{
  mPackageList = v;
}

Package::List *Packages::packageList()
{
  return &mPackageList;
}

Packages *Packages::parseElement( const QDomElement &element, bool *ok )
{
  if ( element.tagName() != "packages" ) {
    qCritical() << "Expected 'packages', got '" << element.tagName() << "'.";
    if ( ok ) *ok = false;
    return nullptr;
  }

  Packages* result = new Packages();

  QDomNode n;
  for( n = element.firstChild(); !n.isNull(); n = n.nextSibling() ) {
    QDomElement e = n.toElement();
    if ( e.tagName() == "package" ) {
      bool ok;
      Package *o = Package::parseElement( e, &ok );
      if ( ok ) result->addPackage( o );
    }
  }


  if ( ok ) *ok = true;
  return result;
}

void Packages::writeElement( QXmlStreamWriter &xml ) const
{
  if ( !mPackageList.isEmpty() ) {
    xml.writeStartElement( "packages" );
    foreach( Package* e, mPackageList ) {
      if (e)
        e->writeElement( xml );
    }
    xml.writeEndElement();
  }
}


Packageinstance::Packageinstance()
{
}

Packageinstance::~Packageinstance()
{
}

void Packageinstance::setName( const QString &v )
{
  mName = v;
}

QString Packageinstance::name() const
{
  return mName;
}

Packageinstance *Packageinstance::parseElement( const QDomElement &element, bool *ok )
{
  if ( element.tagName() != "packageinstance" ) {
    qCritical() << "Expected 'packageinstance', got '" << element.tagName() << "'.";
    if ( ok ) *ok = false;
    return nullptr;
  }

  Packageinstance* result = new Packageinstance();

  result->setName( element.attribute( "name" ) );

  if ( ok ) *ok = true;
  return result;
}

void Packageinstance::writeElement( QXmlStreamWriter &xml ) const
{
  xml.writeStartElement( "packageinstance" );
  if (!mName.isEmpty())
    xml.writeAttribute("name", mName );
  xml.writeEndElement();
}


Packageinstances::Packageinstances()
{
}

Packageinstances::~Packageinstances()
{
}

void Packageinstances::addPackageinstance( Packageinstance* v )
{
  mPackageinstanceList.append( v );
}

void Packageinstances::setPackageinstanceList( const Packageinstance::List &v )
{
  mPackageinstanceList = v;
}

Packageinstance::List *Packageinstances::packageinstanceList()
{
  return &mPackageinstanceList;
}

Packageinstances *Packageinstances::parseElement( const QDomElement &element, bool *ok )
{
  if ( element.tagName() != "packageinstances" ) {
    qCritical() << "Expected 'packageinstances', got '" << element.tagName() << "'.";
    if ( ok ) *ok = false;
    return nullptr;
  }

  Packageinstances* result = new Packageinstances();

  QDomNode n;
  for( n = element.firstChild(); !n.isNull(); n = n.nextSibling() ) {
    QDomElement e = n.toElement();
    if ( e.tagName() == "packageinstance" ) {
      bool ok;
      Packageinstance *o = Packageinstance::parseElement( e, &ok );
      if ( ok ) result->addPackageinstance( o );
    }
  }


  if ( ok ) *ok = true;
  return result;
}

void Packageinstances::writeElement( QXmlStreamWriter &xml ) const
{
  if ( !mPackageinstanceList.isEmpty() ) {
    xml.writeStartElement( "packageinstances" );
    foreach( Packageinstance* e, mPackageinstanceList ) {
      if (e)
        e->writeElement( xml );
    }
    xml.writeEndElement();
  }
}


Package3d::Package3d()
  : mType(Type_Invalid), mLibraryVersion(0), mLibraryVersion_set(false), mLibraryLocallyModified(LibraryLocallyModified_Invalid), mDescription(nullptr), mPackageinstances(nullptr)
{
}

Package3d::~Package3d()
{
}

void Package3d::setName( const QString &v )
{
  mName = v;
}

QString Package3d::name() const
{
  return mName;
}

void Package3d::setUrn( const QString &v )
{
  mUrn = v;
}

QString Package3d::urn() const
{
  return mUrn;
}

void Package3d::setType( const TypeEnum &v )
{
  mType = v;
}

Package3d::TypeEnum Package3d::type() const
{
  return mType;
}

void Package3d::setLibraryVersion( const int v )
{
  mLibraryVersion_set = true;
  mLibraryVersion = v;
}

int Package3d::libraryVersion() const
{
  return mLibraryVersion;
}

bool Package3d::libraryVersionSet() const
{
  return mLibraryVersion_set;
}

void Package3d::setLibraryLocallyModified( const LibraryLocallyModifiedEnum &v )
{
  mLibraryLocallyModified = v;
}

Package3d::LibraryLocallyModifiedEnum Package3d::libraryLocallyModified() const
{
  return mLibraryLocallyModified;
}

void Package3d::setDescription( Description *v )
{
  mDescription = v;
}

Description *Package3d::description()
{
  return mDescription;
}

void Package3d::setPackageinstances( Packageinstances *v )
{
  mPackageinstances = v;
}

Packageinstances *Package3d::packageinstances()
{
  return mPackageinstances;
}

Package3d::TypeEnum Package3d::typeEnumFromString( const QString & v, bool *ok )
{
  if (ok) *ok = true;

  if ( v == "model" ) {
    return Type_model;
  } else if ( v == "box" ) {
    return Type_box;
  } else {
    if (ok) *ok = false;
    return Type_Invalid;
  }

  return Type_Invalid;
}

QString Package3d::typeEnumToString( const TypeEnum & v )
{
  switch( v ) {
  case Type_model: return "model";
  case Type_box: return "box";
  case Type_Invalid:
  default:
    qCritical() << "Unable to serialize a(n) TypeEnum enum because it has invalid value:" << v;
    return QString();
  }
}

Package3d::LibraryLocallyModifiedEnum Package3d::libraryLocallyModifiedEnumFromString( const QString & v, bool *ok )
{
  if (ok) *ok = true;

  if ( v == "no" ) {
    return LibraryLocallyModified_no;
  } else if ( v == "yes" ) {
    return LibraryLocallyModified_yes;
  } else {
    if (ok) *ok = false;
    return LibraryLocallyModified_Invalid;
  }

  return LibraryLocallyModified_Invalid;
}

QString Package3d::libraryLocallyModifiedEnumToString( const LibraryLocallyModifiedEnum & v )
{
  switch( v ) {
  case LibraryLocallyModified_no: return "no";
  case LibraryLocallyModified_yes: return "yes";
  case LibraryLocallyModified_Invalid:
  default:
    qCritical() << "Unable to serialize a(n) LibraryLocallyModifiedEnum enum because it has invalid value:" << v;
    return QString();
  }
}

Package3d *Package3d::parseElement( const QDomElement &element, bool *ok )
{
  if ( element.tagName() != "package3d" ) {
    qCritical() << "Expected 'package3d', got '" << element.tagName() << "'.";
    if ( ok ) *ok = false;
    return nullptr;
  }

  Package3d* result = new Package3d();

  QDomNode n;
  for( n = element.firstChild(); !n.isNull(); n = n.nextSibling() ) {
    QDomElement e = n.toElement();
    if ( e.tagName() == "description" ) {
      bool ok;
      Description *o = Description::parseElement( e, &ok );
      if ( ok ) result->setDescription( o );
    }
    else if ( e.tagName() == "packageinstances" ) {
      bool ok;
      Packageinstances *o = Packageinstances::parseElement( e, &ok );
      if ( ok ) result->setPackageinstances( o );
    }
  }

  result->setName( element.attribute( "name" ) );
  result->setUrn( element.attribute( "urn" ) );
  TypeEnum type = typeEnumFromString( element.attribute( "type" ), ok  );
  if (ok && !(*ok)) {
    qCritical() << "Invalid string: \"" << element.attribute( "type" ) << "\" in the \"type\" element";
    return nullptr;
  } else {
    result->setType( type );
  }
  if (element.hasAttribute("library_version"))
    result->setLibraryVersion( element.attribute( "library_version" ).toInt() );
  if (element.hasAttribute("library_locally_modified"))  {
    LibraryLocallyModifiedEnum library_locally_modified = libraryLocallyModifiedEnumFromString( element.attribute( "library_locally_modified" ), ok  );
    if (ok && !(*ok)) {
      qCritical() << "Invalid string: \"" << element.attribute( "library_locally_modified" ) << "\" in the \"library_locally_modified\" element";
      return nullptr;
    } else {
      result->setLibraryLocallyModified( library_locally_modified );
    }
  } else {
    // default value
    result->setLibraryLocallyModified(LibraryLocallyModified_no);
  }

  if ( ok ) *ok = true;
  return result;
}

void Package3d::writeElement( QXmlStreamWriter &xml ) const
{
  xml.writeStartElement( "package3d" );
  if (!mName.isEmpty())
    xml.writeAttribute("name", mName );
  if (!mUrn.isEmpty())
    xml.writeAttribute("urn", mUrn );
  if (mType != Type_Invalid)
    xml.writeAttribute("type", typeEnumToString(mType));
  if (mLibraryVersion_set)
    xml.writeAttribute("library_version", QString::number( mLibraryVersion ) );
  if (mLibraryLocallyModified != LibraryLocallyModified_Invalid)
    xml.writeAttribute("library_locally_modified", libraryLocallyModifiedEnumToString(mLibraryLocallyModified));
  if (mDescription)
    mDescription->writeElement( xml );
  if (mPackageinstances)
    mPackageinstances->writeElement( xml );
  xml.writeEndElement();
}


Packages3d::Packages3d()
{
}

Packages3d::~Packages3d()
{
}

void Packages3d::addPackage3d( Package3d* v )
{
  mPackage3dList.append( v );
}

void Packages3d::setPackage3dList( const Package3d::List &v )
{
  mPackage3dList = v;
}

Package3d::List *Packages3d::package3dList()
{
  return &mPackage3dList;
}

Packages3d *Packages3d::parseElement( const QDomElement &element, bool *ok )
{
  if ( element.tagName() != "packages3d" ) {
    qCritical() << "Expected 'packages3d', got '" << element.tagName() << "'.";
    if ( ok ) *ok = false;
    return nullptr;
  }

  Packages3d* result = new Packages3d();

  QDomNode n;
  for( n = element.firstChild(); !n.isNull(); n = n.nextSibling() ) {
    QDomElement e = n.toElement();
    if ( e.tagName() == "package3d" ) {
      bool ok;
      Package3d *o = Package3d::parseElement( e, &ok );
      if ( ok ) result->addPackage3d( o );
    }
  }


  if ( ok ) *ok = true;
  return result;
}

void Packages3d::writeElement( QXmlStreamWriter &xml ) const
{
  if ( !mPackage3dList.isEmpty() ) {
    xml.writeStartElement( "packages3d" );
    foreach( Package3d* e, mPackage3dList ) {
      if (e)
        e->writeElement( xml );
    }
    xml.writeEndElement();
  }
}


Pin::Pin()
  : mX(0.0), mX_set(false), mY(0.0), mY_set(false), mVisible(Visible_Invalid), mLength(Length_Invalid), mDirection(Direction_Invalid), mFunction(Function_Invalid), mSwaplevel(0), mSwaplevel_set(false)
{
}

Pin::~Pin()
{
}

void Pin::setName( const QString &v )
{
  mName = v;
}

QString Pin::name() const
{
  return mName;
}

void Pin::setX( const double v )
{
  mX_set = true;
  mX = v;
}

double Pin::x() const
{
  return mX;
}

bool Pin::xSet() const
{
  return mX_set;
}

void Pin::setY( const double v )
{
  mY_set = true;
  mY = v;
}

double Pin::y() const
{
  return mY;
}

bool Pin::ySet() const
{
  return mY_set;
}

void Pin::setVisible( const VisibleEnum &v )
{
  mVisible = v;
}

Pin::VisibleEnum Pin::visible() const
{
  return mVisible;
}

void Pin::setLength( const LengthEnum &v )
{
  mLength = v;
}

Pin::LengthEnum Pin::length() const
{
  return mLength;
}

void Pin::setDirection( const DirectionEnum &v )
{
  mDirection = v;
}

Pin::DirectionEnum Pin::direction() const
{
  return mDirection;
}

void Pin::setFunction( const FunctionEnum &v )
{
  mFunction = v;
}

Pin::FunctionEnum Pin::function() const
{
  return mFunction;
}

void Pin::setSwaplevel( const int v )
{
  mSwaplevel_set = true;
  mSwaplevel = v;
}

int Pin::swaplevel() const
{
  return mSwaplevel;
}

bool Pin::swaplevelSet() const
{
  return mSwaplevel_set;
}

void Pin::setRot( const QString &v )
{
  mRot = v;
}

QString Pin::rot() const
{
  return mRot;
}

Pin::VisibleEnum Pin::visibleEnumFromString( const QString & v, bool *ok )
{
  if (ok) *ok = true;

  if ( v == "off" ) {
    return Visible_off;
  } else if ( v == "pad" ) {
    return Visible_pad;
  } else if ( v == "pin" ) {
    return Visible_pin;
  } else if ( v == "both" ) {
    return Visible_both;
  } else {
    if (ok) *ok = false;
    return Visible_Invalid;
  }

  return Visible_Invalid;
}

QString Pin::visibleEnumToString( const VisibleEnum & v )
{
  switch( v ) {
  case Visible_off: return "off";
  case Visible_pad: return "pad";
  case Visible_pin: return "pin";
  case Visible_both: return "both";
  case Visible_Invalid:
  default:
    qCritical() << "Unable to serialize a(n) VisibleEnum enum because it has invalid value:" << v;
    return QString();
  }
}

Pin::LengthEnum Pin::lengthEnumFromString( const QString & v, bool *ok )
{
  if (ok) *ok = true;

  if ( v == "point" ) {
    return Length_point;
  } else if ( v == "short" ) {
    return Length_short;
  } else if ( v == "middle" ) {
    return Length_middle;
  } else if ( v == "long" ) {
    return Length_long;
  } else {
    if (ok) *ok = false;
    return Length_Invalid;
  }

  return Length_Invalid;
}

QString Pin::lengthEnumToString( const LengthEnum & v )
{
  switch( v ) {
  case Length_point: return "point";
  case Length_short: return "short";
  case Length_middle: return "middle";
  case Length_long: return "long";
  case Length_Invalid:
  default:
    qCritical() << "Unable to serialize a(n) LengthEnum enum because it has invalid value:" << v;
    return QString();
  }
}

Pin::DirectionEnum Pin::directionEnumFromString( const QString & v, bool *ok )
{
  if (ok) *ok = true;

  if ( v == "nc" ) {
    return Direction_nc;
  } else if ( v == "in" ) {
    return Direction_in;
  } else if ( v == "out" ) {
    return Direction_out;
  } else if ( v == "io" ) {
    return Direction_io;
  } else if ( v == "oc" ) {
    return Direction_oc;
  } else if ( v == "pwr" ) {
    return Direction_pwr;
  } else if ( v == "pas" ) {
    return Direction_pas;
  } else if ( v == "hiz" ) {
    return Direction_hiz;
  } else if ( v == "sup" ) {
    return Direction_sup;
  } else {
    if (ok) *ok = false;
    return Direction_Invalid;
  }

  return Direction_Invalid;
}

QString Pin::directionEnumToString( const DirectionEnum & v )
{
  switch( v ) {
  case Direction_nc: return "nc";
  case Direction_in: return "in";
  case Direction_out: return "out";
  case Direction_io: return "io";
  case Direction_oc: return "oc";
  case Direction_pwr: return "pwr";
  case Direction_pas: return "pas";
  case Direction_hiz: return "hiz";
  case Direction_sup: return "sup";
  case Direction_Invalid:
  default:
    qCritical() << "Unable to serialize a(n) DirectionEnum enum because it has invalid value:" << v;
    return QString();
  }
}

Pin::FunctionEnum Pin::functionEnumFromString( const QString & v, bool *ok )
{
  if (ok) *ok = true;

  if ( v == "none" ) {
    return Function_none;
  } else if ( v == "dot" ) {
    return Function_dot;
  } else if ( v == "clk" ) {
    return Function_clk;
  } else if ( v == "dotclk" ) {
    return Function_dotclk;
  } else {
    if (ok) *ok = false;
    return Function_Invalid;
  }

  return Function_Invalid;
}

QString Pin::functionEnumToString( const FunctionEnum & v )
{
  switch( v ) {
  case Function_none: return "none";
  case Function_dot: return "dot";
  case Function_clk: return "clk";
  case Function_dotclk: return "dotclk";
  case Function_Invalid:
  default:
    qCritical() << "Unable to serialize a(n) FunctionEnum enum because it has invalid value:" << v;
    return QString();
  }
}

Pin *Pin::parseElement( const QDomElement &element, bool *ok )
{
  if ( element.tagName() != "pin" ) {
    qCritical() << "Expected 'pin', got '" << element.tagName() << "'.";
    if ( ok ) *ok = false;
    return nullptr;
  }

  Pin* result = new Pin();

  result->setName( element.attribute( "name" ) );
  if (element.hasAttribute("x"))
    result->setX( element.attribute( "x" ).toDouble() );
  if (element.hasAttribute("y"))
    result->setY( element.attribute( "y" ).toDouble() );
  if (element.hasAttribute("visible"))  {
    VisibleEnum visible = visibleEnumFromString( element.attribute( "visible" ), ok  );
    if (ok && !(*ok)) {
      qCritical() << "Invalid string: \"" << element.attribute( "visible" ) << "\" in the \"visible\" element";
      return nullptr;
    } else {
      result->setVisible( visible );
    }
  } else {
    // default value
    result->setVisible(Visible_both);
  }
  if (element.hasAttribute("length"))  {
    LengthEnum length = lengthEnumFromString( element.attribute( "length" ), ok  );
    if (ok && !(*ok)) {
      qCritical() << "Invalid string: \"" << element.attribute( "length" ) << "\" in the \"length\" element";
      return nullptr;
    } else {
      result->setLength( length );
    }
  } else {
    // default value
    result->setLength(Length_long);
  }
  if (element.hasAttribute("direction"))  {
    DirectionEnum direction = directionEnumFromString( element.attribute( "direction" ), ok  );
    if (ok && !(*ok)) {
      qCritical() << "Invalid string: \"" << element.attribute( "direction" ) << "\" in the \"direction\" element";
      return nullptr;
    } else {
      result->setDirection( direction );
    }
  } else {
    // default value
    result->setDirection(Direction_io);
  }
  if (element.hasAttribute("function"))  {
    FunctionEnum function = functionEnumFromString( element.attribute( "function" ), ok  );
    if (ok && !(*ok)) {
      qCritical() << "Invalid string: \"" << element.attribute( "function" ) << "\" in the \"function\" element";
      return nullptr;
    } else {
      result->setFunction( function );
    }
  } else {
    // default value
    result->setFunction(Function_none);
  }
  if (element.hasAttribute("swaplevel"))
    result->setSwaplevel( element.attribute( "swaplevel" ).toInt() );
  result->setRot( element.attribute( "rot" ) );

  if ( ok ) *ok = true;
  return result;
}

void Pin::writeElement( QXmlStreamWriter &xml ) const
{
  xml.writeStartElement( "pin" );
  if (!mName.isEmpty())
    xml.writeAttribute("name", mName );
  if (mX_set)
    xml.writeAttribute("x", QString::number( mX ) );
  if (mY_set)
    xml.writeAttribute("y", QString::number( mY ) );
  if (mVisible != Visible_Invalid)
    xml.writeAttribute("visible", visibleEnumToString(mVisible));
  if (mLength != Length_Invalid)
    xml.writeAttribute("length", lengthEnumToString(mLength));
  if (mDirection != Direction_Invalid)
    xml.writeAttribute("direction", directionEnumToString(mDirection));
  if (mFunction != Function_Invalid)
    xml.writeAttribute("function", functionEnumToString(mFunction));
  if (mSwaplevel_set)
    xml.writeAttribute("swaplevel", QString::number( mSwaplevel ) );
  if (!mRot.isEmpty())
    xml.writeAttribute("rot", mRot );
  xml.writeEndElement();
}


Symbol::Symbol()
  : mLocallyModified(LocallyModified_Invalid), mLibraryVersion(0), mLibraryVersion_set(false), mLibraryLocallyModified(LibraryLocallyModified_Invalid), mDescription(nullptr)
{
}

Symbol::~Symbol()
{
}

void Symbol::setName( const QString &v )
{
  mName = v;
}

QString Symbol::name() const
{
  return mName;
}

void Symbol::setUrn( const QString &v )
{
  mUrn = v;
}

QString Symbol::urn() const
{
  return mUrn;
}

void Symbol::setLocallyModified( const LocallyModifiedEnum &v )
{
  mLocallyModified = v;
}

Symbol::LocallyModifiedEnum Symbol::locallyModified() const
{
  return mLocallyModified;
}

void Symbol::setLibraryVersion( const int v )
{
  mLibraryVersion_set = true;
  mLibraryVersion = v;
}

int Symbol::libraryVersion() const
{
  return mLibraryVersion;
}

bool Symbol::libraryVersionSet() const
{
  return mLibraryVersion_set;
}

void Symbol::setLibraryLocallyModified( const LibraryLocallyModifiedEnum &v )
{
  mLibraryLocallyModified = v;
}

Symbol::LibraryLocallyModifiedEnum Symbol::libraryLocallyModified() const
{
  return mLibraryLocallyModified;
}

void Symbol::addPolygon( Polygon* v )
{
  mPolygonList.append( v );
}

void Symbol::setPolygonList( const Polygon::List &v )
{
  mPolygonList = v;
}

Polygon::List *Symbol::polygonList()
{
  return &mPolygonList;
}

void Symbol::addWire( Wire* v )
{
  mWireList.append( v );
}

void Symbol::setWireList( const Wire::List &v )
{
  mWireList = v;
}

Wire::List *Symbol::wireList()
{
  return &mWireList;
}

void Symbol::addText( Text* v )
{
  mTextList.append( v );
}

void Symbol::setTextList( const Text::List &v )
{
  mTextList = v;
}

Text::List *Symbol::textList()
{
  return &mTextList;
}

void Symbol::addDimension( Dimension* v )
{
  mDimensionList.append( v );
}

void Symbol::setDimensionList( const Dimension::List &v )
{
  mDimensionList = v;
}

Dimension::List *Symbol::dimensionList()
{
  return &mDimensionList;
}

void Symbol::addPin( Pin* v )
{
  mPinList.append( v );
}

void Symbol::setPinList( const Pin::List &v )
{
  mPinList = v;
}

Pin::List *Symbol::pinList()
{
  return &mPinList;
}

void Symbol::addCircle( Circle* v )
{
  mCircleList.append( v );
}

void Symbol::setCircleList( const Circle::List &v )
{
  mCircleList = v;
}

Circle::List *Symbol::circleList()
{
  return &mCircleList;
}

void Symbol::addRectangle( Rectangle* v )
{
  mRectangleList.append( v );
}

void Symbol::setRectangleList( const Rectangle::List &v )
{
  mRectangleList = v;
}

Rectangle::List *Symbol::rectangleList()
{
  return &mRectangleList;
}

void Symbol::addFrame( Frame* v )
{
  mFrameList.append( v );
}

void Symbol::setFrameList( const Frame::List &v )
{
  mFrameList = v;
}

Frame::List *Symbol::frameList()
{
  return &mFrameList;
}

void Symbol::setDescription( Description *v )
{
  mDescription = v;
}

Description *Symbol::description()
{
  return mDescription;
}

Symbol::LocallyModifiedEnum Symbol::locallyModifiedEnumFromString( const QString & v, bool *ok )
{
  if (ok) *ok = true;

  if ( v == "no" ) {
    return LocallyModified_no;
  } else if ( v == "yes" ) {
    return LocallyModified_yes;
  } else {
    if (ok) *ok = false;
    return LocallyModified_Invalid;
  }

  return LocallyModified_Invalid;
}

QString Symbol::locallyModifiedEnumToString( const LocallyModifiedEnum & v )
{
  switch( v ) {
  case LocallyModified_no: return "no";
  case LocallyModified_yes: return "yes";
  case LocallyModified_Invalid:
  default:
    qCritical() << "Unable to serialize a(n) LocallyModifiedEnum enum because it has invalid value:" << v;
    return QString();
  }
}

Symbol::LibraryLocallyModifiedEnum Symbol::libraryLocallyModifiedEnumFromString( const QString & v, bool *ok )
{
  if (ok) *ok = true;

  if ( v == "no" ) {
    return LibraryLocallyModified_no;
  } else if ( v == "yes" ) {
    return LibraryLocallyModified_yes;
  } else {
    if (ok) *ok = false;
    return LibraryLocallyModified_Invalid;
  }

  return LibraryLocallyModified_Invalid;
}

QString Symbol::libraryLocallyModifiedEnumToString( const LibraryLocallyModifiedEnum & v )
{
  switch( v ) {
  case LibraryLocallyModified_no: return "no";
  case LibraryLocallyModified_yes: return "yes";
  case LibraryLocallyModified_Invalid:
  default:
    qCritical() << "Unable to serialize a(n) LibraryLocallyModifiedEnum enum because it has invalid value:" << v;
    return QString();
  }
}

Symbol *Symbol::parseElement( const QDomElement &element, bool *ok )
{
  if ( element.tagName() != "symbol" ) {
    qCritical() << "Expected 'symbol', got '" << element.tagName() << "'.";
    if ( ok ) *ok = false;
    return nullptr;
  }

  Symbol* result = new Symbol();

  QDomNode n;
  for( n = element.firstChild(); !n.isNull(); n = n.nextSibling() ) {
    QDomElement e = n.toElement();
    if ( e.tagName() == "polygon" ) {
      bool ok;
      Polygon *o = Polygon::parseElement( e, &ok );
      if ( ok ) result->addPolygon( o );
    }
    else if ( e.tagName() == "wire" ) {
      bool ok;
      Wire *o = Wire::parseElement( e, &ok );
      if ( ok ) result->addWire( o );
    }
    else if ( e.tagName() == "text" ) {
      bool ok;
      Text *o = Text::parseElement( e, &ok );
      if ( ok ) result->addText( o );
    }
    else if ( e.tagName() == "dimension" ) {
      bool ok;
      Dimension *o = Dimension::parseElement( e, &ok );
      if ( ok ) result->addDimension( o );
    }
    else if ( e.tagName() == "pin" ) {
      bool ok;
      Pin *o = Pin::parseElement( e, &ok );
      if ( ok ) result->addPin( o );
    }
    else if ( e.tagName() == "circle" ) {
      bool ok;
      Circle *o = Circle::parseElement( e, &ok );
      if ( ok ) result->addCircle( o );
    }
    else if ( e.tagName() == "rectangle" ) {
      bool ok;
      Rectangle *o = Rectangle::parseElement( e, &ok );
      if ( ok ) result->addRectangle( o );
    }
    else if ( e.tagName() == "frame" ) {
      bool ok;
      Frame *o = Frame::parseElement( e, &ok );
      if ( ok ) result->addFrame( o );
    }
    else if ( e.tagName() == "description" ) {
      bool ok;
      Description *o = Description::parseElement( e, &ok );
      if ( ok ) result->setDescription( o );
    }
  }

  result->setName( element.attribute( "name" ) );
  result->setUrn( element.attribute( "urn" ) );
  if (element.hasAttribute("locally_modified"))  {
    LocallyModifiedEnum locally_modified = locallyModifiedEnumFromString( element.attribute( "locally_modified" ), ok  );
    if (ok && !(*ok)) {
      qCritical() << "Invalid string: \"" << element.attribute( "locally_modified" ) << "\" in the \"locally_modified\" element";
      return nullptr;
    } else {
      result->setLocallyModified( locally_modified );
    }
  } else {
    // default value
    result->setLocallyModified(LocallyModified_no);
  }
  if (element.hasAttribute("library_version"))
    result->setLibraryVersion( element.attribute( "library_version" ).toInt() );
  if (element.hasAttribute("library_locally_modified"))  {
    LibraryLocallyModifiedEnum library_locally_modified = libraryLocallyModifiedEnumFromString( element.attribute( "library_locally_modified" ), ok  );
    if (ok && !(*ok)) {
      qCritical() << "Invalid string: \"" << element.attribute( "library_locally_modified" ) << "\" in the \"library_locally_modified\" element";
      return nullptr;
    } else {
      result->setLibraryLocallyModified( library_locally_modified );
    }
  } else {
    // default value
    result->setLibraryLocallyModified(LibraryLocallyModified_no);
  }

  if ( ok ) *ok = true;
  return result;
}

void Symbol::writeElement( QXmlStreamWriter &xml ) const
{
  xml.writeStartElement( "symbol" );
  if (!mName.isEmpty())
    xml.writeAttribute("name", mName );
  if (!mUrn.isEmpty())
    xml.writeAttribute("urn", mUrn );
  if (mLocallyModified != LocallyModified_Invalid)
    xml.writeAttribute("locally_modified", locallyModifiedEnumToString(mLocallyModified));
  if (mLibraryVersion_set)
    xml.writeAttribute("library_version", QString::number( mLibraryVersion ) );
  if (mLibraryLocallyModified != LibraryLocallyModified_Invalid)
    xml.writeAttribute("library_locally_modified", libraryLocallyModifiedEnumToString(mLibraryLocallyModified));
  foreach( Polygon* e, mPolygonList ) {
    if (e)
      e->writeElement( xml );
  }
  foreach( Wire* e, mWireList ) {
    if (e)
      e->writeElement( xml );
  }
  foreach( Text* e, mTextList ) {
    if (e)
      e->writeElement( xml );
  }
  foreach( Dimension* e, mDimensionList ) {
    if (e)
      e->writeElement( xml );
  }
  foreach( Pin* e, mPinList ) {
    if (e)
      e->writeElement( xml );
  }
  foreach( Circle* e, mCircleList ) {
    if (e)
      e->writeElement( xml );
  }
  foreach( Rectangle* e, mRectangleList ) {
    if (e)
      e->writeElement( xml );
  }
  foreach( Frame* e, mFrameList ) {
    if (e)
      e->writeElement( xml );
  }
  if (mDescription)
    mDescription->writeElement( xml );
  xml.writeEndElement();
}


Symbols::Symbols()
{
}

Symbols::~Symbols()
{
}

void Symbols::addSymbol( Symbol* v )
{
  mSymbolList.append( v );
}

void Symbols::setSymbolList( const Symbol::List &v )
{
  mSymbolList = v;
}

Symbol::List *Symbols::symbolList()
{
  return &mSymbolList;
}

Symbols *Symbols::parseElement( const QDomElement &element, bool *ok )
{
  if ( element.tagName() != "symbols" ) {
    qCritical() << "Expected 'symbols', got '" << element.tagName() << "'.";
    if ( ok ) *ok = false;
    return nullptr;
  }

  Symbols* result = new Symbols();

  QDomNode n;
  for( n = element.firstChild(); !n.isNull(); n = n.nextSibling() ) {
    QDomElement e = n.toElement();
    if ( e.tagName() == "symbol" ) {
      bool ok;
      Symbol *o = Symbol::parseElement( e, &ok );
      if ( ok ) result->addSymbol( o );
    }
  }


  if ( ok ) *ok = true;
  return result;
}

void Symbols::writeElement( QXmlStreamWriter &xml ) const
{
  if ( !mSymbolList.isEmpty() ) {
    xml.writeStartElement( "symbols" );
    foreach( Symbol* e, mSymbolList ) {
      if (e)
        e->writeElement( xml );
    }
    xml.writeEndElement();
  }
}


Gate::Gate()
  : mX(0.0), mX_set(false), mY(0.0), mY_set(false), mAddlevel(Addlevel_Invalid), mSwaplevel(0), mSwaplevel_set(false)
{
}

Gate::~Gate()
{
}

void Gate::setName( const QString &v )
{
  mName = v;
}

QString Gate::name() const
{
  return mName;
}

void Gate::setSymbol( const QString &v )
{
  mSymbol = v;
}

QString Gate::symbol() const
{
  return mSymbol;
}

void Gate::setX( const double v )
{
  mX_set = true;
  mX = v;
}

double Gate::x() const
{
  return mX;
}

bool Gate::xSet() const
{
  return mX_set;
}

void Gate::setY( const double v )
{
  mY_set = true;
  mY = v;
}

double Gate::y() const
{
  return mY;
}

bool Gate::ySet() const
{
  return mY_set;
}

void Gate::setAddlevel( const AddlevelEnum &v )
{
  mAddlevel = v;
}

Gate::AddlevelEnum Gate::addlevel() const
{
  return mAddlevel;
}

void Gate::setSwaplevel( const int v )
{
  mSwaplevel_set = true;
  mSwaplevel = v;
}

int Gate::swaplevel() const
{
  return mSwaplevel;
}

bool Gate::swaplevelSet() const
{
  return mSwaplevel_set;
}

Gate::AddlevelEnum Gate::addlevelEnumFromString( const QString & v, bool *ok )
{
  if (ok) *ok = true;

  if ( v == "must" ) {
    return Addlevel_must;
  } else if ( v == "can" ) {
    return Addlevel_can;
  } else if ( v == "next" ) {
    return Addlevel_next;
  } else if ( v == "request" ) {
    return Addlevel_request;
  } else if ( v == "always" ) {
    return Addlevel_always;
  } else {
    if (ok) *ok = false;
    return Addlevel_Invalid;
  }

  return Addlevel_Invalid;
}

QString Gate::addlevelEnumToString( const AddlevelEnum & v )
{
  switch( v ) {
  case Addlevel_must: return "must";
  case Addlevel_can: return "can";
  case Addlevel_next: return "next";
  case Addlevel_request: return "request";
  case Addlevel_always: return "always";
  case Addlevel_Invalid:
  default:
    qCritical() << "Unable to serialize a(n) AddlevelEnum enum because it has invalid value:" << v;
    return QString();
  }
}

Gate *Gate::parseElement( const QDomElement &element, bool *ok )
{
  if ( element.tagName() != "gate" ) {
    qCritical() << "Expected 'gate', got '" << element.tagName() << "'.";
    if ( ok ) *ok = false;
    return nullptr;
  }

  Gate* result = new Gate();

  result->setName( element.attribute( "name" ) );
  result->setSymbol( element.attribute( "symbol" ) );
  if (element.hasAttribute("x"))
    result->setX( element.attribute( "x" ).toDouble() );
  if (element.hasAttribute("y"))
    result->setY( element.attribute( "y" ).toDouble() );
  if (element.hasAttribute("addlevel"))  {
    AddlevelEnum addlevel = addlevelEnumFromString( element.attribute( "addlevel" ), ok  );
    if (ok && !(*ok)) {
      qCritical() << "Invalid string: \"" << element.attribute( "addlevel" ) << "\" in the \"addlevel\" element";
      return nullptr;
    } else {
      result->setAddlevel( addlevel );
    }
  } else {
    // default value
    result->setAddlevel(Addlevel_next);
  }
  if (element.hasAttribute("swaplevel"))
    result->setSwaplevel( element.attribute( "swaplevel" ).toInt() );

  if ( ok ) *ok = true;
  return result;
}

void Gate::writeElement( QXmlStreamWriter &xml ) const
{
  xml.writeStartElement( "gate" );
  if (!mName.isEmpty())
    xml.writeAttribute("name", mName );
  if (!mSymbol.isEmpty())
    xml.writeAttribute("symbol", mSymbol );
  if (mX_set)
    xml.writeAttribute("x", QString::number( mX ) );
  if (mY_set)
    xml.writeAttribute("y", QString::number( mY ) );
  if (mAddlevel != Addlevel_Invalid)
    xml.writeAttribute("addlevel", addlevelEnumToString(mAddlevel));
  if (mSwaplevel_set)
    xml.writeAttribute("swaplevel", QString::number( mSwaplevel ) );
  xml.writeEndElement();
}


Gates::Gates()
{
}

Gates::~Gates()
{
}

void Gates::addGate( Gate* v )
{
  mGateList.append( v );
}

void Gates::setGateList( const Gate::List &v )
{
  mGateList = v;
}

Gate::List *Gates::gateList()
{
  return &mGateList;
}

Gates *Gates::parseElement( const QDomElement &element, bool *ok )
{
  if ( element.tagName() != "gates" ) {
    qCritical() << "Expected 'gates', got '" << element.tagName() << "'.";
    if ( ok ) *ok = false;
    return nullptr;
  }

  Gates* result = new Gates();

  QDomNode n;
  for( n = element.firstChild(); !n.isNull(); n = n.nextSibling() ) {
    QDomElement e = n.toElement();
    if ( e.tagName() == "gate" ) {
      bool ok;
      Gate *o = Gate::parseElement( e, &ok );
      if ( ok ) result->addGate( o );
    }
  }


  if ( ok ) *ok = true;
  return result;
}

void Gates::writeElement( QXmlStreamWriter &xml ) const
{
  if ( !mGateList.isEmpty() ) {
    xml.writeStartElement( "gates" );
    foreach( Gate* e, mGateList ) {
      if (e)
        e->writeElement( xml );
    }
    xml.writeEndElement();
  }
}


Connect::Connect()
  : mRoute(Route_Invalid)
{
}

Connect::~Connect()
{
}

void Connect::setGate( const QString &v )
{
  mGate = v;
}

QString Connect::gate() const
{
  return mGate;
}

void Connect::setPin( const QString &v )
{
  mPin = v;
}

QString Connect::pin() const
{
  return mPin;
}

void Connect::setPad( const QString &v )
{
  mPad = v;
}

QString Connect::pad() const
{
  return mPad;
}

void Connect::setRoute( const RouteEnum &v )
{
  mRoute = v;
}

Connect::RouteEnum Connect::route() const
{
  return mRoute;
}

Connect::RouteEnum Connect::routeEnumFromString( const QString & v, bool *ok )
{
  if (ok) *ok = true;

  if ( v == "all" ) {
    return Route_all;
  } else if ( v == "any" ) {
    return Route_any;
  } else {
    if (ok) *ok = false;
    return Route_Invalid;
  }

  return Route_Invalid;
}

QString Connect::routeEnumToString( const RouteEnum & v )
{
  switch( v ) {
  case Route_all: return "all";
  case Route_any: return "any";
  case Route_Invalid:
  default:
    qCritical() << "Unable to serialize a(n) RouteEnum enum because it has invalid value:" << v;
    return QString();
  }
}

Connect *Connect::parseElement( const QDomElement &element, bool *ok )
{
  if ( element.tagName() != "connect" ) {
    qCritical() << "Expected 'connect', got '" << element.tagName() << "'.";
    if ( ok ) *ok = false;
    return nullptr;
  }

  Connect* result = new Connect();

  result->setGate( element.attribute( "gate" ) );
  result->setPin( element.attribute( "pin" ) );
  result->setPad( element.attribute( "pad" ) );
  if (element.hasAttribute("route"))  {
    RouteEnum route = routeEnumFromString( element.attribute( "route" ), ok  );
    if (ok && !(*ok)) {
      qCritical() << "Invalid string: \"" << element.attribute( "route" ) << "\" in the \"route\" element";
      return nullptr;
    } else {
      result->setRoute( route );
    }
  } else {
    // default value
    result->setRoute(Route_all);
  }

  if ( ok ) *ok = true;
  return result;
}

void Connect::writeElement( QXmlStreamWriter &xml ) const
{
  xml.writeStartElement( "connect" );
  if (!mGate.isEmpty())
    xml.writeAttribute("gate", mGate );
  if (!mPin.isEmpty())
    xml.writeAttribute("pin", mPin );
  if (!mPad.isEmpty())
    xml.writeAttribute("pad", mPad );
  if (mRoute != Route_Invalid)
    xml.writeAttribute("route", routeEnumToString(mRoute));
  xml.writeEndElement();
}


Connects::Connects()
{
}

Connects::~Connects()
{
}

void Connects::addConnect( Connect* v )
{
  mConnectList.append( v );
}

void Connects::setConnectList( const Connect::List &v )
{
  mConnectList = v;
}

Connect::List *Connects::connectList()
{
  return &mConnectList;
}

Connects *Connects::parseElement( const QDomElement &element, bool *ok )
{
  if ( element.tagName() != "connects" ) {
    qCritical() << "Expected 'connects', got '" << element.tagName() << "'.";
    if ( ok ) *ok = false;
    return nullptr;
  }

  Connects* result = new Connects();

  QDomNode n;
  for( n = element.firstChild(); !n.isNull(); n = n.nextSibling() ) {
    QDomElement e = n.toElement();
    if ( e.tagName() == "connect" ) {
      bool ok;
      Connect *o = Connect::parseElement( e, &ok );
      if ( ok ) result->addConnect( o );
    }
  }


  if ( ok ) *ok = true;
  return result;
}

void Connects::writeElement( QXmlStreamWriter &xml ) const
{
  if ( !mConnectList.isEmpty() ) {
    xml.writeStartElement( "connects" );
    foreach( Connect* e, mConnectList ) {
      if (e)
        e->writeElement( xml );
    }
    xml.writeEndElement();
  }
}


Package3dinstance::Package3dinstance()
{
}

Package3dinstance::~Package3dinstance()
{
}

void Package3dinstance::setPackage3dUrn( const QString &v )
{
  mPackage3dUrn = v;
}

QString Package3dinstance::package3dUrn() const
{
  return mPackage3dUrn;
}

Package3dinstance *Package3dinstance::parseElement( const QDomElement &element, bool *ok )
{
  if ( element.tagName() != "package3dinstance" ) {
    qCritical() << "Expected 'package3dinstance', got '" << element.tagName() << "'.";
    if ( ok ) *ok = false;
    return nullptr;
  }

  Package3dinstance* result = new Package3dinstance();

  result->setPackage3dUrn( element.attribute( "package3d_urn" ) );

  if ( ok ) *ok = true;
  return result;
}

void Package3dinstance::writeElement( QXmlStreamWriter &xml ) const
{
  xml.writeStartElement( "package3dinstance" );
  if (!mPackage3dUrn.isEmpty())
    xml.writeAttribute("package3d_urn", mPackage3dUrn );
  xml.writeEndElement();
}


Package3dinstances::Package3dinstances()
{
}

Package3dinstances::~Package3dinstances()
{
}

void Package3dinstances::addPackage3dinstance( Package3dinstance* v )
{
  mPackage3dinstanceList.append( v );
}

void Package3dinstances::setPackage3dinstanceList( const Package3dinstance::List &v )
{
  mPackage3dinstanceList = v;
}

Package3dinstance::List *Package3dinstances::package3dinstanceList()
{
  return &mPackage3dinstanceList;
}

Package3dinstances *Package3dinstances::parseElement( const QDomElement &element, bool *ok )
{
  if ( element.tagName() != "package3dinstances" ) {
    qCritical() << "Expected 'package3dinstances', got '" << element.tagName() << "'.";
    if ( ok ) *ok = false;
    return nullptr;
  }

  Package3dinstances* result = new Package3dinstances();

  QDomNode n;
  for( n = element.firstChild(); !n.isNull(); n = n.nextSibling() ) {
    QDomElement e = n.toElement();
    if ( e.tagName() == "package3dinstance" ) {
      bool ok;
      Package3dinstance *o = Package3dinstance::parseElement( e, &ok );
      if ( ok ) result->addPackage3dinstance( o );
    }
  }


  if ( ok ) *ok = true;
  return result;
}

void Package3dinstances::writeElement( QXmlStreamWriter &xml ) const
{
  if ( !mPackage3dinstanceList.isEmpty() ) {
    xml.writeStartElement( "package3dinstances" );
    foreach( Package3dinstance* e, mPackage3dinstanceList ) {
      if (e)
        e->writeElement( xml );
    }
    xml.writeEndElement();
  }
}


Technology::Technology()
{
}

Technology::~Technology()
{
}

void Technology::setName( const QString &v )
{
  mName = v;
}

QString Technology::name() const
{
  return mName;
}

void Technology::addAttribute( Attribute* v )
{
  mAttributeList.append( v );
}

void Technology::setAttributeList( const Attribute::List &v )
{
  mAttributeList = v;
}

Attribute::List *Technology::attributeList()
{
  return &mAttributeList;
}

Technology *Technology::parseElement( const QDomElement &element, bool *ok )
{
  if ( element.tagName() != "technology" ) {
    qCritical() << "Expected 'technology', got '" << element.tagName() << "'.";
    if ( ok ) *ok = false;
    return nullptr;
  }

  Technology* result = new Technology();

  QDomNode n;
  for( n = element.firstChild(); !n.isNull(); n = n.nextSibling() ) {
    QDomElement e = n.toElement();
    if ( e.tagName() == "attribute" ) {
      bool ok;
      Attribute *o = Attribute::parseElement( e, &ok );
      if ( ok ) result->addAttribute( o );
    }
  }

  result->setName( element.attribute( "name" ) );

  if ( ok ) *ok = true;
  return result;
}

void Technology::writeElement( QXmlStreamWriter &xml ) const
{
  xml.writeStartElement( "technology" );
  if (!mName.isEmpty())
    xml.writeAttribute("name", mName );
  foreach( Attribute* e, mAttributeList ) {
    if (e)
      e->writeElement( xml );
  }
  xml.writeEndElement();
}


Technologies::Technologies()
{
}

Technologies::~Technologies()
{
}

void Technologies::addTechnology( Technology* v )
{
  mTechnologyList.append( v );
}

void Technologies::setTechnologyList( const Technology::List &v )
{
  mTechnologyList = v;
}

Technology::List *Technologies::technologyList()
{
  return &mTechnologyList;
}

Technologies *Technologies::parseElement( const QDomElement &element, bool *ok )
{
  if ( element.tagName() != "technologies" ) {
    qCritical() << "Expected 'technologies', got '" << element.tagName() << "'.";
    if ( ok ) *ok = false;
    return nullptr;
  }

  Technologies* result = new Technologies();

  QDomNode n;
  for( n = element.firstChild(); !n.isNull(); n = n.nextSibling() ) {
    QDomElement e = n.toElement();
    if ( e.tagName() == "technology" ) {
      bool ok;
      Technology *o = Technology::parseElement( e, &ok );
      if ( ok ) result->addTechnology( o );
    }
  }


  if ( ok ) *ok = true;
  return result;
}

void Technologies::writeElement( QXmlStreamWriter &xml ) const
{
  if ( !mTechnologyList.isEmpty() ) {
    xml.writeStartElement( "technologies" );
    foreach( Technology* e, mTechnologyList ) {
      if (e)
        e->writeElement( xml );
    }
    xml.writeEndElement();
  }
}


Device::Device()
  : mConnects(nullptr), mPackage3dinstances(nullptr), mTechnologies(nullptr)
{
}

Device::~Device()
{
}

void Device::setName( const QString &v )
{
  mName = v;
}

QString Device::name() const
{
  return mName;
}

void Device::setPackage( const QString &v )
{
  mPackage = v;
}

QString Device::package() const
{
  return mPackage;
}

void Device::setConnects( Connects *v )
{
  mConnects = v;
}

Connects *Device::connects()
{
  return mConnects;
}

void Device::setPackage3dinstances( Package3dinstances *v )
{
  mPackage3dinstances = v;
}

Package3dinstances *Device::package3dinstances()
{
  return mPackage3dinstances;
}

void Device::setTechnologies( Technologies *v )
{
  mTechnologies = v;
}

Technologies *Device::technologies()
{
  return mTechnologies;
}

Device *Device::parseElement( const QDomElement &element, bool *ok )
{
  if ( element.tagName() != "device" ) {
    qCritical() << "Expected 'device', got '" << element.tagName() << "'.";
    if ( ok ) *ok = false;
    return nullptr;
  }

  Device* result = new Device();

  QDomNode n;
  for( n = element.firstChild(); !n.isNull(); n = n.nextSibling() ) {
    QDomElement e = n.toElement();
    if ( e.tagName() == "connects" ) {
      bool ok;
      Connects *o = Connects::parseElement( e, &ok );
      if ( ok ) result->setConnects( o );
    }
    else if ( e.tagName() == "package3dinstances" ) {
      bool ok;
      Package3dinstances *o = Package3dinstances::parseElement( e, &ok );
      if ( ok ) result->setPackage3dinstances( o );
    }
    else if ( e.tagName() == "technologies" ) {
      bool ok;
      Technologies *o = Technologies::parseElement( e, &ok );
      if ( ok ) result->setTechnologies( o );
    }
  }

  result->setName( element.attribute( "name" ) );
  result->setPackage( element.attribute( "package" ) );

  if ( ok ) *ok = true;
  return result;
}

void Device::writeElement( QXmlStreamWriter &xml ) const
{
  xml.writeStartElement( "device" );
  if (!mName.isEmpty())
    xml.writeAttribute("name", mName );
  if (!mPackage.isEmpty())
    xml.writeAttribute("package", mPackage );
  if (mConnects)
    mConnects->writeElement( xml );
  if (mPackage3dinstances)
    mPackage3dinstances->writeElement( xml );
  if (mTechnologies)
    mTechnologies->writeElement( xml );
  xml.writeEndElement();
}


Devices::Devices()
{
}

Devices::~Devices()
{
}

void Devices::addDevice( Device* v )
{
  mDeviceList.append( v );
}

void Devices::setDeviceList( const Device::List &v )
{
  mDeviceList = v;
}

Device::List *Devices::deviceList()
{
  return &mDeviceList;
}

Devices *Devices::parseElement( const QDomElement &element, bool *ok )
{
  if ( element.tagName() != "devices" ) {
    qCritical() << "Expected 'devices', got '" << element.tagName() << "'.";
    if ( ok ) *ok = false;
    return nullptr;
  }

  Devices* result = new Devices();

  QDomNode n;
  for( n = element.firstChild(); !n.isNull(); n = n.nextSibling() ) {
    QDomElement e = n.toElement();
    if ( e.tagName() == "device" ) {
      bool ok;
      Device *o = Device::parseElement( e, &ok );
      if ( ok ) result->addDevice( o );
    }
  }


  if ( ok ) *ok = true;
  return result;
}

void Devices::writeElement( QXmlStreamWriter &xml ) const
{
  if ( !mDeviceList.isEmpty() ) {
    xml.writeStartElement( "devices" );
    foreach( Device* e, mDeviceList ) {
      if (e)
        e->writeElement( xml );
    }
    xml.writeEndElement();
  }
}


Pinmap::Pinmap()
{
}

Pinmap::~Pinmap()
{
}

void Pinmap::setGate( const QString &v )
{
  mGate = v;
}

QString Pinmap::gate() const
{
  return mGate;
}

void Pinmap::setPin( const QString &v )
{
  mPin = v;
}

QString Pinmap::pin() const
{
  return mPin;
}

void Pinmap::setPinorder( const QString &v )
{
  mPinorder = v;
}

QString Pinmap::pinorder() const
{
  return mPinorder;
}

Pinmap *Pinmap::parseElement( const QDomElement &element, bool *ok )
{
  if ( element.tagName() != "pinmap" ) {
    qCritical() << "Expected 'pinmap', got '" << element.tagName() << "'.";
    if ( ok ) *ok = false;
    return nullptr;
  }

  Pinmap* result = new Pinmap();

  result->setGate( element.attribute( "gate" ) );
  result->setPin( element.attribute( "pin" ) );
  result->setPinorder( element.attribute( "pinorder" ) );

  if ( ok ) *ok = true;
  return result;
}

void Pinmap::writeElement( QXmlStreamWriter &xml ) const
{
  xml.writeStartElement( "pinmap" );
  if (!mGate.isEmpty())
    xml.writeAttribute("gate", mGate );
  if (!mPin.isEmpty())
    xml.writeAttribute("pin", mPin );
  if (!mPinorder.isEmpty())
    xml.writeAttribute("pinorder", mPinorder );
  xml.writeEndElement();
}


Pinmapping::Pinmapping()
  : mIsusermap(Isusermap_Invalid), mIddevicewide(Iddevicewide_Invalid)
{
}

Pinmapping::~Pinmapping()
{
}

void Pinmapping::setIsusermap( const IsusermapEnum &v )
{
  mIsusermap = v;
}

Pinmapping::IsusermapEnum Pinmapping::isusermap() const
{
  return mIsusermap;
}

void Pinmapping::setIddevicewide( const IddevicewideEnum &v )
{
  mIddevicewide = v;
}

Pinmapping::IddevicewideEnum Pinmapping::iddevicewide() const
{
  return mIddevicewide;
}

void Pinmapping::setSpiceprefix( const QString &v )
{
  mSpiceprefix = v;
}

QString Pinmapping::spiceprefix() const
{
  return mSpiceprefix;
}

void Pinmapping::addPinmap( Pinmap* v )
{
  mPinmapList.append( v );
}

void Pinmapping::setPinmapList( const Pinmap::List &v )
{
  mPinmapList = v;
}

Pinmap::List *Pinmapping::pinmapList()
{
  return &mPinmapList;
}

Pinmapping::IsusermapEnum Pinmapping::isusermapEnumFromString( const QString & v, bool *ok )
{
  if (ok) *ok = true;

  if ( v == "no" ) {
    return Isusermap_no;
  } else if ( v == "yes" ) {
    return Isusermap_yes;
  } else {
    if (ok) *ok = false;
    return Isusermap_Invalid;
  }

  return Isusermap_Invalid;
}

QString Pinmapping::isusermapEnumToString( const IsusermapEnum & v )
{
  switch( v ) {
  case Isusermap_no: return "no";
  case Isusermap_yes: return "yes";
  case Isusermap_Invalid:
  default:
    qCritical() << "Unable to serialize a(n) IsusermapEnum enum because it has invalid value:" << v;
    return QString();
  }
}

Pinmapping::IddevicewideEnum Pinmapping::iddevicewideEnumFromString( const QString & v, bool *ok )
{
  if (ok) *ok = true;

  if ( v == "no" ) {
    return Iddevicewide_no;
  } else if ( v == "yes" ) {
    return Iddevicewide_yes;
  } else {
    if (ok) *ok = false;
    return Iddevicewide_Invalid;
  }

  return Iddevicewide_Invalid;
}

QString Pinmapping::iddevicewideEnumToString( const IddevicewideEnum & v )
{
  switch( v ) {
  case Iddevicewide_no: return "no";
  case Iddevicewide_yes: return "yes";
  case Iddevicewide_Invalid:
  default:
    qCritical() << "Unable to serialize a(n) IddevicewideEnum enum because it has invalid value:" << v;
    return QString();
  }
}

Pinmapping *Pinmapping::parseElement( const QDomElement &element, bool *ok )
{
  if ( element.tagName() != "pinmapping" ) {
    qCritical() << "Expected 'pinmapping', got '" << element.tagName() << "'.";
    if ( ok ) *ok = false;
    return nullptr;
  }

  Pinmapping* result = new Pinmapping();

  QDomNode n;
  for( n = element.firstChild(); !n.isNull(); n = n.nextSibling() ) {
    QDomElement e = n.toElement();
    if ( e.tagName() == "pinmap" ) {
      bool ok;
      Pinmap *o = Pinmap::parseElement( e, &ok );
      if ( ok ) result->addPinmap( o );
    }
  }

  if (element.hasAttribute("isusermap"))  {
    IsusermapEnum isusermap = isusermapEnumFromString( element.attribute( "isusermap" ), ok  );
    if (ok && !(*ok)) {
      qCritical() << "Invalid string: \"" << element.attribute( "isusermap" ) << "\" in the \"isusermap\" element";
      return nullptr;
    } else {
      result->setIsusermap( isusermap );
    }
  } else {
    // default value
    result->setIsusermap(Isusermap_no);
  }
  if (element.hasAttribute("iddevicewide"))  {
    IddevicewideEnum iddevicewide = iddevicewideEnumFromString( element.attribute( "iddevicewide" ), ok  );
    if (ok && !(*ok)) {
      qCritical() << "Invalid string: \"" << element.attribute( "iddevicewide" ) << "\" in the \"iddevicewide\" element";
      return nullptr;
    } else {
      result->setIddevicewide( iddevicewide );
    }
  } else {
    // default value
    result->setIddevicewide(Iddevicewide_yes);
  }
  result->setSpiceprefix( element.attribute( "spiceprefix" ) );

  if ( ok ) *ok = true;
  return result;
}

void Pinmapping::writeElement( QXmlStreamWriter &xml ) const
{
  xml.writeStartElement( "pinmapping" );
  if (mIsusermap != Isusermap_Invalid)
    xml.writeAttribute("isusermap", isusermapEnumToString(mIsusermap));
  if (mIddevicewide != Iddevicewide_Invalid)
    xml.writeAttribute("iddevicewide", iddevicewideEnumToString(mIddevicewide));
  if (!mSpiceprefix.isEmpty())
    xml.writeAttribute("spiceprefix", mSpiceprefix );
  foreach( Pinmap* e, mPinmapList ) {
    if (e)
      e->writeElement( xml );
  }
  xml.writeEndElement();
}


Model::Model()
{
}

Model::~Model()
{
}

void Model::setName( const QString &v )
{
  mName = v;
}

QString Model::name() const
{
  return mName;
}

void Model::setValue( const QString &v )
{
  mValue = v;
}

QString Model::value() const
{
  return mValue;
}

Model *Model::parseElement( const QDomElement &element, bool *ok )
{
  if ( element.tagName() != "model" ) {
    qCritical() << "Expected 'model', got '" << element.tagName() << "'.";
    if ( ok ) *ok = false;
    return nullptr;
  }

  Model* result = new Model();

  result->setValue( element.text() );
  result->setName( element.attribute( "name" ) );

  if ( ok ) *ok = true;
  return result;
}

void Model::writeElement( QXmlStreamWriter &xml ) const
{
  if ( !value().isEmpty() ) {
    xml.writeStartElement( "model" );
    if (!mName.isEmpty())
      xml.writeAttribute("name", mName );
    xml.writeCharacters( value() );
    xml.writeEndElement();
  }
}


Spice::Spice()
  : mPinmapping(nullptr), mModel(nullptr)
{
}

Spice::~Spice()
{
}

void Spice::setPinmapping( Pinmapping *v )
{
  mPinmapping = v;
}

Pinmapping *Spice::pinmapping()
{
  return mPinmapping;
}

void Spice::setModel( Model *v )
{
  mModel = v;
}

Model *Spice::model()
{
  return mModel;
}

Spice *Spice::parseElement( const QDomElement &element, bool *ok )
{
  if ( element.tagName() != "spice" ) {
    qCritical() << "Expected 'spice', got '" << element.tagName() << "'.";
    if ( ok ) *ok = false;
    return nullptr;
  }

  Spice* result = new Spice();

  QDomNode n;
  for( n = element.firstChild(); !n.isNull(); n = n.nextSibling() ) {
    QDomElement e = n.toElement();
    if ( e.tagName() == "pinmapping" ) {
      bool ok;
      Pinmapping *o = Pinmapping::parseElement( e, &ok );
      if ( ok ) result->setPinmapping( o );
    }
    else if ( e.tagName() == "model" ) {
      bool ok;
      Model *o = Model::parseElement( e, &ok );
      if ( ok ) result->setModel( o );
    }
  }


  if ( ok ) *ok = true;
  return result;
}

void Spice::writeElement( QXmlStreamWriter &xml ) const
{
  xml.writeStartElement( "spice" );
  if (mPinmapping)
    mPinmapping->writeElement( xml );
  if (mModel)
    mModel->writeElement( xml );
  xml.writeEndElement();
}


Deviceset::Deviceset()
  : mLocallyModified(LocallyModified_Invalid), mUservalue(Uservalue_Invalid), mLibraryVersion(0), mLibraryVersion_set(false), mLibraryLocallyModified(LibraryLocallyModified_Invalid), mDescription(nullptr), mGates(nullptr), mDevices(nullptr), mSpice(nullptr)
{
}

Deviceset::~Deviceset()
{
}

void Deviceset::setName( const QString &v )
{
  mName = v;
}

QString Deviceset::name() const
{
  return mName;
}

void Deviceset::setUrn( const QString &v )
{
  mUrn = v;
}

QString Deviceset::urn() const
{
  return mUrn;
}

void Deviceset::setLocallyModified( const LocallyModifiedEnum &v )
{
  mLocallyModified = v;
}

Deviceset::LocallyModifiedEnum Deviceset::locallyModified() const
{
  return mLocallyModified;
}

void Deviceset::setPrefix( const QString &v )
{
  mPrefix = v;
}

QString Deviceset::prefix() const
{
  return mPrefix;
}

void Deviceset::setUservalue( const UservalueEnum &v )
{
  mUservalue = v;
}

Deviceset::UservalueEnum Deviceset::uservalue() const
{
  return mUservalue;
}

void Deviceset::setLibraryVersion( const int v )
{
  mLibraryVersion_set = true;
  mLibraryVersion = v;
}

int Deviceset::libraryVersion() const
{
  return mLibraryVersion;
}

bool Deviceset::libraryVersionSet() const
{
  return mLibraryVersion_set;
}

void Deviceset::setLibraryLocallyModified( const LibraryLocallyModifiedEnum &v )
{
  mLibraryLocallyModified = v;
}

Deviceset::LibraryLocallyModifiedEnum Deviceset::libraryLocallyModified() const
{
  return mLibraryLocallyModified;
}

void Deviceset::setDescription( Description *v )
{
  mDescription = v;
}

Description *Deviceset::description()
{
  return mDescription;
}

void Deviceset::setGates( Gates *v )
{
  mGates = v;
}

Gates *Deviceset::gates()
{
  return mGates;
}

void Deviceset::setDevices( Devices *v )
{
  mDevices = v;
}

Devices *Deviceset::devices()
{
  return mDevices;
}

void Deviceset::setSpice( Spice *v )
{
  mSpice = v;
}

Spice *Deviceset::spice()
{
  return mSpice;
}

Deviceset::LocallyModifiedEnum Deviceset::locallyModifiedEnumFromString( const QString & v, bool *ok )
{
  if (ok) *ok = true;

  if ( v == "no" ) {
    return LocallyModified_no;
  } else if ( v == "yes" ) {
    return LocallyModified_yes;
  } else {
    if (ok) *ok = false;
    return LocallyModified_Invalid;
  }

  return LocallyModified_Invalid;
}

QString Deviceset::locallyModifiedEnumToString( const LocallyModifiedEnum & v )
{
  switch( v ) {
  case LocallyModified_no: return "no";
  case LocallyModified_yes: return "yes";
  case LocallyModified_Invalid:
  default:
    qCritical() << "Unable to serialize a(n) LocallyModifiedEnum enum because it has invalid value:" << v;
    return QString();
  }
}

Deviceset::UservalueEnum Deviceset::uservalueEnumFromString( const QString & v, bool *ok )
{
  if (ok) *ok = true;

  if ( v == "no" ) {
    return Uservalue_no;
  } else if ( v == "yes" ) {
    return Uservalue_yes;
  } else {
    if (ok) *ok = false;
    return Uservalue_Invalid;
  }

  return Uservalue_Invalid;
}

QString Deviceset::uservalueEnumToString( const UservalueEnum & v )
{
  switch( v ) {
  case Uservalue_no: return "no";
  case Uservalue_yes: return "yes";
  case Uservalue_Invalid:
  default:
    qCritical() << "Unable to serialize a(n) UservalueEnum enum because it has invalid value:" << v;
    return QString();
  }
}

Deviceset::LibraryLocallyModifiedEnum Deviceset::libraryLocallyModifiedEnumFromString( const QString & v, bool *ok )
{
  if (ok) *ok = true;

  if ( v == "no" ) {
    return LibraryLocallyModified_no;
  } else if ( v == "yes" ) {
    return LibraryLocallyModified_yes;
  } else {
    if (ok) *ok = false;
    return LibraryLocallyModified_Invalid;
  }

  return LibraryLocallyModified_Invalid;
}

QString Deviceset::libraryLocallyModifiedEnumToString( const LibraryLocallyModifiedEnum & v )
{
  switch( v ) {
  case LibraryLocallyModified_no: return "no";
  case LibraryLocallyModified_yes: return "yes";
  case LibraryLocallyModified_Invalid:
  default:
    qCritical() << "Unable to serialize a(n) LibraryLocallyModifiedEnum enum because it has invalid value:" << v;
    return QString();
  }
}

Deviceset *Deviceset::parseElement( const QDomElement &element, bool *ok )
{
  if ( element.tagName() != "deviceset" ) {
    qCritical() << "Expected 'deviceset', got '" << element.tagName() << "'.";
    if ( ok ) *ok = false;
    return nullptr;
  }

  Deviceset* result = new Deviceset();

  QDomNode n;
  for( n = element.firstChild(); !n.isNull(); n = n.nextSibling() ) {
    QDomElement e = n.toElement();
    if ( e.tagName() == "description" ) {
      bool ok;
      Description *o = Description::parseElement( e, &ok );
      if ( ok ) result->setDescription( o );
    }
    else if ( e.tagName() == "gates" ) {
      bool ok;
      Gates *o = Gates::parseElement( e, &ok );
      if ( ok ) result->setGates( o );
    }
    else if ( e.tagName() == "devices" ) {
      bool ok;
      Devices *o = Devices::parseElement( e, &ok );
      if ( ok ) result->setDevices( o );
    }
    else if ( e.tagName() == "spice" ) {
      bool ok;
      Spice *o = Spice::parseElement( e, &ok );
      if ( ok ) result->setSpice( o );
    }
  }

  result->setName( element.attribute( "name" ) );
  result->setUrn( element.attribute( "urn" ) );
  if (element.hasAttribute("locally_modified"))  {
    LocallyModifiedEnum locally_modified = locallyModifiedEnumFromString( element.attribute( "locally_modified" ), ok  );
    if (ok && !(*ok)) {
      qCritical() << "Invalid string: \"" << element.attribute( "locally_modified" ) << "\" in the \"locally_modified\" element";
      return nullptr;
    } else {
      result->setLocallyModified( locally_modified );
    }
  } else {
    // default value
    result->setLocallyModified(LocallyModified_no);
  }
  result->setPrefix( element.attribute( "prefix" ) );
  if (element.hasAttribute("uservalue"))  {
    UservalueEnum uservalue = uservalueEnumFromString( element.attribute( "uservalue" ), ok  );
    if (ok && !(*ok)) {
      qCritical() << "Invalid string: \"" << element.attribute( "uservalue" ) << "\" in the \"uservalue\" element";
      return nullptr;
    } else {
      result->setUservalue( uservalue );
    }
  } else {
    // default value
    result->setUservalue(Uservalue_no);
  }
  if (element.hasAttribute("library_version"))
    result->setLibraryVersion( element.attribute( "library_version" ).toInt() );
  if (element.hasAttribute("library_locally_modified"))  {
    LibraryLocallyModifiedEnum library_locally_modified = libraryLocallyModifiedEnumFromString( element.attribute( "library_locally_modified" ), ok  );
    if (ok && !(*ok)) {
      qCritical() << "Invalid string: \"" << element.attribute( "library_locally_modified" ) << "\" in the \"library_locally_modified\" element";
      return nullptr;
    } else {
      result->setLibraryLocallyModified( library_locally_modified );
    }
  } else {
    // default value
    result->setLibraryLocallyModified(LibraryLocallyModified_no);
  }

  if ( ok ) *ok = true;
  return result;
}

void Deviceset::writeElement( QXmlStreamWriter &xml ) const
{
  xml.writeStartElement( "deviceset" );
  if (!mName.isEmpty())
    xml.writeAttribute("name", mName );
  if (!mUrn.isEmpty())
    xml.writeAttribute("urn", mUrn );
  if (mLocallyModified != LocallyModified_Invalid)
    xml.writeAttribute("locally_modified", locallyModifiedEnumToString(mLocallyModified));
  if (!mPrefix.isEmpty())
    xml.writeAttribute("prefix", mPrefix );
  if (mUservalue != Uservalue_Invalid)
    xml.writeAttribute("uservalue", uservalueEnumToString(mUservalue));
  if (mLibraryVersion_set)
    xml.writeAttribute("library_version", QString::number( mLibraryVersion ) );
  if (mLibraryLocallyModified != LibraryLocallyModified_Invalid)
    xml.writeAttribute("library_locally_modified", libraryLocallyModifiedEnumToString(mLibraryLocallyModified));
  if (mDescription)
    mDescription->writeElement( xml );
  if (mGates)
    mGates->writeElement( xml );
  if (mDevices)
    mDevices->writeElement( xml );
  if (mSpice)
    mSpice->writeElement( xml );
  xml.writeEndElement();
}


Devicesets::Devicesets()
{
}

Devicesets::~Devicesets()
{
}

void Devicesets::addDeviceset( Deviceset* v )
{
  mDevicesetList.append( v );
}

void Devicesets::setDevicesetList( const Deviceset::List &v )
{
  mDevicesetList = v;
}

Deviceset::List *Devicesets::devicesetList()
{
  return &mDevicesetList;
}

Devicesets *Devicesets::parseElement( const QDomElement &element, bool *ok )
{
  if ( element.tagName() != "devicesets" ) {
    qCritical() << "Expected 'devicesets', got '" << element.tagName() << "'.";
    if ( ok ) *ok = false;
    return nullptr;
  }

  Devicesets* result = new Devicesets();

  QDomNode n;
  for( n = element.firstChild(); !n.isNull(); n = n.nextSibling() ) {
    QDomElement e = n.toElement();
    if ( e.tagName() == "deviceset" ) {
      bool ok;
      Deviceset *o = Deviceset::parseElement( e, &ok );
      if ( ok ) result->addDeviceset( o );
    }
  }


  if ( ok ) *ok = true;
  return result;
}

void Devicesets::writeElement( QXmlStreamWriter &xml ) const
{
  if ( !mDevicesetList.isEmpty() ) {
    xml.writeStartElement( "devicesets" );
    foreach( Deviceset* e, mDevicesetList ) {
      if (e)
        e->writeElement( xml );
    }
    xml.writeEndElement();
  }
}


Library::Library()
  : mDescription(nullptr), mPackages(nullptr), mPackages3d(nullptr), mSymbols(nullptr), mDevicesets(nullptr)
{
}

Library::~Library()
{
}

void Library::setName( const QString &v )
{
  mName = v;
}

QString Library::name() const
{
  return mName;
}

void Library::setUrn( const QString &v )
{
  mUrn = v;
}

QString Library::urn() const
{
  return mUrn;
}

void Library::setDescription( Description *v )
{
  mDescription = v;
}

Description *Library::description()
{
  return mDescription;
}

void Library::setPackages( Packages *v )
{
  mPackages = v;
}

Packages *Library::packages()
{
  return mPackages;
}

void Library::setPackages3d( Packages3d *v )
{
  mPackages3d = v;
}

Packages3d *Library::packages3d()
{
  return mPackages3d;
}

void Library::setSymbols( Symbols *v )
{
  mSymbols = v;
}

Symbols *Library::symbols()
{
  return mSymbols;
}

void Library::setDevicesets( Devicesets *v )
{
  mDevicesets = v;
}

Devicesets *Library::devicesets()
{
  return mDevicesets;
}

Library *Library::parseElement( const QDomElement &element, bool *ok )
{
  if ( element.tagName() != "library" ) {
    qCritical() << "Expected 'library', got '" << element.tagName() << "'.";
    if ( ok ) *ok = false;
    return nullptr;
  }

  Library* result = new Library();

  QDomNode n;
  for( n = element.firstChild(); !n.isNull(); n = n.nextSibling() ) {
    QDomElement e = n.toElement();
    if ( e.tagName() == "description" ) {
      bool ok;
      Description *o = Description::parseElement( e, &ok );
      if ( ok ) result->setDescription( o );
    }
    else if ( e.tagName() == "packages" ) {
      bool ok;
      Packages *o = Packages::parseElement( e, &ok );
      if ( ok ) result->setPackages( o );
    }
    else if ( e.tagName() == "packages3d" ) {
      bool ok;
      Packages3d *o = Packages3d::parseElement( e, &ok );
      if ( ok ) result->setPackages3d( o );
    }
    else if ( e.tagName() == "symbols" ) {
      bool ok;
      Symbols *o = Symbols::parseElement( e, &ok );
      if ( ok ) result->setSymbols( o );
    }
    else if ( e.tagName() == "devicesets" ) {
      bool ok;
      Devicesets *o = Devicesets::parseElement( e, &ok );
      if ( ok ) result->setDevicesets( o );
    }
  }

  result->setName( element.attribute( "name" ) );
  result->setUrn( element.attribute( "urn" ) );

  if ( ok ) *ok = true;
  return result;
}

void Library::writeElement( QXmlStreamWriter &xml ) const
{
  xml.writeStartElement( "library" );
  if (!mName.isEmpty())
    xml.writeAttribute("name", mName );
  if (!mUrn.isEmpty())
    xml.writeAttribute("urn", mUrn );
  if (mDescription)
    mDescription->writeElement( xml );
  if (mPackages)
    mPackages->writeElement( xml );
  if (mPackages3d)
    mPackages3d->writeElement( xml );
  if (mSymbols)
    mSymbols->writeElement( xml );
  if (mDevicesets)
    mDevicesets->writeElement( xml );
  xml.writeEndElement();
}


Libraries::Libraries()
{
}

Libraries::~Libraries()
{
}

void Libraries::addLibrary( Library* v )
{
  mLibraryList.append( v );
}

void Libraries::setLibraryList( const Library::List &v )
{
  mLibraryList = v;
}

Library::List *Libraries::libraryList()
{
  return &mLibraryList;
}

Libraries *Libraries::parseElement( const QDomElement &element, bool *ok )
{
  if ( element.tagName() != "libraries" ) {
    qCritical() << "Expected 'libraries', got '" << element.tagName() << "'.";
    if ( ok ) *ok = false;
    return nullptr;
  }

  Libraries* result = new Libraries();

  QDomNode n;
  for( n = element.firstChild(); !n.isNull(); n = n.nextSibling() ) {
    QDomElement e = n.toElement();
    if ( e.tagName() == "library" ) {
      bool ok;
      Library *o = Library::parseElement( e, &ok );
      if ( ok ) result->addLibrary( o );
    }
  }


  if ( ok ) *ok = true;
  return result;
}

void Libraries::writeElement( QXmlStreamWriter &xml ) const
{
  if ( !mLibraryList.isEmpty() ) {
    xml.writeStartElement( "libraries" );
    foreach( Library* e, mLibraryList ) {
      if (e)
        e->writeElement( xml );
    }
    xml.writeEndElement();
  }
}


Attributes::Attributes()
{
}

Attributes::~Attributes()
{
}

void Attributes::addAttribute( Attribute* v )
{
  mAttributeList.append( v );
}

void Attributes::setAttributeList( const Attribute::List &v )
{
  mAttributeList = v;
}

Attribute::List *Attributes::attributeList()
{
  return &mAttributeList;
}

Attributes *Attributes::parseElement( const QDomElement &element, bool *ok )
{
  if ( element.tagName() != "attributes" ) {
    qCritical() << "Expected 'attributes', got '" << element.tagName() << "'.";
    if ( ok ) *ok = false;
    return nullptr;
  }

  Attributes* result = new Attributes();

  QDomNode n;
  for( n = element.firstChild(); !n.isNull(); n = n.nextSibling() ) {
    QDomElement e = n.toElement();
    if ( e.tagName() == "attribute" ) {
      bool ok;
      Attribute *o = Attribute::parseElement( e, &ok );
      if ( ok ) result->addAttribute( o );
    }
  }


  if ( ok ) *ok = true;
  return result;
}

void Attributes::writeElement( QXmlStreamWriter &xml ) const
{
  if ( !mAttributeList.isEmpty() ) {
    xml.writeStartElement( "attributes" );
    foreach( Attribute* e, mAttributeList ) {
      if (e)
        e->writeElement( xml );
    }
    xml.writeEndElement();
  }
}


Variantdef::Variantdef()
  : mCurrent(Current_Invalid)
{
}

Variantdef::~Variantdef()
{
}

void Variantdef::setName( const QString &v )
{
  mName = v;
}

QString Variantdef::name() const
{
  return mName;
}

void Variantdef::setCurrent( const CurrentEnum &v )
{
  mCurrent = v;
}

Variantdef::CurrentEnum Variantdef::current() const
{
  return mCurrent;
}

Variantdef::CurrentEnum Variantdef::currentEnumFromString( const QString & v, bool *ok )
{
  if (ok) *ok = true;

  if ( v == "no" ) {
    return Current_no;
  } else if ( v == "yes" ) {
    return Current_yes;
  } else {
    if (ok) *ok = false;
    return Current_Invalid;
  }

  return Current_Invalid;
}

QString Variantdef::currentEnumToString( const CurrentEnum & v )
{
  switch( v ) {
  case Current_no: return "no";
  case Current_yes: return "yes";
  case Current_Invalid:
  default:
    qCritical() << "Unable to serialize a(n) CurrentEnum enum because it has invalid value:" << v;
    return QString();
  }
}

Variantdef *Variantdef::parseElement( const QDomElement &element, bool *ok )
{
  if ( element.tagName() != "variantdef" ) {
    qCritical() << "Expected 'variantdef', got '" << element.tagName() << "'.";
    if ( ok ) *ok = false;
    return nullptr;
  }

  Variantdef* result = new Variantdef();

  result->setName( element.attribute( "name" ) );
  if (element.hasAttribute("current"))  {
    CurrentEnum current = currentEnumFromString( element.attribute( "current" ), ok  );
    if (ok && !(*ok)) {
      qCritical() << "Invalid string: \"" << element.attribute( "current" ) << "\" in the \"current\" element";
      return nullptr;
    } else {
      result->setCurrent( current );
    }
  } else {
    // default value
    result->setCurrent(Current_no);
  }

  if ( ok ) *ok = true;
  return result;
}

void Variantdef::writeElement( QXmlStreamWriter &xml ) const
{
  xml.writeStartElement( "variantdef" );
  if (!mName.isEmpty())
    xml.writeAttribute("name", mName );
  if (mCurrent != Current_Invalid)
    xml.writeAttribute("current", currentEnumToString(mCurrent));
  xml.writeEndElement();
}


Variantdefs::Variantdefs()
{
}

Variantdefs::~Variantdefs()
{
}

void Variantdefs::addVariantdef( Variantdef* v )
{
  mVariantdefList.append( v );
}

void Variantdefs::setVariantdefList( const Variantdef::List &v )
{
  mVariantdefList = v;
}

Variantdef::List *Variantdefs::variantdefList()
{
  return &mVariantdefList;
}

Variantdefs *Variantdefs::parseElement( const QDomElement &element, bool *ok )
{
  if ( element.tagName() != "variantdefs" ) {
    qCritical() << "Expected 'variantdefs', got '" << element.tagName() << "'.";
    if ( ok ) *ok = false;
    return nullptr;
  }

  Variantdefs* result = new Variantdefs();

  QDomNode n;
  for( n = element.firstChild(); !n.isNull(); n = n.nextSibling() ) {
    QDomElement e = n.toElement();
    if ( e.tagName() == "variantdef" ) {
      bool ok;
      Variantdef *o = Variantdef::parseElement( e, &ok );
      if ( ok ) result->addVariantdef( o );
    }
  }


  if ( ok ) *ok = true;
  return result;
}

void Variantdefs::writeElement( QXmlStreamWriter &xml ) const
{
  if ( !mVariantdefList.isEmpty() ) {
    xml.writeStartElement( "variantdefs" );
    foreach( Variantdef* e, mVariantdefList ) {
      if (e)
        e->writeElement( xml );
    }
    xml.writeEndElement();
  }
}


Clearance::Clearance()
  : mClass(0), mClass_set(false), mValue(0.0), mValue_set(false)
{
}

Clearance::~Clearance()
{
}

void Clearance::setClass( const int v )
{
  mClass_set = true;
  mClass = v;
}

int Clearance::class_() const
{
  return mClass;
}

bool Clearance::classSet() const
{
  return mClass_set;
}

void Clearance::setValue( const double v )
{
  mValue_set = true;
  mValue = v;
}

double Clearance::value() const
{
  return mValue;
}

bool Clearance::valueSet() const
{
  return mValue_set;
}

Clearance *Clearance::parseElement( const QDomElement &element, bool *ok )
{
  if ( element.tagName() != "clearance" ) {
    qCritical() << "Expected 'clearance', got '" << element.tagName() << "'.";
    if ( ok ) *ok = false;
    return nullptr;
  }

  Clearance* result = new Clearance();

  if (element.hasAttribute("class"))
    result->setClass( element.attribute( "class" ).toInt() );
  if (element.hasAttribute("value"))
    result->setValue( element.attribute( "value" ).toDouble() );

  if ( ok ) *ok = true;
  return result;
}

void Clearance::writeElement( QXmlStreamWriter &xml ) const
{
  xml.writeStartElement( "clearance" );
  if (mClass_set)
    xml.writeAttribute("class", QString::number( mClass ) );
  if (mValue_set)
    xml.writeAttribute("value", QString::number( mValue ) );
  xml.writeEndElement();
}


Class::Class()
  : mNumber(0), mNumber_set(false), mWidth(0.0), mWidth_set(false), mDrill(0.0), mDrill_set(false)
{
}

Class::~Class()
{
}

void Class::setNumber( const int v )
{
  mNumber_set = true;
  mNumber = v;
}

int Class::number() const
{
  return mNumber;
}

bool Class::numberSet() const
{
  return mNumber_set;
}

void Class::setName( const QString &v )
{
  mName = v;
}

QString Class::name() const
{
  return mName;
}

void Class::setWidth( const double v )
{
  mWidth_set = true;
  mWidth = v;
}

double Class::width() const
{
  return mWidth;
}

bool Class::widthSet() const
{
  return mWidth_set;
}

void Class::setDrill( const double v )
{
  mDrill_set = true;
  mDrill = v;
}

double Class::drill() const
{
  return mDrill;
}

bool Class::drillSet() const
{
  return mDrill_set;
}

void Class::addClearance( Clearance* v )
{
  mClearanceList.append( v );
}

void Class::setClearanceList( const Clearance::List &v )
{
  mClearanceList = v;
}

Clearance::List *Class::clearanceList()
{
  return &mClearanceList;
}

Class *Class::parseElement( const QDomElement &element, bool *ok )
{
  if ( element.tagName() != "class" ) {
    qCritical() << "Expected 'class', got '" << element.tagName() << "'.";
    if ( ok ) *ok = false;
    return nullptr;
  }

  Class* result = new Class();

  QDomNode n;
  for( n = element.firstChild(); !n.isNull(); n = n.nextSibling() ) {
    QDomElement e = n.toElement();
    if ( e.tagName() == "clearance" ) {
      bool ok;
      Clearance *o = Clearance::parseElement( e, &ok );
      if ( ok ) result->addClearance( o );
    }
  }

  if (element.hasAttribute("number"))
    result->setNumber( element.attribute( "number" ).toInt() );
  result->setName( element.attribute( "name" ) );
  if (element.hasAttribute("width"))
    result->setWidth( element.attribute( "width" ).toDouble() );
  if (element.hasAttribute("drill"))
    result->setDrill( element.attribute( "drill" ).toDouble() );

  if ( ok ) *ok = true;
  return result;
}

void Class::writeElement( QXmlStreamWriter &xml ) const
{
  xml.writeStartElement( "class" );
  if (mNumber_set)
    xml.writeAttribute("number", QString::number( mNumber ) );
  if (!mName.isEmpty())
    xml.writeAttribute("name", mName );
  if (mWidth_set)
    xml.writeAttribute("width", QString::number( mWidth ) );
  if (mDrill_set)
    xml.writeAttribute("drill", QString::number( mDrill ) );
  foreach( Clearance* e, mClearanceList ) {
    if (e)
      e->writeElement( xml );
  }
  xml.writeEndElement();
}


Classes::Classes()
{
}

Classes::~Classes()
{
}

void Classes::addClass( Class* v )
{
  mClassList.append( v );
}

void Classes::setClassList( const Class::List &v )
{
  mClassList = v;
}

Class::List *Classes::classList()
{
  return &mClassList;
}

Classes *Classes::parseElement( const QDomElement &element, bool *ok )
{
  if ( element.tagName() != "classes" ) {
    qCritical() << "Expected 'classes', got '" << element.tagName() << "'.";
    if ( ok ) *ok = false;
    return nullptr;
  }

  Classes* result = new Classes();

  QDomNode n;
  for( n = element.firstChild(); !n.isNull(); n = n.nextSibling() ) {
    QDomElement e = n.toElement();
    if ( e.tagName() == "class" ) {
      bool ok;
      Class *o = Class::parseElement( e, &ok );
      if ( ok ) result->addClass( o );
    }
  }


  if ( ok ) *ok = true;
  return result;
}

void Classes::writeElement( QXmlStreamWriter &xml ) const
{
  if ( !mClassList.isEmpty() ) {
    xml.writeStartElement( "classes" );
    foreach( Class* e, mClassList ) {
      if (e)
        e->writeElement( xml );
    }
    xml.writeEndElement();
  }
}


Approved::Approved()
{
}

Approved::~Approved()
{
}

void Approved::setHash( const QString &v )
{
  mHash = v;
}

QString Approved::hash() const
{
  return mHash;
}

Approved *Approved::parseElement( const QDomElement &element, bool *ok )
{
  if ( element.tagName() != "approved" ) {
    qCritical() << "Expected 'approved', got '" << element.tagName() << "'.";
    if ( ok ) *ok = false;
    return nullptr;
  }

  Approved* result = new Approved();

  result->setHash( element.attribute( "hash" ) );

  if ( ok ) *ok = true;
  return result;
}

void Approved::writeElement( QXmlStreamWriter &xml ) const
{
  xml.writeStartElement( "approved" );
  if (!mHash.isEmpty())
    xml.writeAttribute("hash", mHash );
  xml.writeEndElement();
}


Errors::Errors()
{
}

Errors::~Errors()
{
}

void Errors::addApproved( Approved* v )
{
  mApprovedList.append( v );
}

void Errors::setApprovedList( const Approved::List &v )
{
  mApprovedList = v;
}

Approved::List *Errors::approvedList()
{
  return &mApprovedList;
}

Errors *Errors::parseElement( const QDomElement &element, bool *ok )
{
  if ( element.tagName() != "errors" ) {
    qCritical() << "Expected 'errors', got '" << element.tagName() << "'.";
    if ( ok ) *ok = false;
    return nullptr;
  }

  Errors* result = new Errors();

  QDomNode n;
  for( n = element.firstChild(); !n.isNull(); n = n.nextSibling() ) {
    QDomElement e = n.toElement();
    if ( e.tagName() == "approved" ) {
      bool ok;
      Approved *o = Approved::parseElement( e, &ok );
      if ( ok ) result->addApproved( o );
    }
  }


  if ( ok ) *ok = true;
  return result;
}

void Errors::writeElement( QXmlStreamWriter &xml ) const
{
  if ( !mApprovedList.isEmpty() ) {
    xml.writeStartElement( "errors" );
    foreach( Approved* e, mApprovedList ) {
      if (e)
        e->writeElement( xml );
    }
    xml.writeEndElement();
  }
}


Board::Board()
  : mLimitedwidth(0.0), mLimitedwidth_set(false), mDescription(nullptr), mFusionsync(nullptr), mPlain(nullptr), mLibraries(nullptr), mAttributes(nullptr), mVariantdefs(nullptr), mClasses(nullptr), mDesignrules(nullptr), mAutorouter(nullptr), mElements(nullptr), mSignals(nullptr), mMfgpreviewcolors(nullptr), mErrors(nullptr)
{
}

Board::~Board()
{
}

void Board::setLimitedwidth( const double v )
{
  mLimitedwidth_set = true;
  mLimitedwidth = v;
}

double Board::limitedwidth() const
{
  return mLimitedwidth;
}

bool Board::limitedwidthSet() const
{
  return mLimitedwidth_set;
}

void Board::setDescription( Description *v )
{
  mDescription = v;
}

Description *Board::description()
{
  return mDescription;
}

void Board::setFusionsync( Fusionsync *v )
{
  mFusionsync = v;
}

Fusionsync *Board::fusionsync()
{
  return mFusionsync;
}

void Board::setPlain( Plain *v )
{
  mPlain = v;
}

Plain *Board::plain()
{
  return mPlain;
}

void Board::setLibraries( Libraries *v )
{
  mLibraries = v;
}

Libraries *Board::libraries()
{
  return mLibraries;
}

void Board::setAttributes( Attributes *v )
{
  mAttributes = v;
}

Attributes *Board::attributes()
{
  return mAttributes;
}

void Board::setVariantdefs( Variantdefs *v )
{
  mVariantdefs = v;
}

Variantdefs *Board::variantdefs()
{
  return mVariantdefs;
}

void Board::setClasses( Classes *v )
{
  mClasses = v;
}

Classes *Board::classes()
{
  return mClasses;
}

void Board::setDesignrules( Designrules *v )
{
  mDesignrules = v;
}

Designrules *Board::designrules()
{
  return mDesignrules;
}

void Board::setAutorouter( Autorouter *v )
{
  mAutorouter = v;
}

Autorouter *Board::autorouter()
{
  return mAutorouter;
}

void Board::setElements( Elements *v )
{
  mElements = v;
}

Elements *Board::elements()
{
  return mElements;
}

void Board::setSignals( Signals *v )
{
  mSignals = v;
}

Signals *Board::signals_()
{
  return mSignals;
}

void Board::setMfgpreviewcolors( Mfgpreviewcolors *v )
{
  mMfgpreviewcolors = v;
}

Mfgpreviewcolors *Board::mfgpreviewcolors()
{
  return mMfgpreviewcolors;
}

void Board::setErrors( Errors *v )
{
  mErrors = v;
}

Errors *Board::errors()
{
  return mErrors;
}

Board *Board::parseElement( const QDomElement &element, bool *ok )
{
  if ( element.tagName() != "board" ) {
    qCritical() << "Expected 'board', got '" << element.tagName() << "'.";
    if ( ok ) *ok = false;
    return nullptr;
  }

  Board* result = new Board();

  QDomNode n;
  for( n = element.firstChild(); !n.isNull(); n = n.nextSibling() ) {
    QDomElement e = n.toElement();
    if ( e.tagName() == "description" ) {
      bool ok;
      Description *o = Description::parseElement( e, &ok );
      if ( ok ) result->setDescription( o );
    }
    else if ( e.tagName() == "fusionsync" ) {
      bool ok;
      Fusionsync *o = Fusionsync::parseElement( e, &ok );
      if ( ok ) result->setFusionsync( o );
    }
    else if ( e.tagName() == "plain" ) {
      bool ok;
      Plain *o = Plain::parseElement( e, &ok );
      if ( ok ) result->setPlain( o );
    }
    else if ( e.tagName() == "libraries" ) {
      bool ok;
      Libraries *o = Libraries::parseElement( e, &ok );
      if ( ok ) result->setLibraries( o );
    }
    else if ( e.tagName() == "attributes" ) {
      bool ok;
      Attributes *o = Attributes::parseElement( e, &ok );
      if ( ok ) result->setAttributes( o );
    }
    else if ( e.tagName() == "variantdefs" ) {
      bool ok;
      Variantdefs *o = Variantdefs::parseElement( e, &ok );
      if ( ok ) result->setVariantdefs( o );
    }
    else if ( e.tagName() == "classes" ) {
      bool ok;
      Classes *o = Classes::parseElement( e, &ok );
      if ( ok ) result->setClasses( o );
    }
    else if ( e.tagName() == "designrules" ) {
      bool ok;
      Designrules *o = Designrules::parseElement( e, &ok );
      if ( ok ) result->setDesignrules( o );
    }
    else if ( e.tagName() == "autorouter" ) {
      bool ok;
      Autorouter *o = Autorouter::parseElement( e, &ok );
      if ( ok ) result->setAutorouter( o );
    }
    else if ( e.tagName() == "elements" ) {
      bool ok;
      Elements *o = Elements::parseElement( e, &ok );
      if ( ok ) result->setElements( o );
    }
    else if ( e.tagName() == "signals" ) {
      bool ok;
      Signals *o = Signals::parseElement( e, &ok );
      if ( ok ) result->setSignals( o );
    }
    else if ( e.tagName() == "mfgpreviewcolors" ) {
      bool ok;
      Mfgpreviewcolors *o = Mfgpreviewcolors::parseElement( e, &ok );
      if ( ok ) result->setMfgpreviewcolors( o );
    }
    else if ( e.tagName() == "errors" ) {
      bool ok;
      Errors *o = Errors::parseElement( e, &ok );
      if ( ok ) result->setErrors( o );
    }
  }

  if (element.hasAttribute("limitedwidth"))
    result->setLimitedwidth( element.attribute( "limitedwidth" ).toDouble() );

  if ( ok ) *ok = true;
  return result;
}

void Board::writeElement( QXmlStreamWriter &xml ) const
{
  xml.writeStartElement( "board" );
  if (mLimitedwidth_set)
    xml.writeAttribute("limitedwidth", QString::number( mLimitedwidth ) );
  if (mDescription)
    mDescription->writeElement( xml );
  if (mFusionsync)
    mFusionsync->writeElement( xml );
  if (mPlain)
    mPlain->writeElement( xml );
  if (mLibraries)
    mLibraries->writeElement( xml );
  if (mAttributes)
    mAttributes->writeElement( xml );
  if (mVariantdefs)
    mVariantdefs->writeElement( xml );
  if (mClasses)
    mClasses->writeElement( xml );
  if (mDesignrules)
    mDesignrules->writeElement( xml );
  if (mAutorouter)
    mAutorouter->writeElement( xml );
  if (mElements)
    mElements->writeElement( xml );
  if (mSignals)
    mSignals->writeElement( xml );
  if (mMfgpreviewcolors)
    mMfgpreviewcolors->writeElement( xml );
  if (mErrors)
    mErrors->writeElement( xml );
  xml.writeEndElement();
}


Pinref::Pinref()
{
}

Pinref::~Pinref()
{
}

void Pinref::setPart( const QString &v )
{
  mPart = v;
}

QString Pinref::part() const
{
  return mPart;
}

void Pinref::setGate( const QString &v )
{
  mGate = v;
}

QString Pinref::gate() const
{
  return mGate;
}

void Pinref::setPin( const QString &v )
{
  mPin = v;
}

QString Pinref::pin() const
{
  return mPin;
}

Pinref *Pinref::parseElement( const QDomElement &element, bool *ok )
{
  if ( element.tagName() != "pinref" ) {
    qCritical() << "Expected 'pinref', got '" << element.tagName() << "'.";
    if ( ok ) *ok = false;
    return nullptr;
  }

  Pinref* result = new Pinref();

  result->setPart( element.attribute( "part" ) );
  result->setGate( element.attribute( "gate" ) );
  result->setPin( element.attribute( "pin" ) );

  if ( ok ) *ok = true;
  return result;
}

void Pinref::writeElement( QXmlStreamWriter &xml ) const
{
  xml.writeStartElement( "pinref" );
  if (!mPart.isEmpty())
    xml.writeAttribute("part", mPart );
  if (!mGate.isEmpty())
    xml.writeAttribute("gate", mGate );
  if (!mPin.isEmpty())
    xml.writeAttribute("pin", mPin );
  xml.writeEndElement();
}


Portref::Portref()
{
}

Portref::~Portref()
{
}

void Portref::setModuleinst( const QString &v )
{
  mModuleinst = v;
}

QString Portref::moduleinst() const
{
  return mModuleinst;
}

void Portref::setPort( const QString &v )
{
  mPort = v;
}

QString Portref::port() const
{
  return mPort;
}

Portref *Portref::parseElement( const QDomElement &element, bool *ok )
{
  if ( element.tagName() != "portref" ) {
    qCritical() << "Expected 'portref', got '" << element.tagName() << "'.";
    if ( ok ) *ok = false;
    return nullptr;
  }

  Portref* result = new Portref();

  result->setModuleinst( element.attribute( "moduleinst" ) );
  result->setPort( element.attribute( "port" ) );

  if ( ok ) *ok = true;
  return result;
}

void Portref::writeElement( QXmlStreamWriter &xml ) const
{
  xml.writeStartElement( "portref" );
  if (!mModuleinst.isEmpty())
    xml.writeAttribute("moduleinst", mModuleinst );
  if (!mPort.isEmpty())
    xml.writeAttribute("port", mPort );
  xml.writeEndElement();
}


Junction::Junction()
  : mX(0.0), mX_set(false), mY(0.0), mY_set(false)
{
}

Junction::~Junction()
{
}

void Junction::setX( const double v )
{
  mX_set = true;
  mX = v;
}

double Junction::x() const
{
  return mX;
}

bool Junction::xSet() const
{
  return mX_set;
}

void Junction::setY( const double v )
{
  mY_set = true;
  mY = v;
}

double Junction::y() const
{
  return mY;
}

bool Junction::ySet() const
{
  return mY_set;
}

Junction *Junction::parseElement( const QDomElement &element, bool *ok )
{
  if ( element.tagName() != "junction" ) {
    qCritical() << "Expected 'junction', got '" << element.tagName() << "'.";
    if ( ok ) *ok = false;
    return nullptr;
  }

  Junction* result = new Junction();

  if (element.hasAttribute("x"))
    result->setX( element.attribute( "x" ).toDouble() );
  if (element.hasAttribute("y"))
    result->setY( element.attribute( "y" ).toDouble() );

  if ( ok ) *ok = true;
  return result;
}

void Junction::writeElement( QXmlStreamWriter &xml ) const
{
  xml.writeStartElement( "junction" );
  if (mX_set)
    xml.writeAttribute("x", QString::number( mX ) );
  if (mY_set)
    xml.writeAttribute("y", QString::number( mY ) );
  xml.writeEndElement();
}


Label::Label()
  : mX(0.0), mX_set(false), mY(0.0), mY_set(false), mSize(0.0), mSize_set(false), mLayer(0), mLayer_set(false), mFont(Font_Invalid), mRatio(0), mRatio_set(false), mXref(Xref_Invalid), mAlign(Align_Invalid)
{
}

Label::~Label()
{
}

void Label::setX( const double v )
{
  mX_set = true;
  mX = v;
}

double Label::x() const
{
  return mX;
}

bool Label::xSet() const
{
  return mX_set;
}

void Label::setY( const double v )
{
  mY_set = true;
  mY = v;
}

double Label::y() const
{
  return mY;
}

bool Label::ySet() const
{
  return mY_set;
}

void Label::setSize( const double v )
{
  mSize_set = true;
  mSize = v;
}

double Label::size() const
{
  return mSize;
}

bool Label::sizeSet() const
{
  return mSize_set;
}

void Label::setLayer( const int v )
{
  mLayer_set = true;
  mLayer = v;
}

int Label::layer() const
{
  return mLayer;
}

bool Label::layerSet() const
{
  return mLayer_set;
}

void Label::setFont( const FontEnum &v )
{
  mFont = v;
}

Label::FontEnum Label::font() const
{
  return mFont;
}

void Label::setRatio( const int v )
{
  mRatio_set = true;
  mRatio = v;
}

int Label::ratio() const
{
  return mRatio;
}

bool Label::ratioSet() const
{
  return mRatio_set;
}

void Label::setRot( const QString &v )
{
  mRot = v;
}

QString Label::rot() const
{
  return mRot;
}

void Label::setXref( const XrefEnum &v )
{
  mXref = v;
}

Label::XrefEnum Label::xref() const
{
  return mXref;
}

void Label::setAlign( const AlignEnum &v )
{
  mAlign = v;
}

Label::AlignEnum Label::align() const
{
  return mAlign;
}

Label::FontEnum Label::fontEnumFromString( const QString & v, bool *ok )
{
  if (ok) *ok = true;

  if ( v == "vector" ) {
    return Font_vector;
  } else if ( v == "proportional" ) {
    return Font_proportional;
  } else if ( v == "fixed" ) {
    return Font_fixed;
  } else {
    if (ok) *ok = false;
    return Font_Invalid;
  }

  return Font_Invalid;
}

QString Label::fontEnumToString( const FontEnum & v )
{
  switch( v ) {
  case Font_vector: return "vector";
  case Font_proportional: return "proportional";
  case Font_fixed: return "fixed";
  case Font_Invalid:
  default:
    qCritical() << "Unable to serialize a(n) FontEnum enum because it has invalid value:" << v;
    return QString();
  }
}

Label::XrefEnum Label::xrefEnumFromString( const QString & v, bool *ok )
{
  if (ok) *ok = true;

  if ( v == "no" ) {
    return Xref_no;
  } else if ( v == "yes" ) {
    return Xref_yes;
  } else {
    if (ok) *ok = false;
    return Xref_Invalid;
  }

  return Xref_Invalid;
}

QString Label::xrefEnumToString( const XrefEnum & v )
{
  switch( v ) {
  case Xref_no: return "no";
  case Xref_yes: return "yes";
  case Xref_Invalid:
  default:
    qCritical() << "Unable to serialize a(n) XrefEnum enum because it has invalid value:" << v;
    return QString();
  }
}

Label::AlignEnum Label::alignEnumFromString( const QString & v, bool *ok )
{
  if (ok) *ok = true;

  if ( v == "bottom-left" ) {
    return Align_bottom_left;
  } else if ( v == "bottom-center" ) {
    return Align_bottom_center;
  } else if ( v == "bottom-right" ) {
    return Align_bottom_right;
  } else if ( v == "center-left" ) {
    return Align_center_left;
  } else if ( v == "center" ) {
    return Align_center;
  } else if ( v == "center-right" ) {
    return Align_center_right;
  } else if ( v == "top-left" ) {
    return Align_top_left;
  } else if ( v == "top-center" ) {
    return Align_top_center;
  } else if ( v == "top-right" ) {
    return Align_top_right;
  } else {
    if (ok) *ok = false;
    return Align_Invalid;
  }

  return Align_Invalid;
}

QString Label::alignEnumToString( const AlignEnum & v )
{
  switch( v ) {
  case Align_bottom_left: return "bottom-left";
  case Align_bottom_center: return "bottom-center";
  case Align_bottom_right: return "bottom-right";
  case Align_center_left: return "center-left";
  case Align_center: return "center";
  case Align_center_right: return "center-right";
  case Align_top_left: return "top-left";
  case Align_top_center: return "top-center";
  case Align_top_right: return "top-right";
  case Align_Invalid:
  default:
    qCritical() << "Unable to serialize a(n) AlignEnum enum because it has invalid value:" << v;
    return QString();
  }
}

Label *Label::parseElement( const QDomElement &element, bool *ok )
{
  if ( element.tagName() != "label" ) {
    qCritical() << "Expected 'label', got '" << element.tagName() << "'.";
    if ( ok ) *ok = false;
    return nullptr;
  }

  Label* result = new Label();

  if (element.hasAttribute("x"))
    result->setX( element.attribute( "x" ).toDouble() );
  if (element.hasAttribute("y"))
    result->setY( element.attribute( "y" ).toDouble() );
  if (element.hasAttribute("size"))
    result->setSize( element.attribute( "size" ).toDouble() );
  if (element.hasAttribute("layer"))
    result->setLayer( element.attribute( "layer" ).toInt() );
  if (element.hasAttribute("font"))  {
    FontEnum font = fontEnumFromString( element.attribute( "font" ), ok  );
    if (ok && !(*ok)) {
      qCritical() << "Invalid string: \"" << element.attribute( "font" ) << "\" in the \"font\" element";
      return nullptr;
    } else {
      result->setFont( font );
    }
  } else {
    // default value
    result->setFont(Font_proportional);
  }
  if (element.hasAttribute("ratio"))
    result->setRatio( element.attribute( "ratio" ).toInt() );
  result->setRot( element.attribute( "rot" ) );
  if (element.hasAttribute("xref"))  {
    XrefEnum xref = xrefEnumFromString( element.attribute( "xref" ), ok  );
    if (ok && !(*ok)) {
      qCritical() << "Invalid string: \"" << element.attribute( "xref" ) << "\" in the \"xref\" element";
      return nullptr;
    } else {
      result->setXref( xref );
    }
  } else {
    // default value
    result->setXref(Xref_no);
  }
  if (element.hasAttribute("align"))  {
    AlignEnum align = alignEnumFromString( element.attribute( "align" ), ok  );
    if (ok && !(*ok)) {
      qCritical() << "Invalid string: \"" << element.attribute( "align" ) << "\" in the \"align\" element";
      return nullptr;
    } else {
      result->setAlign( align );
    }
  } else {
    // default value
    result->setAlign(Align_bottom-left);
  }

  if ( ok ) *ok = true;
  return result;
}

void Label::writeElement( QXmlStreamWriter &xml ) const
{
  xml.writeStartElement( "label" );
  if (mX_set)
    xml.writeAttribute("x", QString::number( mX ) );
  if (mY_set)
    xml.writeAttribute("y", QString::number( mY ) );
  if (mSize_set)
    xml.writeAttribute("size", QString::number( mSize ) );
  if (mLayer_set)
    xml.writeAttribute("layer", QString::number( mLayer ) );
  if (mFont != Font_Invalid)
    xml.writeAttribute("font", fontEnumToString(mFont));
  if (mRatio_set)
    xml.writeAttribute("ratio", QString::number( mRatio ) );
  if (!mRot.isEmpty())
    xml.writeAttribute("rot", mRot );
  if (mXref != Xref_Invalid)
    xml.writeAttribute("xref", xrefEnumToString(mXref));
  if (mAlign != Align_Invalid)
    xml.writeAttribute("align", alignEnumToString(mAlign));
  xml.writeEndElement();
}


Probe::Probe()
  : mX(0.0), mX_set(false), mY(0.0), mY_set(false), mSize(0.0), mSize_set(false), mLayer(0), mLayer_set(false), mFont(Font_Invalid), mRatio(0), mRatio_set(false), mXref(Xref_Invalid)
{
}

Probe::~Probe()
{
}

void Probe::setX( const double v )
{
  mX_set = true;
  mX = v;
}

double Probe::x() const
{
  return mX;
}

bool Probe::xSet() const
{
  return mX_set;
}

void Probe::setY( const double v )
{
  mY_set = true;
  mY = v;
}

double Probe::y() const
{
  return mY;
}

bool Probe::ySet() const
{
  return mY_set;
}

void Probe::setSize( const double v )
{
  mSize_set = true;
  mSize = v;
}

double Probe::size() const
{
  return mSize;
}

bool Probe::sizeSet() const
{
  return mSize_set;
}

void Probe::setLayer( const int v )
{
  mLayer_set = true;
  mLayer = v;
}

int Probe::layer() const
{
  return mLayer;
}

bool Probe::layerSet() const
{
  return mLayer_set;
}

void Probe::setFont( const FontEnum &v )
{
  mFont = v;
}

Probe::FontEnum Probe::font() const
{
  return mFont;
}

void Probe::setRatio( const int v )
{
  mRatio_set = true;
  mRatio = v;
}

int Probe::ratio() const
{
  return mRatio;
}

bool Probe::ratioSet() const
{
  return mRatio_set;
}

void Probe::setRot( const QString &v )
{
  mRot = v;
}

QString Probe::rot() const
{
  return mRot;
}

void Probe::setXref( const XrefEnum &v )
{
  mXref = v;
}

Probe::XrefEnum Probe::xref() const
{
  return mXref;
}

Probe::FontEnum Probe::fontEnumFromString( const QString & v, bool *ok )
{
  if (ok) *ok = true;

  if ( v == "vector" ) {
    return Font_vector;
  } else if ( v == "proportional" ) {
    return Font_proportional;
  } else if ( v == "fixed" ) {
    return Font_fixed;
  } else {
    if (ok) *ok = false;
    return Font_Invalid;
  }

  return Font_Invalid;
}

QString Probe::fontEnumToString( const FontEnum & v )
{
  switch( v ) {
  case Font_vector: return "vector";
  case Font_proportional: return "proportional";
  case Font_fixed: return "fixed";
  case Font_Invalid:
  default:
    qCritical() << "Unable to serialize a(n) FontEnum enum because it has invalid value:" << v;
    return QString();
  }
}

Probe::XrefEnum Probe::xrefEnumFromString( const QString & v, bool *ok )
{
  if (ok) *ok = true;

  if ( v == "no" ) {
    return Xref_no;
  } else if ( v == "yes" ) {
    return Xref_yes;
  } else {
    if (ok) *ok = false;
    return Xref_Invalid;
  }

  return Xref_Invalid;
}

QString Probe::xrefEnumToString( const XrefEnum & v )
{
  switch( v ) {
  case Xref_no: return "no";
  case Xref_yes: return "yes";
  case Xref_Invalid:
  default:
    qCritical() << "Unable to serialize a(n) XrefEnum enum because it has invalid value:" << v;
    return QString();
  }
}

Probe *Probe::parseElement( const QDomElement &element, bool *ok )
{
  if ( element.tagName() != "probe" ) {
    qCritical() << "Expected 'probe', got '" << element.tagName() << "'.";
    if ( ok ) *ok = false;
    return nullptr;
  }

  Probe* result = new Probe();

  if (element.hasAttribute("x"))
    result->setX( element.attribute( "x" ).toDouble() );
  if (element.hasAttribute("y"))
    result->setY( element.attribute( "y" ).toDouble() );
  if (element.hasAttribute("size"))
    result->setSize( element.attribute( "size" ).toDouble() );
  if (element.hasAttribute("layer"))
    result->setLayer( element.attribute( "layer" ).toInt() );
  if (element.hasAttribute("font"))  {
    FontEnum font = fontEnumFromString( element.attribute( "font" ), ok  );
    if (ok && !(*ok)) {
      qCritical() << "Invalid string: \"" << element.attribute( "font" ) << "\" in the \"font\" element";
      return nullptr;
    } else {
      result->setFont( font );
    }
  } else {
    // default value
    result->setFont(Font_proportional);
  }
  if (element.hasAttribute("ratio"))
    result->setRatio( element.attribute( "ratio" ).toInt() );
  result->setRot( element.attribute( "rot" ) );
  if (element.hasAttribute("xref"))  {
    XrefEnum xref = xrefEnumFromString( element.attribute( "xref" ), ok  );
    if (ok && !(*ok)) {
      qCritical() << "Invalid string: \"" << element.attribute( "xref" ) << "\" in the \"xref\" element";
      return nullptr;
    } else {
      result->setXref( xref );
    }
  } else {
    // default value
    result->setXref(Xref_no);
  }

  if ( ok ) *ok = true;
  return result;
}

void Probe::writeElement( QXmlStreamWriter &xml ) const
{
  xml.writeStartElement( "probe" );
  if (mX_set)
    xml.writeAttribute("x", QString::number( mX ) );
  if (mY_set)
    xml.writeAttribute("y", QString::number( mY ) );
  if (mSize_set)
    xml.writeAttribute("size", QString::number( mSize ) );
  if (mLayer_set)
    xml.writeAttribute("layer", QString::number( mLayer ) );
  if (mFont != Font_Invalid)
    xml.writeAttribute("font", fontEnumToString(mFont));
  if (mRatio_set)
    xml.writeAttribute("ratio", QString::number( mRatio ) );
  if (!mRot.isEmpty())
    xml.writeAttribute("rot", mRot );
  if (mXref != Xref_Invalid)
    xml.writeAttribute("xref", xrefEnumToString(mXref));
  xml.writeEndElement();
}


Segment::Segment()
{
}

Segment::~Segment()
{
}

void Segment::addPinref( Pinref* v )
{
  mPinrefList.append( v );
}

void Segment::setPinrefList( const Pinref::List &v )
{
  mPinrefList = v;
}

Pinref::List *Segment::pinrefList()
{
  return &mPinrefList;
}

void Segment::addPortref( Portref* v )
{
  mPortrefList.append( v );
}

void Segment::setPortrefList( const Portref::List &v )
{
  mPortrefList = v;
}

Portref::List *Segment::portrefList()
{
  return &mPortrefList;
}

void Segment::addWire( Wire* v )
{
  mWireList.append( v );
}

void Segment::setWireList( const Wire::List &v )
{
  mWireList = v;
}

Wire::List *Segment::wireList()
{
  return &mWireList;
}

void Segment::addJunction( Junction* v )
{
  mJunctionList.append( v );
}

void Segment::setJunctionList( const Junction::List &v )
{
  mJunctionList = v;
}

Junction::List *Segment::junctionList()
{
  return &mJunctionList;
}

void Segment::addLabel( Label* v )
{
  mLabelList.append( v );
}

void Segment::setLabelList( const Label::List &v )
{
  mLabelList = v;
}

Label::List *Segment::labelList()
{
  return &mLabelList;
}

void Segment::addProbe( Probe* v )
{
  mProbeList.append( v );
}

void Segment::setProbeList( const Probe::List &v )
{
  mProbeList = v;
}

Probe::List *Segment::probeList()
{
  return &mProbeList;
}

Segment *Segment::parseElement( const QDomElement &element, bool *ok )
{
  if ( element.tagName() != "segment" ) {
    qCritical() << "Expected 'segment', got '" << element.tagName() << "'.";
    if ( ok ) *ok = false;
    return nullptr;
  }

  Segment* result = new Segment();

  QDomNode n;
  for( n = element.firstChild(); !n.isNull(); n = n.nextSibling() ) {
    QDomElement e = n.toElement();
    if ( e.tagName() == "pinref" ) {
      bool ok;
      Pinref *o = Pinref::parseElement( e, &ok );
      if ( ok ) result->addPinref( o );
    }
    else if ( e.tagName() == "portref" ) {
      bool ok;
      Portref *o = Portref::parseElement( e, &ok );
      if ( ok ) result->addPortref( o );
    }
    else if ( e.tagName() == "wire" ) {
      bool ok;
      Wire *o = Wire::parseElement( e, &ok );
      if ( ok ) result->addWire( o );
    }
    else if ( e.tagName() == "junction" ) {
      bool ok;
      Junction *o = Junction::parseElement( e, &ok );
      if ( ok ) result->addJunction( o );
    }
    else if ( e.tagName() == "label" ) {
      bool ok;
      Label *o = Label::parseElement( e, &ok );
      if ( ok ) result->addLabel( o );
    }
    else if ( e.tagName() == "probe" ) {
      bool ok;
      Probe *o = Probe::parseElement( e, &ok );
      if ( ok ) result->addProbe( o );
    }
  }


  if ( ok ) *ok = true;
  return result;
}

void Segment::writeElement( QXmlStreamWriter &xml ) const
{
  if ( !mPinrefList.isEmpty() || !mPortrefList.isEmpty() || !mWireList.isEmpty() || !mJunctionList.isEmpty() || !mLabelList.isEmpty() || !mProbeList.isEmpty() ) {
    xml.writeStartElement( "segment" );
    foreach( Pinref* e, mPinrefList ) {
      if (e)
        e->writeElement( xml );
    }
    foreach( Portref* e, mPortrefList ) {
      if (e)
        e->writeElement( xml );
    }
    foreach( Wire* e, mWireList ) {
      if (e)
        e->writeElement( xml );
    }
    foreach( Junction* e, mJunctionList ) {
      if (e)
        e->writeElement( xml );
    }
    foreach( Label* e, mLabelList ) {
      if (e)
        e->writeElement( xml );
    }
    foreach( Probe* e, mProbeList ) {
      if (e)
        e->writeElement( xml );
    }
    xml.writeEndElement();
  }
}


Net::Net()
  : mClass(0), mClass_set(false)
{
}

Net::~Net()
{
}

void Net::setName( const QString &v )
{
  mName = v;
}

QString Net::name() const
{
  return mName;
}

void Net::setClass( const int v )
{
  mClass_set = true;
  mClass = v;
}

int Net::class_() const
{
  return mClass;
}

bool Net::classSet() const
{
  return mClass_set;
}

void Net::addSegment( Segment* v )
{
  mSegmentList.append( v );
}

void Net::setSegmentList( const Segment::List &v )
{
  mSegmentList = v;
}

Segment::List *Net::segmentList()
{
  return &mSegmentList;
}

Net *Net::parseElement( const QDomElement &element, bool *ok )
{
  if ( element.tagName() != "net" ) {
    qCritical() << "Expected 'net', got '" << element.tagName() << "'.";
    if ( ok ) *ok = false;
    return nullptr;
  }

  Net* result = new Net();

  QDomNode n;
  for( n = element.firstChild(); !n.isNull(); n = n.nextSibling() ) {
    QDomElement e = n.toElement();
    if ( e.tagName() == "segment" ) {
      bool ok;
      Segment *o = Segment::parseElement( e, &ok );
      if ( ok ) result->addSegment( o );
    }
  }

  result->setName( element.attribute( "name" ) );
  if (element.hasAttribute("class"))
    result->setClass( element.attribute( "class" ).toInt() );

  if ( ok ) *ok = true;
  return result;
}

void Net::writeElement( QXmlStreamWriter &xml ) const
{
  xml.writeStartElement( "net" );
  if (!mName.isEmpty())
    xml.writeAttribute("name", mName );
  if (mClass_set)
    xml.writeAttribute("class", QString::number( mClass ) );
  foreach( Segment* e, mSegmentList ) {
    if (e)
      e->writeElement( xml );
  }
  xml.writeEndElement();
}


Nets::Nets()
{
}

Nets::~Nets()
{
}

void Nets::addNet( Net* v )
{
  mNetList.append( v );
}

void Nets::setNetList( const Net::List &v )
{
  mNetList = v;
}

Net::List *Nets::netList()
{
  return &mNetList;
}

Nets *Nets::parseElement( const QDomElement &element, bool *ok )
{
  if ( element.tagName() != "nets" ) {
    qCritical() << "Expected 'nets', got '" << element.tagName() << "'.";
    if ( ok ) *ok = false;
    return nullptr;
  }

  Nets* result = new Nets();

  QDomNode n;
  for( n = element.firstChild(); !n.isNull(); n = n.nextSibling() ) {
    QDomElement e = n.toElement();
    if ( e.tagName() == "net" ) {
      bool ok;
      Net *o = Net::parseElement( e, &ok );
      if ( ok ) result->addNet( o );
    }
  }


  if ( ok ) *ok = true;
  return result;
}

void Nets::writeElement( QXmlStreamWriter &xml ) const
{
  if ( !mNetList.isEmpty() ) {
    xml.writeStartElement( "nets" );
    foreach( Net* e, mNetList ) {
      if (e)
        e->writeElement( xml );
    }
    xml.writeEndElement();
  }
}


Bus::Bus()
{
}

Bus::~Bus()
{
}

void Bus::setName( const QString &v )
{
  mName = v;
}

QString Bus::name() const
{
  return mName;
}

void Bus::addSegment( Segment* v )
{
  mSegmentList.append( v );
}

void Bus::setSegmentList( const Segment::List &v )
{
  mSegmentList = v;
}

Segment::List *Bus::segmentList()
{
  return &mSegmentList;
}

Bus *Bus::parseElement( const QDomElement &element, bool *ok )
{
  if ( element.tagName() != "bus" ) {
    qCritical() << "Expected 'bus', got '" << element.tagName() << "'.";
    if ( ok ) *ok = false;
    return nullptr;
  }

  Bus* result = new Bus();

  QDomNode n;
  for( n = element.firstChild(); !n.isNull(); n = n.nextSibling() ) {
    QDomElement e = n.toElement();
    if ( e.tagName() == "segment" ) {
      bool ok;
      Segment *o = Segment::parseElement( e, &ok );
      if ( ok ) result->addSegment( o );
    }
  }

  result->setName( element.attribute( "name" ) );

  if ( ok ) *ok = true;
  return result;
}

void Bus::writeElement( QXmlStreamWriter &xml ) const
{
  xml.writeStartElement( "bus" );
  if (!mName.isEmpty())
    xml.writeAttribute("name", mName );
  foreach( Segment* e, mSegmentList ) {
    if (e)
      e->writeElement( xml );
  }
  xml.writeEndElement();
}


Busses::Busses()
{
}

Busses::~Busses()
{
}

void Busses::addBus( Bus* v )
{
  mBusList.append( v );
}

void Busses::setBusList( const Bus::List &v )
{
  mBusList = v;
}

Bus::List *Busses::busList()
{
  return &mBusList;
}

Busses *Busses::parseElement( const QDomElement &element, bool *ok )
{
  if ( element.tagName() != "busses" ) {
    qCritical() << "Expected 'busses', got '" << element.tagName() << "'.";
    if ( ok ) *ok = false;
    return nullptr;
  }

  Busses* result = new Busses();

  QDomNode n;
  for( n = element.firstChild(); !n.isNull(); n = n.nextSibling() ) {
    QDomElement e = n.toElement();
    if ( e.tagName() == "bus" ) {
      bool ok;
      Bus *o = Bus::parseElement( e, &ok );
      if ( ok ) result->addBus( o );
    }
  }


  if ( ok ) *ok = true;
  return result;
}

void Busses::writeElement( QXmlStreamWriter &xml ) const
{
  if ( !mBusList.isEmpty() ) {
    xml.writeStartElement( "busses" );
    foreach( Bus* e, mBusList ) {
      if (e)
        e->writeElement( xml );
    }
    xml.writeEndElement();
  }
}


Instance::Instance()
  : mX(0.0), mX_set(false), mY(0.0), mY_set(false), mSmashed(Smashed_Invalid)
{
}

Instance::~Instance()
{
}

void Instance::setPart( const QString &v )
{
  mPart = v;
}

QString Instance::part() const
{
  return mPart;
}

void Instance::setGate( const QString &v )
{
  mGate = v;
}

QString Instance::gate() const
{
  return mGate;
}

void Instance::setX( const double v )
{
  mX_set = true;
  mX = v;
}

double Instance::x() const
{
  return mX;
}

bool Instance::xSet() const
{
  return mX_set;
}

void Instance::setY( const double v )
{
  mY_set = true;
  mY = v;
}

double Instance::y() const
{
  return mY;
}

bool Instance::ySet() const
{
  return mY_set;
}

void Instance::setSmashed( const SmashedEnum &v )
{
  mSmashed = v;
}

Instance::SmashedEnum Instance::smashed() const
{
  return mSmashed;
}

void Instance::setRot( const QString &v )
{
  mRot = v;
}

QString Instance::rot() const
{
  return mRot;
}

void Instance::addAttribute( Attribute* v )
{
  mAttributeList.append( v );
}

void Instance::setAttributeList( const Attribute::List &v )
{
  mAttributeList = v;
}

Attribute::List *Instance::attributeList()
{
  return &mAttributeList;
}

Instance::SmashedEnum Instance::smashedEnumFromString( const QString & v, bool *ok )
{
  if (ok) *ok = true;

  if ( v == "no" ) {
    return Smashed_no;
  } else if ( v == "yes" ) {
    return Smashed_yes;
  } else {
    if (ok) *ok = false;
    return Smashed_Invalid;
  }

  return Smashed_Invalid;
}

QString Instance::smashedEnumToString( const SmashedEnum & v )
{
  switch( v ) {
  case Smashed_no: return "no";
  case Smashed_yes: return "yes";
  case Smashed_Invalid:
  default:
    qCritical() << "Unable to serialize a(n) SmashedEnum enum because it has invalid value:" << v;
    return QString();
  }
}

Instance *Instance::parseElement( const QDomElement &element, bool *ok )
{
  if ( element.tagName() != "instance" ) {
    qCritical() << "Expected 'instance', got '" << element.tagName() << "'.";
    if ( ok ) *ok = false;
    return nullptr;
  }

  Instance* result = new Instance();

  QDomNode n;
  for( n = element.firstChild(); !n.isNull(); n = n.nextSibling() ) {
    QDomElement e = n.toElement();
    if ( e.tagName() == "attribute" ) {
      bool ok;
      Attribute *o = Attribute::parseElement( e, &ok );
      if ( ok ) result->addAttribute( o );
    }
  }

  result->setPart( element.attribute( "part" ) );
  result->setGate( element.attribute( "gate" ) );
  if (element.hasAttribute("x"))
    result->setX( element.attribute( "x" ).toDouble() );
  if (element.hasAttribute("y"))
    result->setY( element.attribute( "y" ).toDouble() );
  if (element.hasAttribute("smashed"))  {
    SmashedEnum smashed = smashedEnumFromString( element.attribute( "smashed" ), ok  );
    if (ok && !(*ok)) {
      qCritical() << "Invalid string: \"" << element.attribute( "smashed" ) << "\" in the \"smashed\" element";
      return nullptr;
    } else {
      result->setSmashed( smashed );
    }
  } else {
    // default value
    result->setSmashed(Smashed_no);
  }
  result->setRot( element.attribute( "rot" ) );

  if ( ok ) *ok = true;
  return result;
}

void Instance::writeElement( QXmlStreamWriter &xml ) const
{
  xml.writeStartElement( "instance" );
  if (!mPart.isEmpty())
    xml.writeAttribute("part", mPart );
  if (!mGate.isEmpty())
    xml.writeAttribute("gate", mGate );
  if (mX_set)
    xml.writeAttribute("x", QString::number( mX ) );
  if (mY_set)
    xml.writeAttribute("y", QString::number( mY ) );
  if (mSmashed != Smashed_Invalid)
    xml.writeAttribute("smashed", smashedEnumToString(mSmashed));
  if (!mRot.isEmpty())
    xml.writeAttribute("rot", mRot );
  foreach( Attribute* e, mAttributeList ) {
    if (e)
      e->writeElement( xml );
  }
  xml.writeEndElement();
}


Instances::Instances()
{
}

Instances::~Instances()
{
}

void Instances::addInstance( Instance* v )
{
  mInstanceList.append( v );
}

void Instances::setInstanceList( const Instance::List &v )
{
  mInstanceList = v;
}

Instance::List *Instances::instanceList()
{
  return &mInstanceList;
}

Instances *Instances::parseElement( const QDomElement &element, bool *ok )
{
  if ( element.tagName() != "instances" ) {
    qCritical() << "Expected 'instances', got '" << element.tagName() << "'.";
    if ( ok ) *ok = false;
    return nullptr;
  }

  Instances* result = new Instances();

  QDomNode n;
  for( n = element.firstChild(); !n.isNull(); n = n.nextSibling() ) {
    QDomElement e = n.toElement();
    if ( e.tagName() == "instance" ) {
      bool ok;
      Instance *o = Instance::parseElement( e, &ok );
      if ( ok ) result->addInstance( o );
    }
  }


  if ( ok ) *ok = true;
  return result;
}

void Instances::writeElement( QXmlStreamWriter &xml ) const
{
  if ( !mInstanceList.isEmpty() ) {
    xml.writeStartElement( "instances" );
    foreach( Instance* e, mInstanceList ) {
      if (e)
        e->writeElement( xml );
    }
    xml.writeEndElement();
  }
}


Moduleinst::Moduleinst()
  : mX(0.0), mX_set(false), mY(0.0), mY_set(false), mOffset(0), mOffset_set(false), mSmashed(Smashed_Invalid)
{
}

Moduleinst::~Moduleinst()
{
}

void Moduleinst::setName( const QString &v )
{
  mName = v;
}

QString Moduleinst::name() const
{
  return mName;
}

void Moduleinst::setModule( const QString &v )
{
  mModule = v;
}

QString Moduleinst::module_() const
{
  return mModule;
}

void Moduleinst::setModulevariant( const QString &v )
{
  mModulevariant = v;
}

QString Moduleinst::modulevariant() const
{
  return mModulevariant;
}

void Moduleinst::setX( const double v )
{
  mX_set = true;
  mX = v;
}

double Moduleinst::x() const
{
  return mX;
}

bool Moduleinst::xSet() const
{
  return mX_set;
}

void Moduleinst::setY( const double v )
{
  mY_set = true;
  mY = v;
}

double Moduleinst::y() const
{
  return mY;
}

bool Moduleinst::ySet() const
{
  return mY_set;
}

void Moduleinst::setOffset( const int v )
{
  mOffset_set = true;
  mOffset = v;
}

int Moduleinst::offset() const
{
  return mOffset;
}

bool Moduleinst::offsetSet() const
{
  return mOffset_set;
}

void Moduleinst::setSmashed( const SmashedEnum &v )
{
  mSmashed = v;
}

Moduleinst::SmashedEnum Moduleinst::smashed() const
{
  return mSmashed;
}

void Moduleinst::setRot( const QString &v )
{
  mRot = v;
}

QString Moduleinst::rot() const
{
  return mRot;
}

void Moduleinst::addAttribute( Attribute* v )
{
  mAttributeList.append( v );
}

void Moduleinst::setAttributeList( const Attribute::List &v )
{
  mAttributeList = v;
}

Attribute::List *Moduleinst::attributeList()
{
  return &mAttributeList;
}

Moduleinst::SmashedEnum Moduleinst::smashedEnumFromString( const QString & v, bool *ok )
{
  if (ok) *ok = true;

  if ( v == "no" ) {
    return Smashed_no;
  } else if ( v == "yes" ) {
    return Smashed_yes;
  } else {
    if (ok) *ok = false;
    return Smashed_Invalid;
  }

  return Smashed_Invalid;
}

QString Moduleinst::smashedEnumToString( const SmashedEnum & v )
{
  switch( v ) {
  case Smashed_no: return "no";
  case Smashed_yes: return "yes";
  case Smashed_Invalid:
  default:
    qCritical() << "Unable to serialize a(n) SmashedEnum enum because it has invalid value:" << v;
    return QString();
  }
}

Moduleinst *Moduleinst::parseElement( const QDomElement &element, bool *ok )
{
  if ( element.tagName() != "moduleinst" ) {
    qCritical() << "Expected 'moduleinst', got '" << element.tagName() << "'.";
    if ( ok ) *ok = false;
    return nullptr;
  }

  Moduleinst* result = new Moduleinst();

  QDomNode n;
  for( n = element.firstChild(); !n.isNull(); n = n.nextSibling() ) {
    QDomElement e = n.toElement();
    if ( e.tagName() == "attribute" ) {
      bool ok;
      Attribute *o = Attribute::parseElement( e, &ok );
      if ( ok ) result->addAttribute( o );
    }
  }

  result->setName( element.attribute( "name" ) );
  result->setModule( element.attribute( "module" ) );
  result->setModulevariant( element.attribute( "modulevariant" ) );
  if (element.hasAttribute("x"))
    result->setX( element.attribute( "x" ).toDouble() );
  if (element.hasAttribute("y"))
    result->setY( element.attribute( "y" ).toDouble() );
  if (element.hasAttribute("offset"))
    result->setOffset( element.attribute( "offset" ).toInt() );
  if (element.hasAttribute("smashed"))  {
    SmashedEnum smashed = smashedEnumFromString( element.attribute( "smashed" ), ok  );
    if (ok && !(*ok)) {
      qCritical() << "Invalid string: \"" << element.attribute( "smashed" ) << "\" in the \"smashed\" element";
      return nullptr;
    } else {
      result->setSmashed( smashed );
    }
  } else {
    // default value
    result->setSmashed(Smashed_no);
  }
  result->setRot( element.attribute( "rot" ) );

  if ( ok ) *ok = true;
  return result;
}

void Moduleinst::writeElement( QXmlStreamWriter &xml ) const
{
  xml.writeStartElement( "moduleinst" );
  if (!mName.isEmpty())
    xml.writeAttribute("name", mName );
  if (!mModule.isEmpty())
    xml.writeAttribute("module", mModule );
  if (!mModulevariant.isEmpty())
    xml.writeAttribute("modulevariant", mModulevariant );
  if (mX_set)
    xml.writeAttribute("x", QString::number( mX ) );
  if (mY_set)
    xml.writeAttribute("y", QString::number( mY ) );
  if (mOffset_set)
    xml.writeAttribute("offset", QString::number( mOffset ) );
  if (mSmashed != Smashed_Invalid)
    xml.writeAttribute("smashed", smashedEnumToString(mSmashed));
  if (!mRot.isEmpty())
    xml.writeAttribute("rot", mRot );
  foreach( Attribute* e, mAttributeList ) {
    if (e)
      e->writeElement( xml );
  }
  xml.writeEndElement();
}


Moduleinsts::Moduleinsts()
{
}

Moduleinsts::~Moduleinsts()
{
}

void Moduleinsts::addModuleinst( Moduleinst* v )
{
  mModuleinstList.append( v );
}

void Moduleinsts::setModuleinstList( const Moduleinst::List &v )
{
  mModuleinstList = v;
}

Moduleinst::List *Moduleinsts::moduleinstList()
{
  return &mModuleinstList;
}

Moduleinsts *Moduleinsts::parseElement( const QDomElement &element, bool *ok )
{
  if ( element.tagName() != "moduleinsts" ) {
    qCritical() << "Expected 'moduleinsts', got '" << element.tagName() << "'.";
    if ( ok ) *ok = false;
    return nullptr;
  }

  Moduleinsts* result = new Moduleinsts();

  QDomNode n;
  for( n = element.firstChild(); !n.isNull(); n = n.nextSibling() ) {
    QDomElement e = n.toElement();
    if ( e.tagName() == "moduleinst" ) {
      bool ok;
      Moduleinst *o = Moduleinst::parseElement( e, &ok );
      if ( ok ) result->addModuleinst( o );
    }
  }


  if ( ok ) *ok = true;
  return result;
}

void Moduleinsts::writeElement( QXmlStreamWriter &xml ) const
{
  if ( !mModuleinstList.isEmpty() ) {
    xml.writeStartElement( "moduleinsts" );
    foreach( Moduleinst* e, mModuleinstList ) {
      if (e)
        e->writeElement( xml );
    }
    xml.writeEndElement();
  }
}


Sheet::Sheet()
  : mDescription(nullptr), mPlain(nullptr), mModuleinsts(nullptr), mInstances(nullptr), mBusses(nullptr), mNets(nullptr)
{
}

Sheet::~Sheet()
{
}

void Sheet::setDescription( Description *v )
{
  mDescription = v;
}

Description *Sheet::description()
{
  return mDescription;
}

void Sheet::setPlain( Plain *v )
{
  mPlain = v;
}

Plain *Sheet::plain()
{
  return mPlain;
}

void Sheet::setModuleinsts( Moduleinsts *v )
{
  mModuleinsts = v;
}

Moduleinsts *Sheet::moduleinsts()
{
  return mModuleinsts;
}

void Sheet::setInstances( Instances *v )
{
  mInstances = v;
}

Instances *Sheet::instances()
{
  return mInstances;
}

void Sheet::setBusses( Busses *v )
{
  mBusses = v;
}

Busses *Sheet::busses()
{
  return mBusses;
}

void Sheet::setNets( Nets *v )
{
  mNets = v;
}

Nets *Sheet::nets()
{
  return mNets;
}

Sheet *Sheet::parseElement( const QDomElement &element, bool *ok )
{
  if ( element.tagName() != "sheet" ) {
    qCritical() << "Expected 'sheet', got '" << element.tagName() << "'.";
    if ( ok ) *ok = false;
    return nullptr;
  }

  Sheet* result = new Sheet();

  QDomNode n;
  for( n = element.firstChild(); !n.isNull(); n = n.nextSibling() ) {
    QDomElement e = n.toElement();
    if ( e.tagName() == "description" ) {
      bool ok;
      Description *o = Description::parseElement( e, &ok );
      if ( ok ) result->setDescription( o );
    }
    else if ( e.tagName() == "plain" ) {
      bool ok;
      Plain *o = Plain::parseElement( e, &ok );
      if ( ok ) result->setPlain( o );
    }
    else if ( e.tagName() == "moduleinsts" ) {
      bool ok;
      Moduleinsts *o = Moduleinsts::parseElement( e, &ok );
      if ( ok ) result->setModuleinsts( o );
    }
    else if ( e.tagName() == "instances" ) {
      bool ok;
      Instances *o = Instances::parseElement( e, &ok );
      if ( ok ) result->setInstances( o );
    }
    else if ( e.tagName() == "busses" ) {
      bool ok;
      Busses *o = Busses::parseElement( e, &ok );
      if ( ok ) result->setBusses( o );
    }
    else if ( e.tagName() == "nets" ) {
      bool ok;
      Nets *o = Nets::parseElement( e, &ok );
      if ( ok ) result->setNets( o );
    }
  }


  if ( ok ) *ok = true;
  return result;
}

void Sheet::writeElement( QXmlStreamWriter &xml ) const
{
  xml.writeStartElement( "sheet" );
  if (mDescription)
    mDescription->writeElement( xml );
  if (mPlain)
    mPlain->writeElement( xml );
  if (mModuleinsts)
    mModuleinsts->writeElement( xml );
  if (mInstances)
    mInstances->writeElement( xml );
  if (mBusses)
    mBusses->writeElement( xml );
  if (mNets)
    mNets->writeElement( xml );
  xml.writeEndElement();
}


Sheets::Sheets()
{
}

Sheets::~Sheets()
{
}

void Sheets::addSheet( Sheet* v )
{
  mSheetList.append( v );
}

void Sheets::setSheetList( const Sheet::List &v )
{
  mSheetList = v;
}

Sheet::List *Sheets::sheetList()
{
  return &mSheetList;
}

Sheets *Sheets::parseElement( const QDomElement &element, bool *ok )
{
  if ( element.tagName() != "sheets" ) {
    qCritical() << "Expected 'sheets', got '" << element.tagName() << "'.";
    if ( ok ) *ok = false;
    return nullptr;
  }

  Sheets* result = new Sheets();

  QDomNode n;
  for( n = element.firstChild(); !n.isNull(); n = n.nextSibling() ) {
    QDomElement e = n.toElement();
    if ( e.tagName() == "sheet" ) {
      bool ok;
      Sheet *o = Sheet::parseElement( e, &ok );
      if ( ok ) result->addSheet( o );
    }
  }


  if ( ok ) *ok = true;
  return result;
}

void Sheets::writeElement( QXmlStreamWriter &xml ) const
{
  if ( !mSheetList.isEmpty() ) {
    xml.writeStartElement( "sheets" );
    foreach( Sheet* e, mSheetList ) {
      if (e)
        e->writeElement( xml );
    }
    xml.writeEndElement();
  }
}


Part::Part()
  : mSpice(nullptr)
{
}

Part::~Part()
{
}

void Part::setName( const QString &v )
{
  mName = v;
}

QString Part::name() const
{
  return mName;
}

void Part::setLibrary( const QString &v )
{
  mLibrary = v;
}

QString Part::library() const
{
  return mLibrary;
}

void Part::setLibraryUrn( const QString &v )
{
  mLibraryUrn = v;
}

QString Part::libraryUrn() const
{
  return mLibraryUrn;
}

void Part::setDeviceset( const QString &v )
{
  mDeviceset = v;
}

QString Part::deviceset() const
{
  return mDeviceset;
}

void Part::setDevice( const QString &v )
{
  mDevice = v;
}

QString Part::device() const
{
  return mDevice;
}

void Part::setPackage3dUrn( const QString &v )
{
  mPackage3dUrn = v;
}

QString Part::package3dUrn() const
{
  return mPackage3dUrn;
}

void Part::setTechnology( const QString &v )
{
  mTechnology = v;
}

QString Part::technology() const
{
  return mTechnology;
}

void Part::setValue( const QString &v )
{
  mValue = v;
}

QString Part::value() const
{
  return mValue;
}

void Part::addAttribute( Attribute* v )
{
  mAttributeList.append( v );
}

void Part::setAttributeList( const Attribute::List &v )
{
  mAttributeList = v;
}

Attribute::List *Part::attributeList()
{
  return &mAttributeList;
}

void Part::addVariant( Variant* v )
{
  mVariantList.append( v );
}

void Part::setVariantList( const Variant::List &v )
{
  mVariantList = v;
}

Variant::List *Part::variantList()
{
  return &mVariantList;
}

void Part::setSpice( Spice *v )
{
  mSpice = v;
}

Spice *Part::spice()
{
  return mSpice;
}

Part *Part::parseElement( const QDomElement &element, bool *ok )
{
  if ( element.tagName() != "part" ) {
    qCritical() << "Expected 'part', got '" << element.tagName() << "'.";
    if ( ok ) *ok = false;
    return nullptr;
  }

  Part* result = new Part();

  QDomNode n;
  for( n = element.firstChild(); !n.isNull(); n = n.nextSibling() ) {
    QDomElement e = n.toElement();
    if ( e.tagName() == "attribute" ) {
      bool ok;
      Attribute *o = Attribute::parseElement( e, &ok );
      if ( ok ) result->addAttribute( o );
    }
    else if ( e.tagName() == "variant" ) {
      bool ok;
      Variant *o = Variant::parseElement( e, &ok );
      if ( ok ) result->addVariant( o );
    }
    else if ( e.tagName() == "spice" ) {
      bool ok;
      Spice *o = Spice::parseElement( e, &ok );
      if ( ok ) result->setSpice( o );
    }
  }

  result->setName( element.attribute( "name" ) );
  result->setLibrary( element.attribute( "library" ) );
  result->setLibraryUrn( element.attribute( "library_urn" ) );
  result->setDeviceset( element.attribute( "deviceset" ) );
  result->setDevice( element.attribute( "device" ) );
  result->setPackage3dUrn( element.attribute( "package3d_urn" ) );
  result->setTechnology( element.attribute( "technology" ) );
  result->setValue( element.attribute( "value" ) );

  if ( ok ) *ok = true;
  return result;
}

void Part::writeElement( QXmlStreamWriter &xml ) const
{
  xml.writeStartElement( "part" );
  if (!mName.isEmpty())
    xml.writeAttribute("name", mName );
  if (!mLibrary.isEmpty())
    xml.writeAttribute("library", mLibrary );
  if (!mLibraryUrn.isEmpty())
    xml.writeAttribute("library_urn", mLibraryUrn );
  if (!mDeviceset.isEmpty())
    xml.writeAttribute("deviceset", mDeviceset );
  if (!mDevice.isEmpty())
    xml.writeAttribute("device", mDevice );
  if (!mPackage3dUrn.isEmpty())
    xml.writeAttribute("package3d_urn", mPackage3dUrn );
  if (!mTechnology.isEmpty())
    xml.writeAttribute("technology", mTechnology );
  if (!mValue.isEmpty())
    xml.writeAttribute("value", mValue );
  foreach( Attribute* e, mAttributeList ) {
    if (e)
      e->writeElement( xml );
  }
  foreach( Variant* e, mVariantList ) {
    if (e)
      e->writeElement( xml );
  }
  if (mSpice)
    mSpice->writeElement( xml );
  xml.writeEndElement();
}


Parts::Parts()
{
}

Parts::~Parts()
{
}

void Parts::addPart( Part* v )
{
  mPartList.append( v );
}

void Parts::setPartList( const Part::List &v )
{
  mPartList = v;
}

Part::List *Parts::partList()
{
  return &mPartList;
}

Parts *Parts::parseElement( const QDomElement &element, bool *ok )
{
  if ( element.tagName() != "parts" ) {
    qCritical() << "Expected 'parts', got '" << element.tagName() << "'.";
    if ( ok ) *ok = false;
    return nullptr;
  }

  Parts* result = new Parts();

  QDomNode n;
  for( n = element.firstChild(); !n.isNull(); n = n.nextSibling() ) {
    QDomElement e = n.toElement();
    if ( e.tagName() == "part" ) {
      bool ok;
      Part *o = Part::parseElement( e, &ok );
      if ( ok ) result->addPart( o );
    }
  }


  if ( ok ) *ok = true;
  return result;
}

void Parts::writeElement( QXmlStreamWriter &xml ) const
{
  if ( !mPartList.isEmpty() ) {
    xml.writeStartElement( "parts" );
    foreach( Part* e, mPartList ) {
      if (e)
        e->writeElement( xml );
    }
    xml.writeEndElement();
  }
}


Port::Port()
  : mSide(0), mSide_set(false), mCoord(0.0), mCoord_set(false), mDirection(Direction_Invalid)
{
}

Port::~Port()
{
}

void Port::setName( const QString &v )
{
  mName = v;
}

QString Port::name() const
{
  return mName;
}

void Port::setSide( const int v )
{
  mSide_set = true;
  mSide = v;
}

int Port::side() const
{
  return mSide;
}

bool Port::sideSet() const
{
  return mSide_set;
}

void Port::setCoord( const double v )
{
  mCoord_set = true;
  mCoord = v;
}

double Port::coord() const
{
  return mCoord;
}

bool Port::coordSet() const
{
  return mCoord_set;
}

void Port::setDirection( const DirectionEnum &v )
{
  mDirection = v;
}

Port::DirectionEnum Port::direction() const
{
  return mDirection;
}

Port::DirectionEnum Port::directionEnumFromString( const QString & v, bool *ok )
{
  if (ok) *ok = true;

  if ( v == "nc" ) {
    return Direction_nc;
  } else if ( v == "in" ) {
    return Direction_in;
  } else if ( v == "out" ) {
    return Direction_out;
  } else if ( v == "io" ) {
    return Direction_io;
  } else if ( v == "oc" ) {
    return Direction_oc;
  } else if ( v == "pwr" ) {
    return Direction_pwr;
  } else if ( v == "pas" ) {
    return Direction_pas;
  } else if ( v == "hiz" ) {
    return Direction_hiz;
  } else {
    if (ok) *ok = false;
    return Direction_Invalid;
  }

  return Direction_Invalid;
}

QString Port::directionEnumToString( const DirectionEnum & v )
{
  switch( v ) {
  case Direction_nc: return "nc";
  case Direction_in: return "in";
  case Direction_out: return "out";
  case Direction_io: return "io";
  case Direction_oc: return "oc";
  case Direction_pwr: return "pwr";
  case Direction_pas: return "pas";
  case Direction_hiz: return "hiz";
  case Direction_Invalid:
  default:
    qCritical() << "Unable to serialize a(n) DirectionEnum enum because it has invalid value:" << v;
    return QString();
  }
}

Port *Port::parseElement( const QDomElement &element, bool *ok )
{
  if ( element.tagName() != "port" ) {
    qCritical() << "Expected 'port', got '" << element.tagName() << "'.";
    if ( ok ) *ok = false;
    return nullptr;
  }

  Port* result = new Port();

  result->setName( element.attribute( "name" ) );
  if (element.hasAttribute("side"))
    result->setSide( element.attribute( "side" ).toInt() );
  if (element.hasAttribute("coord"))
    result->setCoord( element.attribute( "coord" ).toDouble() );
  if (element.hasAttribute("direction"))  {
    DirectionEnum direction = directionEnumFromString( element.attribute( "direction" ), ok  );
    if (ok && !(*ok)) {
      qCritical() << "Invalid string: \"" << element.attribute( "direction" ) << "\" in the \"direction\" element";
      return nullptr;
    } else {
      result->setDirection( direction );
    }
  } else {
    // default value
    result->setDirection(Direction_io);
  }

  if ( ok ) *ok = true;
  return result;
}

void Port::writeElement( QXmlStreamWriter &xml ) const
{
  xml.writeStartElement( "port" );
  if (!mName.isEmpty())
    xml.writeAttribute("name", mName );
  if (mSide_set)
    xml.writeAttribute("side", QString::number( mSide ) );
  if (mCoord_set)
    xml.writeAttribute("coord", QString::number( mCoord ) );
  if (mDirection != Direction_Invalid)
    xml.writeAttribute("direction", directionEnumToString(mDirection));
  xml.writeEndElement();
}


Ports::Ports()
{
}

Ports::~Ports()
{
}

void Ports::addPort( Port* v )
{
  mPortList.append( v );
}

void Ports::setPortList( const Port::List &v )
{
  mPortList = v;
}

Port::List *Ports::portList()
{
  return &mPortList;
}

Ports *Ports::parseElement( const QDomElement &element, bool *ok )
{
  if ( element.tagName() != "ports" ) {
    qCritical() << "Expected 'ports', got '" << element.tagName() << "'.";
    if ( ok ) *ok = false;
    return nullptr;
  }

  Ports* result = new Ports();

  QDomNode n;
  for( n = element.firstChild(); !n.isNull(); n = n.nextSibling() ) {
    QDomElement e = n.toElement();
    if ( e.tagName() == "port" ) {
      bool ok;
      Port *o = Port::parseElement( e, &ok );
      if ( ok ) result->addPort( o );
    }
  }


  if ( ok ) *ok = true;
  return result;
}

void Ports::writeElement( QXmlStreamWriter &xml ) const
{
  if ( !mPortList.isEmpty() ) {
    xml.writeStartElement( "ports" );
    foreach( Port* e, mPortList ) {
      if (e)
        e->writeElement( xml );
    }
    xml.writeEndElement();
  }
}


Module::Module()
  : mDx(0.0), mDx_set(false), mDy(0.0), mDy_set(false), mDescription(nullptr), mPorts(nullptr), mVariantdefs(nullptr), mParts(nullptr), mSheets(nullptr)
{
}

Module::~Module()
{
}

void Module::setName( const QString &v )
{
  mName = v;
}

QString Module::name() const
{
  return mName;
}

void Module::setPrefix( const QString &v )
{
  mPrefix = v;
}

QString Module::prefix() const
{
  return mPrefix;
}

void Module::setDx( const double v )
{
  mDx_set = true;
  mDx = v;
}

double Module::dx() const
{
  return mDx;
}

bool Module::dxSet() const
{
  return mDx_set;
}

void Module::setDy( const double v )
{
  mDy_set = true;
  mDy = v;
}

double Module::dy() const
{
  return mDy;
}

bool Module::dySet() const
{
  return mDy_set;
}

void Module::setDescription( Description *v )
{
  mDescription = v;
}

Description *Module::description()
{
  return mDescription;
}

void Module::setPorts( Ports *v )
{
  mPorts = v;
}

Ports *Module::ports()
{
  return mPorts;
}

void Module::setVariantdefs( Variantdefs *v )
{
  mVariantdefs = v;
}

Variantdefs *Module::variantdefs()
{
  return mVariantdefs;
}

void Module::setParts( Parts *v )
{
  mParts = v;
}

Parts *Module::parts()
{
  return mParts;
}

void Module::setSheets( Sheets *v )
{
  mSheets = v;
}

Sheets *Module::sheets()
{
  return mSheets;
}

Module *Module::parseElement( const QDomElement &element, bool *ok )
{
  if ( element.tagName() != "module" ) {
    qCritical() << "Expected 'module', got '" << element.tagName() << "'.";
    if ( ok ) *ok = false;
    return nullptr;
  }

  Module* result = new Module();

  QDomNode n;
  for( n = element.firstChild(); !n.isNull(); n = n.nextSibling() ) {
    QDomElement e = n.toElement();
    if ( e.tagName() == "description" ) {
      bool ok;
      Description *o = Description::parseElement( e, &ok );
      if ( ok ) result->setDescription( o );
    }
    else if ( e.tagName() == "ports" ) {
      bool ok;
      Ports *o = Ports::parseElement( e, &ok );
      if ( ok ) result->setPorts( o );
    }
    else if ( e.tagName() == "variantdefs" ) {
      bool ok;
      Variantdefs *o = Variantdefs::parseElement( e, &ok );
      if ( ok ) result->setVariantdefs( o );
    }
    else if ( e.tagName() == "parts" ) {
      bool ok;
      Parts *o = Parts::parseElement( e, &ok );
      if ( ok ) result->setParts( o );
    }
    else if ( e.tagName() == "sheets" ) {
      bool ok;
      Sheets *o = Sheets::parseElement( e, &ok );
      if ( ok ) result->setSheets( o );
    }
  }

  result->setName( element.attribute( "name" ) );
  result->setPrefix( element.attribute( "prefix" ) );
  if (element.hasAttribute("dx"))
    result->setDx( element.attribute( "dx" ).toDouble() );
  if (element.hasAttribute("dy"))
    result->setDy( element.attribute( "dy" ).toDouble() );

  if ( ok ) *ok = true;
  return result;
}

void Module::writeElement( QXmlStreamWriter &xml ) const
{
  xml.writeStartElement( "module" );
  if (!mName.isEmpty())
    xml.writeAttribute("name", mName );
  if (!mPrefix.isEmpty())
    xml.writeAttribute("prefix", mPrefix );
  if (mDx_set)
    xml.writeAttribute("dx", QString::number( mDx ) );
  if (mDy_set)
    xml.writeAttribute("dy", QString::number( mDy ) );
  if (mDescription)
    mDescription->writeElement( xml );
  if (mPorts)
    mPorts->writeElement( xml );
  if (mVariantdefs)
    mVariantdefs->writeElement( xml );
  if (mParts)
    mParts->writeElement( xml );
  if (mSheets)
    mSheets->writeElement( xml );
  xml.writeEndElement();
}


Modules::Modules()
{
}

Modules::~Modules()
{
}

void Modules::addModule( Module* v )
{
  mModuleList.append( v );
}

void Modules::setModuleList( const Module::List &v )
{
  mModuleList = v;
}

Module::List *Modules::moduleList()
{
  return &mModuleList;
}

Modules *Modules::parseElement( const QDomElement &element, bool *ok )
{
  if ( element.tagName() != "modules" ) {
    qCritical() << "Expected 'modules', got '" << element.tagName() << "'.";
    if ( ok ) *ok = false;
    return nullptr;
  }

  Modules* result = new Modules();

  QDomNode n;
  for( n = element.firstChild(); !n.isNull(); n = n.nextSibling() ) {
    QDomElement e = n.toElement();
    if ( e.tagName() == "module" ) {
      bool ok;
      Module *o = Module::parseElement( e, &ok );
      if ( ok ) result->addModule( o );
    }
  }


  if ( ok ) *ok = true;
  return result;
}

void Modules::writeElement( QXmlStreamWriter &xml ) const
{
  if ( !mModuleList.isEmpty() ) {
    xml.writeStartElement( "modules" );
    foreach( Module* e, mModuleList ) {
      if (e)
        e->writeElement( xml );
    }
    xml.writeEndElement();
  }
}


Schematic::Schematic()
  : mDescription(nullptr), mLibraries(nullptr), mAttributes(nullptr), mVariantdefs(nullptr), mClasses(nullptr), mModules(nullptr), mParts(nullptr), mSheets(nullptr), mErrors(nullptr)
{
}

Schematic::~Schematic()
{
}

void Schematic::setXreflabel( const QString &v )
{
  mXreflabel = v;
}

QString Schematic::xreflabel() const
{
  return mXreflabel;
}

void Schematic::setXrefpart( const QString &v )
{
  mXrefpart = v;
}

QString Schematic::xrefpart() const
{
  return mXrefpart;
}

void Schematic::setDescription( Description *v )
{
  mDescription = v;
}

Description *Schematic::description()
{
  return mDescription;
}

void Schematic::setLibraries( Libraries *v )
{
  mLibraries = v;
}

Libraries *Schematic::libraries()
{
  return mLibraries;
}

void Schematic::setAttributes( Attributes *v )
{
  mAttributes = v;
}

Attributes *Schematic::attributes()
{
  return mAttributes;
}

void Schematic::setVariantdefs( Variantdefs *v )
{
  mVariantdefs = v;
}

Variantdefs *Schematic::variantdefs()
{
  return mVariantdefs;
}

void Schematic::setClasses( Classes *v )
{
  mClasses = v;
}

Classes *Schematic::classes()
{
  return mClasses;
}

void Schematic::setModules( Modules *v )
{
  mModules = v;
}

Modules *Schematic::modules()
{
  return mModules;
}

void Schematic::setParts( Parts *v )
{
  mParts = v;
}

Parts *Schematic::parts()
{
  return mParts;
}

void Schematic::setSheets( Sheets *v )
{
  mSheets = v;
}

Sheets *Schematic::sheets()
{
  return mSheets;
}

void Schematic::setErrors( Errors *v )
{
  mErrors = v;
}

Errors *Schematic::errors()
{
  return mErrors;
}

Schematic *Schematic::parseElement( const QDomElement &element, bool *ok )
{
  if ( element.tagName() != "schematic" ) {
    qCritical() << "Expected 'schematic', got '" << element.tagName() << "'.";
    if ( ok ) *ok = false;
    return nullptr;
  }

  Schematic* result = new Schematic();

  QDomNode n;
  for( n = element.firstChild(); !n.isNull(); n = n.nextSibling() ) {
    QDomElement e = n.toElement();
    if ( e.tagName() == "description" ) {
      bool ok;
      Description *o = Description::parseElement( e, &ok );
      if ( ok ) result->setDescription( o );
    }
    else if ( e.tagName() == "libraries" ) {
      bool ok;
      Libraries *o = Libraries::parseElement( e, &ok );
      if ( ok ) result->setLibraries( o );
    }
    else if ( e.tagName() == "attributes" ) {
      bool ok;
      Attributes *o = Attributes::parseElement( e, &ok );
      if ( ok ) result->setAttributes( o );
    }
    else if ( e.tagName() == "variantdefs" ) {
      bool ok;
      Variantdefs *o = Variantdefs::parseElement( e, &ok );
      if ( ok ) result->setVariantdefs( o );
    }
    else if ( e.tagName() == "classes" ) {
      bool ok;
      Classes *o = Classes::parseElement( e, &ok );
      if ( ok ) result->setClasses( o );
    }
    else if ( e.tagName() == "modules" ) {
      bool ok;
      Modules *o = Modules::parseElement( e, &ok );
      if ( ok ) result->setModules( o );
    }
    else if ( e.tagName() == "parts" ) {
      bool ok;
      Parts *o = Parts::parseElement( e, &ok );
      if ( ok ) result->setParts( o );
    }
    else if ( e.tagName() == "sheets" ) {
      bool ok;
      Sheets *o = Sheets::parseElement( e, &ok );
      if ( ok ) result->setSheets( o );
    }
    else if ( e.tagName() == "errors" ) {
      bool ok;
      Errors *o = Errors::parseElement( e, &ok );
      if ( ok ) result->setErrors( o );
    }
  }

  result->setXreflabel( element.attribute( "xreflabel" ) );
  result->setXrefpart( element.attribute( "xrefpart" ) );

  if ( ok ) *ok = true;
  return result;
}

void Schematic::writeElement( QXmlStreamWriter &xml ) const
{
  xml.writeStartElement( "schematic" );
  if (!mXreflabel.isEmpty())
    xml.writeAttribute("xreflabel", mXreflabel );
  if (!mXrefpart.isEmpty())
    xml.writeAttribute("xrefpart", mXrefpart );
  if (mDescription)
    mDescription->writeElement( xml );
  if (mLibraries)
    mLibraries->writeElement( xml );
  if (mAttributes)
    mAttributes->writeElement( xml );
  if (mVariantdefs)
    mVariantdefs->writeElement( xml );
  if (mClasses)
    mClasses->writeElement( xml );
  if (mModules)
    mModules->writeElement( xml );
  if (mParts)
    mParts->writeElement( xml );
  if (mSheets)
    mSheets->writeElement( xml );
  if (mErrors)
    mErrors->writeElement( xml );
  xml.writeEndElement();
}


Drawing::Drawing()
  : mLibrary(nullptr), mSchematic(nullptr), mBoard(nullptr), mSettings(nullptr), mGrid(nullptr), mLayers(nullptr)
{
}

Drawing::~Drawing()
{
}

void Drawing::setLibrary( Library *v )
{
  mLibrary = v;
}

Library *Drawing::library()
{
  return mLibrary;
}

void Drawing::setSchematic( Schematic *v )
{
  mSchematic = v;
}

Schematic *Drawing::schematic()
{
  return mSchematic;
}

void Drawing::setBoard( Board *v )
{
  mBoard = v;
}

Board *Drawing::board()
{
  return mBoard;
}

void Drawing::setSettings( Settings *v )
{
  mSettings = v;
}

Settings *Drawing::settings()
{
  return mSettings;
}

void Drawing::setGrid( Grid *v )
{
  mGrid = v;
}

Grid *Drawing::grid()
{
  return mGrid;
}

void Drawing::setLayers( Layers *v )
{
  mLayers = v;
}

Layers *Drawing::layers()
{
  return mLayers;
}

Drawing *Drawing::parseElement( const QDomElement &element, bool *ok )
{
  if ( element.tagName() != "drawing" ) {
    qCritical() << "Expected 'drawing', got '" << element.tagName() << "'.";
    if ( ok ) *ok = false;
    return nullptr;
  }

  Drawing* result = new Drawing();

  QDomNode n;
  for( n = element.firstChild(); !n.isNull(); n = n.nextSibling() ) {
    QDomElement e = n.toElement();
    if ( e.tagName() == "library" ) {
      bool ok;
      Library *o = Library::parseElement( e, &ok );
      if ( ok ) result->setLibrary( o );
    }
    else if ( e.tagName() == "schematic" ) {
      bool ok;
      Schematic *o = Schematic::parseElement( e, &ok );
      if ( ok ) result->setSchematic( o );
    }
    else if ( e.tagName() == "board" ) {
      bool ok;
      Board *o = Board::parseElement( e, &ok );
      if ( ok ) result->setBoard( o );
    }
    else if ( e.tagName() == "settings" ) {
      bool ok;
      Settings *o = Settings::parseElement( e, &ok );
      if ( ok ) result->setSettings( o );
    }
    else if ( e.tagName() == "grid" ) {
      bool ok;
      Grid *o = Grid::parseElement( e, &ok );
      if ( ok ) result->setGrid( o );
    }
    else if ( e.tagName() == "layers" ) {
      bool ok;
      Layers *o = Layers::parseElement( e, &ok );
      if ( ok ) result->setLayers( o );
    }
  }


  if ( ok ) *ok = true;
  return result;
}

void Drawing::writeElement( QXmlStreamWriter &xml ) const
{
  xml.writeStartElement( "drawing" );
  if (mLibrary)
    mLibrary->writeElement( xml );
  if (mSchematic)
    mSchematic->writeElement( xml );
  if (mBoard)
    mBoard->writeElement( xml );
  if (mSettings)
    mSettings->writeElement( xml );
  if (mGrid)
    mGrid->writeElement( xml );
  if (mLayers)
    mLayers->writeElement( xml );
  xml.writeEndElement();
}


Note::Note()
  : mVersion(0.0), mVersion_set(false), mSeverity(Severity_Invalid)
{
}

Note::~Note()
{
}

void Note::setVersion( const double v )
{
  mVersion_set = true;
  mVersion = v;
}

double Note::version() const
{
  return mVersion;
}

bool Note::versionSet() const
{
  return mVersion_set;
}

void Note::setSeverity( const SeverityEnum &v )
{
  mSeverity = v;
}

Note::SeverityEnum Note::severity() const
{
  return mSeverity;
}

void Note::setValue( const QString &v )
{
  mValue = v;
}

QString Note::value() const
{
  return mValue;
}

Note::SeverityEnum Note::severityEnumFromString( const QString & v, bool *ok )
{
  if (ok) *ok = true;

  if ( v == "info" ) {
    return Severity_info;
  } else if ( v == "warning" ) {
    return Severity_warning;
  } else if ( v == "error" ) {
    return Severity_error;
  } else {
    if (ok) *ok = false;
    return Severity_Invalid;
  }

  return Severity_Invalid;
}

QString Note::severityEnumToString( const SeverityEnum & v )
{
  switch( v ) {
  case Severity_info: return "info";
  case Severity_warning: return "warning";
  case Severity_error: return "error";
  case Severity_Invalid:
  default:
    qCritical() << "Unable to serialize a(n) SeverityEnum enum because it has invalid value:" << v;
    return QString();
  }
}

Note *Note::parseElement( const QDomElement &element, bool *ok )
{
  if ( element.tagName() != "note" ) {
    qCritical() << "Expected 'note', got '" << element.tagName() << "'.";
    if ( ok ) *ok = false;
    return nullptr;
  }

  Note* result = new Note();

  result->setValue( element.text() );
  if (element.hasAttribute("version"))
    result->setVersion( element.attribute( "version" ).toDouble() );
  SeverityEnum severity = severityEnumFromString( element.attribute( "severity" ), ok  );
  if (ok && !(*ok)) {
    qCritical() << "Invalid string: \"" << element.attribute( "severity" ) << "\" in the \"severity\" element";
    return nullptr;
  } else {
    result->setSeverity( severity );
  }

  if ( ok ) *ok = true;
  return result;
}

void Note::writeElement( QXmlStreamWriter &xml ) const
{
  if ( !value().isEmpty() ) {
    xml.writeStartElement( "note" );
    if (mVersion_set)
      xml.writeAttribute("version", QString::number( mVersion ) );
    if (mSeverity != Severity_Invalid)
      xml.writeAttribute("severity", severityEnumToString(mSeverity));
    xml.writeCharacters( value() );
    xml.writeEndElement();
  }
}


Compatibility::Compatibility()
{
}

Compatibility::~Compatibility()
{
}

void Compatibility::addNote( Note* v )
{
  mNoteList.append( v );
}

void Compatibility::setNoteList( const Note::List &v )
{
  mNoteList = v;
}

Note::List *Compatibility::noteList()
{
  return &mNoteList;
}

Compatibility *Compatibility::parseElement( const QDomElement &element, bool *ok )
{
  if ( element.tagName() != "compatibility" ) {
    qCritical() << "Expected 'compatibility', got '" << element.tagName() << "'.";
    if ( ok ) *ok = false;
    return nullptr;
  }

  Compatibility* result = new Compatibility();

  QDomNode n;
  for( n = element.firstChild(); !n.isNull(); n = n.nextSibling() ) {
    QDomElement e = n.toElement();
    if ( e.tagName() == "note" ) {
      bool ok;
      Note *o = Note::parseElement( e, &ok );
      if ( ok ) result->addNote( o );
    }
  }


  if ( ok ) *ok = true;
  return result;
}

void Compatibility::writeElement( QXmlStreamWriter &xml ) const
{
  if ( !mNoteList.isEmpty() ) {
    xml.writeStartElement( "compatibility" );
    foreach( Note* e, mNoteList ) {
      if (e)
        e->writeElement( xml );
    }
    xml.writeEndElement();
  }
}


Eagle::Eagle()
  : mCompatibility(nullptr), mDrawing(nullptr)
{
}

Eagle::~Eagle()
{
}

void Eagle::setVersion( const QString &v )
{
  mVersion = v;
}

QString Eagle::version() const
{
  return mVersion;
}

void Eagle::setCompatibility( Compatibility *v )
{
  mCompatibility = v;
}

Compatibility *Eagle::compatibility()
{
  return mCompatibility;
}

void Eagle::setDrawing( Drawing *v )
{
  mDrawing = v;
}

Drawing *Eagle::drawing()
{
  return mDrawing;
}

Eagle *Eagle::parseElement( const QDomElement &element, bool *ok )
{
  if ( element.tagName() != "eagle" ) {
    qCritical() << "Expected 'eagle', got '" << element.tagName() << "'.";
    if ( ok ) *ok = false;
    return nullptr;
  }

  Eagle* result = new Eagle();

  QDomNode n;
  for( n = element.firstChild(); !n.isNull(); n = n.nextSibling() ) {
    QDomElement e = n.toElement();
    if ( e.tagName() == "compatibility" ) {
      bool ok;
      Compatibility *o = Compatibility::parseElement( e, &ok );
      if ( ok ) result->setCompatibility( o );
    }
    else if ( e.tagName() == "drawing" ) {
      bool ok;
      Drawing *o = Drawing::parseElement( e, &ok );
      if ( ok ) result->setDrawing( o );
    }
  }

  result->setVersion( element.attribute( "version" ) );

  if ( ok ) *ok = true;
  return result;
}

void Eagle::writeElement( QXmlStreamWriter &xml ) const
{
  xml.writeStartElement( "eagle" );
  if (!mVersion.isEmpty())
    xml.writeAttribute("version", mVersion );
  if (mCompatibility)
    mCompatibility->writeElement( xml );
  if (mDrawing)
    mDrawing->writeElement( xml );
  xml.writeEndElement();
}

Eagle *Eagle::parseFile( const QString &filename, bool *ok )
{
  QFile file( filename );
  if ( !file.open( QIODevice::ReadOnly ) ) {
    qCritical() << "Unable to open file '" << filename << "'";
    if ( ok ) *ok = false;
    return nullptr;
  }

  QString errorMsg;
  int errorLine, errorCol;
  QDomDocument doc;
  if ( !doc.setContent( &file, false, &errorMsg, &errorLine, &errorCol ) ) {
    qCritical() << errorMsg << " at " << errorLine << "," << errorCol;
    if ( ok ) *ok = false;
    return nullptr;
  }

  bool documentOk;
  Eagle* c = parseElement( doc.documentElement(), &documentOk );
  if ( ok ) {
    *ok = documentOk;
  }
  return c;
}

Eagle *Eagle::parseString( const QString &xml, bool *ok )
{
  QString errorMsg;
  int errorLine, errorCol;
  QDomDocument doc;
  if ( !doc.setContent( xml, false, &errorMsg, &errorLine, &errorCol ) ) {
    qCritical() << errorMsg << " at " << errorLine << "," << errorCol;
    if ( ok ) *ok = false;
    return nullptr;
  }

  bool documentOk;
  Eagle* c = parseElement( doc.documentElement(), &documentOk );
  if ( ok ) {
    *ok = documentOk;
  }
  return c;
}

bool Eagle::writeFile( const QString &filename ) const
{
  QFile file( filename );
  if ( !file.open( QIODevice::WriteOnly ) ) {
    qCritical() << "Unable to open file '" << filename << "'";
    return false;
  }

  QXmlStreamWriter xml( &file );
  xml.setAutoFormatting( true );
  xml.setAutoFormattingIndent( 2 );
  xml.writeStartDocument( "1.0" );
  writeElement( xml );
  xml.writeEndDocument();
  file.close();

  return true;
}


